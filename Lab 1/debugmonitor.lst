680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 02 Dec 2020      Time: 22:44:35          Source: C:\USERS\VICTO\DOCUMENTS\ELEC4THYEAR\CPEN412\LABS\DEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
          0804 0000    5   StackPointerVal     equ $08040000      when using sram
                       6   ;StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
          0803 0000   11   RamVectorTable      equ $08030000      when using sram
                      12   ;RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0804 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0803 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0803 
00000486  00C4      
00000488  23FC 0803  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0546 0803 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  2F04      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0803  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0803  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0803  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0803  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0803 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0803  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0803  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0803  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0803  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0803  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0803  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0803  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0803  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0803  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0803  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0803  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0803  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0803  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0803  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0803  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0803  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0803  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0803  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0803  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0803  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0803  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0803  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0803  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0803  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0803  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0803  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0803  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0803  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0803  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0803  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0803  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0803  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0803  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0803  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0803  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0803  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0803  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0803  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0803  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0803  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0803  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0803  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0803  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0803  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0803  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0803  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0803  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0803  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0803  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0803  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0803  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0803  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0803  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0803  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0803  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0803 
00000714  00D8      
00000716  33DF 0803  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0803  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0803  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0803  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0803  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0803  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0803  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0803  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0803  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0803  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0803  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0803  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0803  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0803  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0803  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0803  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0803  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0803  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0803  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0803  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0803  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0803  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0803  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0803  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0803  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0803  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0803  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0803  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0803  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0803  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0803  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0803  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0803  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0803  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0803  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0803  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0803  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2378      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0803  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0803  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0803  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0803  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0803  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0803  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0803  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0803  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0803  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0803  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0803  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0803  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0803  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0803  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0803  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0803  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0803  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0803  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0803  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0803  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0803  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0803  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0803  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0803  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0803  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0803  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0803  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0803  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0803  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480[LAB5]\M68KV6.0 - 800BY480 - (VERILOG) FOR STUDENTS (2020)\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     478   ; unsigned int i, x, y, z, PortA_Count;
                     479   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     480   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     481   ; unsigned int d0, d1, d2, d3, d4, d5, d6, d7;
                     482   ; unsigned int a0, a1, a2, a3, a4, a5, a6;
                     483   ; unsigned int PC, SSP, USP;
                     484   ; unsigned short int SR;
                     485   ; // Breakpoint variables
                     486   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     487   ; unsigned short int BreakPointInstruction[8];           // to hold the instruction opcode at the breakpoint
                     488   ; unsigned int BreakPointSetOrCleared[8];
                     489   ; unsigned int InstructionSize;
                     490   ; // watchpoint variables
                     491   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     492   ; unsigned int WatchPointSetOrCleared[8];
                     493   ; char WatchPointString[8][100];
                     494   ; char    TempString[100];
                     495   ; // SPI Registers
                     496   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                     497   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                     498   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                     499   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                     500   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                     501   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                     502   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                     503   ; int Write_Enable_Command = 0x06;
                     504   ; int Page_Program_Command = 0x02;
                     505   ; int Erase_Chip_Command = 0xC7;
                     506   ; int Read_Status_Register_Command = 0x05;
                     507   ; int Read_Flash_Chip_Command = 0x03;
                     508   ; int First_Address_Byte = 0x00;
                     509   ; int Test_Data_Byte = 0x09;
                     510   ; int Dummy_Data_Byte = 0xFF;
                     511   ; /************************************************************************************
                     512   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     513   ; ************************************************************************************/
                     514   ; void Wait1ms(void)
                     515   ; {
                     516   _Wait1ms:
00000932  2F02       517          move.l    D2,-(A7)
                     518   ; long int  i;
                     519   ; for (i = 0; i < 1000; i++)
00000934  4282       520          clr.l     D2
                     521   Wait1ms_1:
00000936  0C82 0000  522          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       523          bge.s     Wait1ms_3
0000093E  5282       524          addq.l    #1,D2
00000940  60F4       525          bra       Wait1ms_1
                     526   Wait1ms_3:
00000942  241F       527          move.l    (A7)+,D2
00000944  4E75       528          rts
                     529   ; ;
                     530   ; }
                     531   ; /************************************************************************************
                     532   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     533   ; **************************************************************************************/
                     534   ; void Wait3ms(void)
                     535   ; {
                     536   _Wait3ms:
00000946  2F02       537          move.l    D2,-(A7)
                     538   ; int i;
                     539   ; for (i = 0; i < 3; i++)
00000948  4282       540          clr.l     D2
                     541   Wait3ms_1:
0000094A  0C82 0000  542          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       543          bge.s     Wait3ms_3
                     544   ; Wait1ms();
00000952  4EB8 0932  545          jsr       _Wait1ms
00000956  5282       546          addq.l    #1,D2
00000958  60F0       547          bra       Wait3ms_1
                     548   Wait3ms_3:
0000095A  241F       549          move.l    (A7)+,D2
0000095C  4E75       550          rts
                     551   ; }
                     552   ; /*********************************************************************************************
                     553   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     554   ; *********************************************************************************************/
                     555   ; void Init_LCD(void)
                     556   ; {
                     557   _Init_LCD:
                     558   ; LCDcommand = (char)(0x0c);
0000095E  13FC 000C  559          move.b    #12,4194336
00000962  0040 0020 
                     560   ; Wait3ms();
00000966  4EB8 0946  561          jsr       _Wait3ms
                     562   ; LCDcommand = (char)(0x38);
0000096A  13FC 0038  563          move.b    #56,4194336
0000096E  0040 0020 
                     564   ; Wait3ms();
00000972  4EB8 0946  565          jsr       _Wait3ms
00000976  4E75       566          rts
                     567   ; }
                     568   ; /******************************************************************************
                     569   ; *subroutine to output a single character held in d1 to the LCD display
                     570   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     571   ; *current cursor position
                     572   ; *******************************************************************************/
                     573   ; void Outchar(int c)
                     574   ; {
                     575   _Outchar:
00000978  4E56 0000  576          link      A6,#0
                     577   ; LCDdata = (char)(c);
0000097C  202E 0008  578          move.l    8(A6),D0
00000980  13C0 0040  579          move.b    D0,4194338
00000984  0022      
                     580   ; Wait1ms();
00000986  4EB8 0932  581          jsr       _Wait1ms
0000098A  4E5E       582          unlk      A6
0000098C  4E75       583          rts
                     584   ; }
                     585   ; /**********************************************************************************
                     586   ; *subroutine to output a message at the current cursor position of the LCD display
                     587   ; ************************************************************************************/
                     588   ; void OutMess(char* theMessage)
                     589   ; {
                     590   _OutMess:
0000098E  4E56 FFFC  591          link      A6,#-4
                     592   ; char c;
                     593   ; while ((c = *theMessage++) != (char)(0))
                     594   OutMess_1:
00000992  206E 0008  595          move.l    8(A6),A0
00000996  52AE 0008  596          addq.l    #1,8(A6)
0000099A  1D50 FFFF  597          move.b    (A0),-1(A6)
0000099E  1010       598          move.b    (A0),D0
000009A0  6712       599          beq.s     OutMess_3
                     600   ; Outchar(c);
000009A2  122E FFFF  601          move.b    -1(A6),D1
000009A6  4881       602          ext.w     D1
000009A8  48C1       603          ext.l     D1
000009AA  2F01       604          move.l    D1,-(A7)
000009AC  4EB8 0978  605          jsr       _Outchar
000009B0  584F       606          addq.w    #4,A7
000009B2  60DE       607          bra       OutMess_1
                     608   OutMess_3:
000009B4  4E5E       609          unlk      A6
000009B6  4E75       610          rts
                     611   ; }
                     612   ; /******************************************************************************
                     613   ; *subroutine to clear the line by issuing 24 space characters
                     614   ; *******************************************************************************/
                     615   ; void Clearln(void)
                     616   ; {
                     617   _Clearln:
000009B8  2F02       618          move.l    D2,-(A7)
                     619   ; unsigned char i;
                     620   ; for (i = 0; i < 24; i++)
000009BA  4202       621          clr.b     D2
                     622   Clearln_1:
000009BC  0C02 0018  623          cmp.b     #24,D2
000009C0  640E       624          bhs.s     Clearln_3
                     625   ; Outchar(' ');  /* write a space char to the LCD display */
000009C2  4878 0020  626          pea       32
000009C6  4EB8 0978  627          jsr       _Outchar
000009CA  584F       628          addq.w    #4,A7
000009CC  5202       629          addq.b    #1,D2
000009CE  60EC       630          bra       Clearln_1
                     631   Clearln_3:
000009D0  241F       632          move.l    (A7)+,D2
000009D2  4E75       633          rts
                     634   ; }
                     635   ; /******************************************************************************
                     636   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     637   ; *******************************************************************************/
                     638   ; void Oline0(char* theMessage)
                     639   ; {
                     640   _Oline0:
000009D4  4E56 0000  641          link      A6,#0
                     642   ; LCDcommand = (char)(0x80);
000009D8  13FC 0080  643          move.b    #128,4194336
000009DC  0040 0020 
                     644   ; Wait3ms();
000009E0  4EB8 0946  645          jsr       _Wait3ms
                     646   ; Clearln();
000009E4  4EB8 09B8  647          jsr       _Clearln
                     648   ; LCDcommand = (char)(0x80);
000009E8  13FC 0080  649          move.b    #128,4194336
000009EC  0040 0020 
                     650   ; Wait3ms();
000009F0  4EB8 0946  651          jsr       _Wait3ms
                     652   ; OutMess(theMessage);
000009F4  2F2E 0008  653          move.l    8(A6),-(A7)
000009F8  4EB8 098E  654          jsr       _OutMess
000009FC  584F       655          addq.w    #4,A7
000009FE  4E5E       656          unlk      A6
00000A00  4E75       657          rts
                     658   ; }
                     659   ; /******************************************************************************
                     660   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     661   ; *******************************************************************************/
                     662   ; void Oline1(char* theMessage)
                     663   ; {
                     664   _Oline1:
00000A02  4E56 0000  665          link      A6,#0
                     666   ; LCDcommand = (char)(0xC0);
00000A06  13FC 00C0  667          move.b    #192,4194336
00000A0A  0040 0020 
                     668   ; Wait3ms();
00000A0E  4EB8 0946  669          jsr       _Wait3ms
                     670   ; Clearln();
00000A12  4EB8 09B8  671          jsr       _Clearln
                     672   ; LCDcommand = (char)(0xC0);
00000A16  13FC 00C0  673          move.b    #192,4194336
00000A1A  0040 0020 
                     674   ; Wait3ms();
00000A1E  4EB8 0946  675          jsr       _Wait3ms
                     676   ; OutMess(theMessage);
00000A22  2F2E 0008  677          move.l    8(A6),-(A7)
00000A26  4EB8 098E  678          jsr       _OutMess
00000A2A  584F       679          addq.w    #4,A7
00000A2C  4E5E       680          unlk      A6
00000A2E  4E75       681          rts
                     682   ; }
                     683   ; void InstallExceptionHandler(void (*function_ptr)(), int level)
                     684   ; {
                     685   _InstallExceptionHandler:
00000A30  4E56 FFFC  686          link      A6,#-4
                     687   ; volatile long int* RamVectorAddress = (volatile long int*)(StartOfExceptionVectorTable);   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  688          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     689   ; RamVectorAddress[level] = (long int*)(function_ptr);
00000A3C  206E FFFC  690          move.l    -4(A6),A0
00000A40  202E 000C  691          move.l    12(A6),D0
00000A44  E588       692          lsl.l     #2,D0
00000A46  21AE 0008  693          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       694          unlk      A6
00000A4E  4E75       695          rts
                     696   ; }
                     697   ; void TestLEDS(void)
                     698   ; {
                     699   _TestLEDS:
00000A50  48E7 3000  700          movem.l   D2/D3,-(A7)
                     701   ; int delay;
                     702   ; unsigned char count = 0;
00000A54  4202       703          clr.b     D2
                     704   ; while (1) {
                     705   TestLEDS_1:
                     706   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f));
00000A56  1002       707          move.b    D2,D0
00000A58  E908       708          lsl.b     #4,D0
00000A5A  1202       709          move.b    D2,D1
00000A5C  C23C 000F  710          and.b     #15,D1
00000A60  D001       711          add.b     D1,D0
00000A62  13C0 0040  712          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  713          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  714          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  715          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  716          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  717          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  718          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  719          move.b    D0,4194304
00000A90  0000      
                     720   ; for (delay = 0; delay < 200000; delay++)
00000A92  4283       721          clr.l     D3
                     722   TestLEDS_4:
00000A94  0C83 0003  723          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       724          bge.s     TestLEDS_6
00000A9C  5283       725          addq.l    #1,D3
00000A9E  60F4       726          bra       TestLEDS_4
                     727   TestLEDS_6:
                     728   ; ;
                     729   ; count++;
00000AA0  5202       730          addq.b    #1,D2
00000AA2  60B2       731          bra       TestLEDS_1
                     732   ; }
                     733   ; }
                     734   ; void SwitchTest(void)
                     735   ; {
                     736   _SwitchTest:
00000AA4  48E7 3020  737          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  738          lea       _printf.L,A2
00000AAC  33B8      
                     739   ; int i, switches = 0;
00000AAE  4283       740          clr.l     D3
                     741   ; printf("\r\n");
00000AB0  4879 0000  742          pea       @m68kde~1_1.L
00000AB4  3D08      
00000AB6  4E92       743          jsr       (A2)
00000AB8  584F       744          addq.w    #4,A7
                     745   ; while (1) {
                     746   SwitchTest_1:
                     747   ; switches = (PortB << 8) | (PortA);
00000ABA  1039 0040  748          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  749          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       750          lsl.l     #8,D0
00000AC8  1239 0040  751          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  752          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       753          or.l      D1,D0
00000AD6  2600       754          move.l    D0,D3
                     755   ; printf("\rSwitches SW[7-0] = ");
00000AD8  4879 0000  756          pea       @m68kde~1_2.L
00000ADC  3D0C      
00000ADE  4E92       757          jsr       (A2)
00000AE0  584F       758          addq.w    #4,A7
                     759   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00000AE2  243C 0000  760          move.l    #128,D2
00000AE6  0080      
                     761   SwitchTest_4:
00000AE8  0C82 0000  762          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       763          ble.s     SwitchTest_6
                     764   ; if ((switches & i) == 0)
00000AF0  2003       765          move.l    D3,D0
00000AF2  C082       766          and.l     D2,D0
00000AF4  660C       767          bne.s     SwitchTest_7
                     768   ; printf("0");
00000AF6  4879 0000  769          pea       @m68kde~1_3.L
00000AFA  3D22      
00000AFC  4E92       770          jsr       (A2)
00000AFE  584F       771          addq.w    #4,A7
00000B00  600A       772          bra.s     SwitchTest_8
                     773   SwitchTest_7:
                     774   ; else
                     775   ; printf("1");
00000B02  4879 0000  776          pea       @m68kde~1_4.L
00000B06  3D24      
00000B08  4E92       777          jsr       (A2)
00000B0A  584F       778          addq.w    #4,A7
                     779   SwitchTest_8:
00000B0C  E282       780          asr.l     #1,D2
00000B0E  60D8       781          bra       SwitchTest_4
                     782   SwitchTest_6:
00000B10  60A8       783          bra       SwitchTest_1
                     784   ; }
                     785   ; }
                     786   ; }
                     787   ; /*********************************************************************************************
                     788   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     789   ; *********************************************************************************************/
                     790   ; void Init_RS232(void)
                     791   ; {
                     792   _Init_RS232:
                     793   ; RS232_Control = (char)(0x15); //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  794          move.b    #21,4194368
00000B16  0040 0040 
                     795   ; RS232_Baud = (char)(0x1);      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  796          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       797          rts
                     798   ; }
                     799   ; int kbhit(void)
                     800   ; {
                     801   _kbhit:
                     802   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  803          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  804          and.b     #1,D0
00000B2E  0C00 0001  805          cmp.b     #1,D0
00000B32  6604       806          bne.s     kbhit_1
                     807   ; return 1;
00000B34  7001       808          moveq     #1,D0
00000B36  6002       809          bra.s     kbhit_3
                     810   kbhit_1:
                     811   ; else
                     812   ; return 0;
00000B38  4280       813          clr.l     D0
                     814   kbhit_3:
00000B3A  4E75       815          rts
                     816   ; }
                     817   ; /*********************************************************************************************************
                     818   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     819   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     820   ; **  to allow the board to communicate with HyperTerminal Program
                     821   ; **
                     822   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     823   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     824   ; **  call _putch() also
                     825   ; *********************************************************************************************************/
                     826   ; int _putch(int c)
                     827   ; {
                     828   __putch:
00000B3C  4E56 0000  829          link      A6,#0
                     830   ; while (((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     831   _putch_1:
00000B40  1039 0040  832          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  833          and.b     #2,D0
00000B4A  0C00 0002  834          cmp.b     #2,D0
00000B4E  6702       835          beq.s     _putch_3
00000B50  60EE       836          bra       _putch_1
                     837   _putch_3:
                     838   ; ;
                     839   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  840          move.l    8(A6),D0
00000B56  C03C 007F  841          and.b     #127,D0
00000B5A  13C0 0040  842          move.b    D0,4194370
00000B5E  0042      
                     843   ; return c;                                              // putchar() expects the character to be returned
00000B60  202E 0008  844          move.l    8(A6),D0
00000B64  4E5E       845          unlk      A6
00000B66  4E75       846          rts
                     847   ; }
                     848   ; /*********************************************************************************************************
                     849   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     850   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     851   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     852   ; **
                     853   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     854   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     855   ; **  call _getch() also
                     856   ; *********************************************************************************************************/
                     857   ; int _getch(void)
                     858   ; {
                     859   __getch:
00000B68  2F02       860          move.l    D2,-(A7)
                     861   ; int c;
                     862   ; while (((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     863   _getch_1:
00000B6A  1039 0040  864          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  865          and.b     #1,D0
00000B74  0C00 0001  866          cmp.b     #1,D0
00000B78  6702       867          beq.s     _getch_3
00000B7A  60EE       868          bra       _getch_1
                     869   _getch_3:
                     870   ; ;
                     871   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  872          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  873          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  874          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       875          move.l    D0,D2
                     876   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     877   ; if (Echo)
00000B90  4AB9 0803  878          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       879          beq.s     _getch_4
                     880   ; _putch(c);
00000B98  2F02       881          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  882          jsr       __putch
00000B9E  584F       883          addq.w    #4,A7
                     884   _getch_4:
                     885   ; return c;
00000BA0  2002       886          move.l    D2,D0
00000BA2  241F       887          move.l    (A7)+,D2
00000BA4  4E75       888          rts
                     889   ; }
                     890   ; // flush the input stream for any unread characters
                     891   ; void FlushKeyboard(void)
                     892   ; {
                     893   _FlushKeyboard:
00000BA6  4E56 FFFC  894          link      A6,#-4
                     895   ; char c;
                     896   ; while (1) {
                     897   FlushKeyboard_1:
                     898   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  899          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  900          and.b     #1,D0
00000BB4  0C00 0001  901          cmp.b     #1,D0
00000BB8  6610       902          bne.s     FlushKeyboard_4
                     903   ; c = ((char)(RS232_RxData) & (char)(0x7f));
00000BBA  1039 0040  904          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  905          and.b     #127,D0
00000BC4  1D40 FFFF  906          move.b    D0,-1(A6)
00000BC8  6002       907          bra.s     FlushKeyboard_5
                     908   FlushKeyboard_4:
                     909   ; else
                     910   ; return;
00000BCA  6002       911          bra.s     FlushKeyboard_6
                     912   FlushKeyboard_5:
00000BCC  60DC       913          bra       FlushKeyboard_1
                     914   FlushKeyboard_6:
00000BCE  4E5E       915          unlk      A6
00000BD0  4E75       916          rts
                     917   ; }
                     918   ; }
                     919   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     920   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     921   ; char xtod(int c)
                     922   ; {
                     923   _xtod:
00000BD2  4E56 0000  924          link      A6,#0
00000BD6  2F02       925          move.l    D2,-(A7)
00000BD8  242E 0008  926          move.l    8(A6),D2
                     927   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  928          cmp.b     #57,D2
00000BE0  6E08       929          bgt.s     xtod_1
                     930   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       931          move.b    D2,D0
00000BE4  0400 0030  932          sub.b     #48,D0
00000BE8  6014       933          bra.s     xtod_3
                     934   xtod_1:
                     935   ; else if ((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  936          cmp.b     #70,D2
00000BEE  6F08       937          ble.s     xtod_4
                     938   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       939          move.b    D2,D0
00000BF2  0400 0057  940          sub.b     #87,D0
00000BF6  6006       941          bra.s     xtod_3
                     942   xtod_4:
                     943   ; else
                     944   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       945          move.b    D2,D0
00000BFA  0400 0037  946          sub.b     #55,D0
                     947   xtod_3:
00000BFE  241F       948          move.l    (A7)+,D2
00000C00  4E5E       949          unlk      A6
00000C02  4E75       950          rts
                     951   ; }
                     952   ; int Get2HexDigits(char* CheckSumPtr)
                     953   ; {
                     954   _Get2HexDigits:
00000C04  4E56 0000  955          link      A6,#0
00000C08  2F02       956          move.l    D2,-(A7)
                     957   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       958          move.l    D0,-(A7)
00000C0C  4EB8 0B68  959          jsr       __getch
00000C10  2200       960          move.l    D0,D1
00000C12  201F       961          move.l    (A7)+,D0
00000C14  2F01       962          move.l    D1,-(A7)
00000C16  4EB8 0BD2  963          jsr       _xtod
00000C1A  584F       964          addq.w    #4,A7
00000C1C  C0BC 0000  965          and.l     #255,D0
00000C20  00FF      
00000C22  E980       966          asl.l     #4,D0
00000C24  2F00       967          move.l    D0,-(A7)
00000C26  2F01       968          move.l    D1,-(A7)
00000C28  4EB8 0B68  969          jsr       __getch
00000C2C  221F       970          move.l    (A7)+,D1
00000C2E  2F00       971          move.l    D0,-(A7)
00000C30  4EB8 0BD2  972          jsr       _xtod
00000C34  584F       973          addq.w    #4,A7
00000C36  2200       974          move.l    D0,D1
00000C38  201F       975          move.l    (A7)+,D0
00000C3A  C2BC 0000  976          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       977          or.l      D1,D0
00000C42  2400       978          move.l    D0,D2
                     979   ; if (CheckSumPtr)
00000C44  4AAE 0008  980          tst.l     8(A6)
00000C48  6706       981          beq.s     Get2HexDigits_1
                     982   ; *CheckSumPtr += i;
00000C4A  206E 0008  983          move.l    8(A6),A0
00000C4E  D510       984          add.b     D2,(A0)
                     985   Get2HexDigits_1:
                     986   ; return i;
00000C50  2002       987          move.l    D2,D0
00000C52  241F       988          move.l    (A7)+,D2
00000C54  4E5E       989          unlk      A6
00000C56  4E75       990          rts
                     991   ; }
                     992   ; int Get4HexDigits(char* CheckSumPtr)
                     993   ; {
                     994   _Get4HexDigits:
00000C58  4E56 0000  995          link      A6,#0
                     996   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  997          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  998          jsr       _Get2HexDigits
00000C64  584F       999          addq.w    #4,A7
00000C66  E180      1000          asl.l     #8,D0
00000C68  2F00      1001          move.l    D0,-(A7)
00000C6A  2F2E 0008 1002          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04 1003          jsr       _Get2HexDigits
00000C72  584F      1004          addq.w    #4,A7
00000C74  2200      1005          move.l    D0,D1
00000C76  201F      1006          move.l    (A7)+,D0
00000C78  8081      1007          or.l      D1,D0
00000C7A  4E5E      1008          unlk      A6
00000C7C  4E75      1009          rts
                    1010   ; }
                    1011   ; int Get6HexDigits(char* CheckSumPtr)
                    1012   ; {
                    1013   _Get6HexDigits:
00000C7E  4E56 0000 1014          link      A6,#0
                    1015   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1016          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1017          jsr       _Get4HexDigits
00000C8A  584F      1018          addq.w    #4,A7
00000C8C  E180      1019          asl.l     #8,D0
00000C8E  2F00      1020          move.l    D0,-(A7)
00000C90  2F2E 0008 1021          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1022          jsr       _Get2HexDigits
00000C98  584F      1023          addq.w    #4,A7
00000C9A  2200      1024          move.l    D0,D1
00000C9C  201F      1025          move.l    (A7)+,D0
00000C9E  8081      1026          or.l      D1,D0
00000CA0  4E5E      1027          unlk      A6
00000CA2  4E75      1028          rts
                    1029   ; }
                    1030   ; int Get8HexDigits(char* CheckSumPtr)
                    1031   ; {
                    1032   _Get8HexDigits:
00000CA4  4E56 0000 1033          link      A6,#0
                    1034   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1035          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1036          jsr       _Get4HexDigits
00000CB0  584F      1037          addq.w    #4,A7
00000CB2  E180      1038          asl.l     #8,D0
00000CB4  E180      1039          asl.l     #8,D0
00000CB6  2F00      1040          move.l    D0,-(A7)
00000CB8  2F2E 0008 1041          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1042          jsr       _Get4HexDigits
00000CC0  584F      1043          addq.w    #4,A7
00000CC2  2200      1044          move.l    D0,D1
00000CC4  201F      1045          move.l    (A7)+,D0
00000CC6  8081      1046          or.l      D1,D0
00000CC8  4E5E      1047          unlk      A6
00000CCA  4E75      1048          rts
                    1049   ; }
                    1050   ; void DumpMemory(void)   // simple dump memory fn
                    1051   ; {
                    1052   _DumpMemory:
00000CCC  48E7 3C30 1053          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000CD0  45F9 0000 1054          lea       _printf.L,A2
00000CD4  33B8      
00000CD6  47F9 0000 1055          lea       _putch.L,A3
00000CDA  32AA      
                    1056   ; int i, j;
                    1057   ; unsigned char* RamPtr, c; // pointer to where the program is download (assumed)
                    1058   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue");
00000CDC  4879 0000 1059          pea       @m68kde~1_5.L
00000CE0  3D26      
00000CE2  4E92      1060          jsr       (A2)
00000CE4  584F      1061          addq.w    #4,A7
                    1062   ; printf("\r\nEnter Start Address: ");
00000CE6  4879 0000 1063          pea       @m68kde~1_6.L
00000CEA  3D60      
00000CEC  4E92      1064          jsr       (A2)
00000CEE  584F      1065          addq.w    #4,A7
                    1066   ; RamPtr = Get8HexDigits(0);
00000CF0  42A7      1067          clr.l     -(A7)
00000CF2  4EB8 0CA4 1068          jsr       _Get8HexDigits
00000CF6  584F      1069          addq.w    #4,A7
00000CF8  2600      1070          move.l    D0,D3
                    1071   ; while (1) {
                    1072   DumpMemory_1:
                    1073   ; for (i = 0; i < 16; i++) {
00000CFA  4285      1074          clr.l     D5
                    1075   DumpMemory_4:
00000CFC  0C85 0000 1076          cmp.l     #16,D5
00000D00  0010      
00000D02  6C00 0096 1077          bge       DumpMemory_6
                    1078   ; printf("\r\n%08x ", RamPtr);
00000D06  2F03      1079          move.l    D3,-(A7)
00000D08  4879 0000 1080          pea       @m68kde~1_7.L
00000D0C  3D78      
00000D0E  4E92      1081          jsr       (A2)
00000D10  504F      1082          addq.w    #8,A7
                    1083   ; for (j = 0; j < 16; j++) {
00000D12  4282      1084          clr.l     D2
                    1085   DumpMemory_7:
00000D14  0C82 0000 1086          cmp.l     #16,D2
00000D18  0010      
00000D1A  6C24      1087          bge.s     DumpMemory_9
                    1088   ; printf("%02X", RamPtr[j]);
00000D1C  2043      1089          move.l    D3,A0
00000D1E  1230 2800 1090          move.b    0(A0,D2.L),D1
00000D22  C2BC 0000 1091          and.l     #255,D1
00000D26  00FF      
00000D28  2F01      1092          move.l    D1,-(A7)
00000D2A  4879 0000 1093          pea       @m68kde~1_8.L
00000D2E  3D80      
00000D30  4E92      1094          jsr       (A2)
00000D32  504F      1095          addq.w    #8,A7
                    1096   ; putchar(' ');
00000D34  4878 0020 1097          pea       32
00000D38  4E93      1098          jsr       (A3)
00000D3A  584F      1099          addq.w    #4,A7
00000D3C  5282      1100          addq.l    #1,D2
00000D3E  60D4      1101          bra       DumpMemory_7
                    1102   DumpMemory_9:
                    1103   ; }
                    1104   ; // now display the data as ASCII at the end
                    1105   ; printf("  ");
00000D40  4879 0000 1106          pea       @m68kde~1_9.L
00000D44  3D86      
00000D46  4E92      1107          jsr       (A2)
00000D48  584F      1108          addq.w    #4,A7
                    1109   ; for (j = 0; j < 16; j++) {
00000D4A  4282      1110          clr.l     D2
                    1111   DumpMemory_10:
00000D4C  0C82 0000 1112          cmp.l     #16,D2
00000D50  0010      
00000D52  6C00 003A 1113          bge       DumpMemory_12
                    1114   ; c = ((char)(RamPtr[j]) & 0x7f);
00000D56  2043      1115          move.l    D3,A0
00000D58  1030 2800 1116          move.b    0(A0,D2.L),D0
00000D5C  C03C 007F 1117          and.b     #127,D0
00000D60  1800      1118          move.b    D0,D4
                    1119   ; if ((c > (char)(0x7f)) || (c < ' '))
00000D62  0C04 007F 1120          cmp.b     #127,D4
00000D66  6206      1121          bhi.s     DumpMemory_15
00000D68  0C04 0020 1122          cmp.b     #32,D4
00000D6C  640A      1123          bhs.s     DumpMemory_13
                    1124   DumpMemory_15:
                    1125   ; putchar('.');
00000D6E  4878 002E 1126          pea       46
00000D72  4E93      1127          jsr       (A3)
00000D74  584F      1128          addq.w    #4,A7
00000D76  6012      1129          bra.s     DumpMemory_14
                    1130   DumpMemory_13:
                    1131   ; else
                    1132   ; putchar(RamPtr[j]);
00000D78  2043      1133          move.l    D3,A0
00000D7A  1230 2800 1134          move.b    0(A0,D2.L),D1
00000D7E  C2BC 0000 1135          and.l     #255,D1
00000D82  00FF      
00000D84  2F01      1136          move.l    D1,-(A7)
00000D86  4E93      1137          jsr       (A3)
00000D88  584F      1138          addq.w    #4,A7
                    1139   DumpMemory_14:
00000D8A  5282      1140          addq.l    #1,D2
00000D8C  60BE      1141          bra       DumpMemory_10
                    1142   DumpMemory_12:
                    1143   ; }
                    1144   ; RamPtr = RamPtr + 16;
00000D8E  0683 0000 1145          add.l     #16,D3
00000D92  0010      
00000D94  5285      1146          addq.l    #1,D5
00000D96  6000 FF64 1147          bra       DumpMemory_4
                    1148   DumpMemory_6:
                    1149   ; }
                    1150   ; printf("\r\n");
00000D9A  4879 0000 1151          pea       @m68kde~1_1.L
00000D9E  3D08      
00000DA0  4E92      1152          jsr       (A2)
00000DA2  584F      1153          addq.w    #4,A7
                    1154   ; c = _getch();
00000DA4  4EB8 0B68 1155          jsr       __getch
00000DA8  1800      1156          move.b    D0,D4
                    1157   ; if (c == 0x1b)          // break on ESC
00000DAA  0C04 001B 1158          cmp.b     #27,D4
00000DAE  6602      1159          bne.s     DumpMemory_16
                    1160   ; break;
00000DB0  6004      1161          bra.s     DumpMemory_3
                    1162   DumpMemory_16:
00000DB2  6000 FF46 1163          bra       DumpMemory_1
                    1164   DumpMemory_3:
00000DB6  4CDF 0C3C 1165          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DBA  4E75      1166          rts
                    1167   ; }
                    1168   ; }
                    1169   ; void FillMemory()
                    1170   ; {
                    1171   _FillMemory:
00000DBC  48E7 3820 1172          movem.l   D2/D3/D4/A2,-(A7)
00000DC0  45F9 0000 1173          lea       _printf.L,A2
00000DC4  33B8      
                    1174   ; char* StartRamPtr, * EndRamPtr;
                    1175   ; unsigned char FillData;
                    1176   ; printf("\r\nFill Memory Block");
00000DC6  4879 0000 1177          pea       @m68kde~1_10.L
00000DCA  3D8A      
00000DCC  4E92      1178          jsr       (A2)
00000DCE  584F      1179          addq.w    #4,A7
                    1180   ; printf("\r\nEnter Start Address: ");
00000DD0  4879 0000 1181          pea       @m68kde~1_6.L
00000DD4  3D60      
00000DD6  4E92      1182          jsr       (A2)
00000DD8  584F      1183          addq.w    #4,A7
                    1184   ; StartRamPtr = Get8HexDigits(0);
00000DDA  42A7      1185          clr.l     -(A7)
00000DDC  4EB8 0CA4 1186          jsr       _Get8HexDigits
00000DE0  584F      1187          addq.w    #4,A7
00000DE2  2400      1188          move.l    D0,D2
                    1189   ; printf("\r\nEnter End Address: ");
00000DE4  4879 0000 1190          pea       @m68kde~1_11.L
00000DE8  3D9E      
00000DEA  4E92      1191          jsr       (A2)
00000DEC  584F      1192          addq.w    #4,A7
                    1193   ; EndRamPtr = Get8HexDigits(0);
00000DEE  42A7      1194          clr.l     -(A7)
00000DF0  4EB8 0CA4 1195          jsr       _Get8HexDigits
00000DF4  584F      1196          addq.w    #4,A7
00000DF6  2800      1197          move.l    D0,D4
                    1198   ; printf("\r\nEnter Fill Data: ");
00000DF8  4879 0000 1199          pea       @m68kde~1_12.L
00000DFC  3DB4      
00000DFE  4E92      1200          jsr       (A2)
00000E00  584F      1201          addq.w    #4,A7
                    1202   ; FillData = Get2HexDigits(0);
00000E02  42A7      1203          clr.l     -(A7)
00000E04  4EB8 0C04 1204          jsr       _Get2HexDigits
00000E08  584F      1205          addq.w    #4,A7
00000E0A  1600      1206          move.b    D0,D3
                    1207   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData);
00000E0C  C6BC 0000 1208          and.l     #255,D3
00000E10  00FF      
00000E12  2F03      1209          move.l    D3,-(A7)
00000E14  2F04      1210          move.l    D4,-(A7)
00000E16  2F02      1211          move.l    D2,-(A7)
00000E18  4879 0000 1212          pea       @m68kde~1_13.L
00000E1C  3DC8      
00000E1E  4E92      1213          jsr       (A2)
00000E20  DEFC 0010 1214          add.w     #16,A7
                    1215   ; while (StartRamPtr < EndRamPtr)
                    1216   FillMemory_1:
00000E24  B484      1217          cmp.l     D4,D2
00000E26  6408      1218          bhs.s     FillMemory_3
                    1219   ; *StartRamPtr++ = FillData;
00000E28  2042      1220          move.l    D2,A0
00000E2A  5282      1221          addq.l    #1,D2
00000E2C  1083      1222          move.b    D3,(A0)
00000E2E  60F4      1223          bra       FillMemory_1
                    1224   FillMemory_3:
00000E30  4CDF 041C 1225          movem.l   (A7)+,D2/D3/D4/A2
00000E34  4E75      1226          rts
                    1227   ; }
                    1228   ; void Load_SRecordFile()
                    1229   ; {
                    1230   _Load_SRecordFile:
00000E36  4E56 FFDC 1231          link      A6,#-36
00000E3A  48E7 3F3C 1232          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E3E  45EE FFFA 1233          lea       -6(A6),A2
00000E42  47F8 0C04 1234          lea       _Get2HexDigits.L,A3
00000E46  49F9 0000 1235          lea       _printf.L,A4
00000E4A  33B8      
                    1236   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0;
00000E4C  42AE FFEE 1237          clr.l     -18(A6)
00000E50  3A7C 0000 1238          move.w    #0,A5
                    1239   ; int result, ByteCount;
                    1240   ; char c, CheckSum, ReadCheckSum, HeaderType;
                    1241   ; char* RamPtr;                          // pointer to Memory where downloaded program will be stored
                    1242   ; LoadFailed = 0;                        //assume LOAD operation will pass
00000E54  7E00      1243          moveq     #0,D7
                    1244   ; AddressFail = 0;
00000E56  42AE FFEA 1245          clr.l     -22(A6)
                    1246   ; Echo = 0;                              // don't echo S records during download
00000E5A  42B9 0803 1247          clr.l     _Echo.L
00000E5E  00E0      
                    1248   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n");
00000E60  4879 0000 1249          pea       @m68kde~1_14.L
00000E64  3DF8      
00000E66  4E94      1250          jsr       (A4)
00000E68  584F      1251          addq.w    #4,A7
                    1252   ; while (1) {
                    1253   Load_SRecordFile_1:
                    1254   ; CheckSum = 0;
00000E6A  4212      1255          clr.b     (A2)
                    1256   ; do {
                    1257   Load_SRecordFile_4:
                    1258   ; c = toupper(_getch());
00000E6C  2F00      1259          move.l    D0,-(A7)
00000E6E  4EB8 0B68 1260          jsr       __getch
00000E72  2200      1261          move.l    D0,D1
00000E74  201F      1262          move.l    (A7)+,D0
00000E76  2F01      1263          move.l    D1,-(A7)
00000E78  4EB9 0000 1264          jsr       _toupper
00000E7C  338C      
00000E7E  584F      1265          addq.w    #4,A7
00000E80  1C00      1266          move.b    D0,D6
                    1267   ; if (c == 0x1b)      // if break
00000E82  0C06 001B 1268          cmp.b     #27,D6
00000E86  6604      1269          bne.s     Load_SRecordFile_6
                    1270   ; return;
00000E88  6000 0132 1271          bra       Load_SRecordFile_8
                    1272   Load_SRecordFile_6:
00000E8C  0C06 0053 1273          cmp.b     #83,D6
00000E90  66DA      1274          bne       Load_SRecordFile_4
                    1275   ; } while (c != (char)('S'));   // wait for S start of header
                    1276   ; HeaderType = _getch();
00000E92  4EB8 0B68 1277          jsr       __getch
00000E96  1600      1278          move.b    D0,D3
                    1279   ; if (HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000E98  0C03 0030 1280          cmp.b     #48,D3
00000E9C  6706      1281          beq.s     Load_SRecordFile_11
00000E9E  0C03 0035 1282          cmp.b     #53,D3
00000EA2  6604      1283          bne.s     Load_SRecordFile_9
                    1284   Load_SRecordFile_11:
                    1285   ; continue;
00000EA4  6000 00D2 1286          bra       Load_SRecordFile_23
                    1287   Load_SRecordFile_9:
                    1288   ; if (HeaderType >= (char)('7'))
00000EA8  0C03 0037 1289          cmp.b     #55,D3
00000EAC  6D04      1290          blt.s     Load_SRecordFile_12
                    1291   ; break;                 // end load on s7,s8,s9 records
00000EAE  6000 00CC 1292          bra       Load_SRecordFile_3
                    1293   Load_SRecordFile_12:
                    1294   ; // get the bytecount
                    1295   ; ByteCount = Get2HexDigits(&CheckSum);
00000EB2  2F0A      1296          move.l    A2,-(A7)
00000EB4  4E93      1297          jsr       (A3)
00000EB6  584F      1298          addq.w    #4,A7
00000EB8  2D40 FFF6 1299          move.l    D0,-10(A6)
                    1300   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1301   ; if (HeaderType == (char)('1')) {
00000EBC  0C03 0031 1302          cmp.b     #49,D3
00000EC0  660E      1303          bne.s     Load_SRecordFile_14
                    1304   ; AddressSize = 2;       // 2 byte address
00000EC2  7A02      1305          moveq     #2,D5
                    1306   ; Address = Get4HexDigits(&CheckSum);
00000EC4  2F0A      1307          move.l    A2,-(A7)
00000EC6  4EB8 0C58 1308          jsr       _Get4HexDigits
00000ECA  584F      1309          addq.w    #4,A7
00000ECC  2800      1310          move.l    D0,D4
00000ECE  6020      1311          bra.s     Load_SRecordFile_17
                    1312   Load_SRecordFile_14:
                    1313   ; }
                    1314   ; else if (HeaderType == (char)('2')) {
00000ED0  0C03 0032 1315          cmp.b     #50,D3
00000ED4  660E      1316          bne.s     Load_SRecordFile_16
                    1317   ; AddressSize = 3;       // 3 byte address
00000ED6  7A03      1318          moveq     #3,D5
                    1319   ; Address = Get6HexDigits(&CheckSum);
00000ED8  2F0A      1320          move.l    A2,-(A7)
00000EDA  4EB8 0C7E 1321          jsr       _Get6HexDigits
00000EDE  584F      1322          addq.w    #4,A7
00000EE0  2800      1323          move.l    D0,D4
00000EE2  600C      1324          bra.s     Load_SRecordFile_17
                    1325   Load_SRecordFile_16:
                    1326   ; }
                    1327   ; else {
                    1328   ; AddressSize = 4;       // 4 byte address
00000EE4  7A04      1329          moveq     #4,D5
                    1330   ; Address = Get8HexDigits(&CheckSum);
00000EE6  2F0A      1331          move.l    A2,-(A7)
00000EE8  4EB8 0CA4 1332          jsr       _Get8HexDigits
00000EEC  584F      1333          addq.w    #4,A7
00000EEE  2800      1334          move.l    D0,D4
                    1335   Load_SRecordFile_17:
                    1336   ; }
                    1337   ; RamPtr = (char*)(Address);                            // point to download area
00000EF0  2D44 FFFC 1338          move.l    D4,-4(A6)
                    1339   ; NumDataBytesToRead = ByteCount - AddressSize - 1;
00000EF4  202E FFF6 1340          move.l    -10(A6),D0
00000EF8  9085      1341          sub.l     D5,D0
00000EFA  5380      1342          subq.l    #1,D0
00000EFC  2D40 FFE2 1343          move.l    D0,-30(A6)
                    1344   ; for (i = 0; i < NumDataBytesToRead; i++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F00  4282      1345          clr.l     D2
                    1346   Load_SRecordFile_18:
00000F02  B4AE FFE2 1347          cmp.l     -30(A6),D2
00000F06  6C1E      1348          bge.s     Load_SRecordFile_20
                    1349   ; DataByte = Get2HexDigits(&CheckSum);
00000F08  2F0A      1350          move.l    A2,-(A7)
00000F0A  4E93      1351          jsr       (A3)
00000F0C  584F      1352          addq.w    #4,A7
00000F0E  2D40 FFDE 1353          move.l    D0,-34(A6)
                    1354   ; *RamPtr++ = DataByte;                      // store downloaded byte in Ram at specified address
00000F12  202E FFDE 1355          move.l    -34(A6),D0
00000F16  206E FFFC 1356          move.l    -4(A6),A0
00000F1A  52AE FFFC 1357          addq.l    #1,-4(A6)
00000F1E  1080      1358          move.b    D0,(A0)
                    1359   ; ByteTotal++;
00000F20  524D      1360          addq.w    #1,A5
00000F22  5282      1361          addq.l    #1,D2
00000F24  60DC      1362          bra       Load_SRecordFile_18
                    1363   Load_SRecordFile_20:
                    1364   ; }
                    1365   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1366   ; ReadCheckSum = Get2HexDigits(0);
00000F26  42A7      1367          clr.l     -(A7)
00000F28  4E93      1368          jsr       (A3)
00000F2A  584F      1369          addq.w    #4,A7
00000F2C  1D40 FFFB 1370          move.b    D0,-5(A6)
                    1371   ; if ((~CheckSum & 0Xff) != (ReadCheckSum & 0Xff)) {
00000F30  1012      1372          move.b    (A2),D0
00000F32  4600      1373          not.b     D0
00000F34  4880      1374          ext.w     D0
00000F36  C07C 00FF 1375          and.w     #255,D0
00000F3A  122E FFFB 1376          move.b    -5(A6),D1
00000F3E  4881      1377          ext.w     D1
00000F40  C27C 00FF 1378          and.w     #255,D1
00000F44  B041      1379          cmp.w     D1,D0
00000F46  6708      1380          beq.s     Load_SRecordFile_21
                    1381   ; LoadFailed = 1;
00000F48  7E01      1382          moveq     #1,D7
                    1383   ; FailedAddress = Address;
00000F4A  2D44 FFE6 1384          move.l    D4,-26(A6)
                    1385   ; break;
00000F4E  602C      1386          bra.s     Load_SRecordFile_3
                    1387   Load_SRecordFile_21:
                    1388   ; }
                    1389   ; SRecordCount++;
00000F50  52AE FFEE 1390          addq.l    #1,-18(A6)
                    1391   ; // display feedback on progress
                    1392   ; if (SRecordCount % 25 == 0)
00000F54  2F2E FFEE 1393          move.l    -18(A6),-(A7)
00000F58  4878 0019 1394          pea       25
00000F5C  4EB9 0000 1395          jsr       LDIV
00000F60  31DE      
00000F62  202F 0004 1396          move.l    4(A7),D0
00000F66  504F      1397          addq.w    #8,A7
00000F68  4A80      1398          tst.l     D0
00000F6A  660C      1399          bne.s     Load_SRecordFile_23
                    1400   ; putchar('.');
00000F6C  4878 002E 1401          pea       46
00000F70  4EB9 0000 1402          jsr       _putch
00000F74  32AA      
00000F76  584F      1403          addq.w    #4,A7
                    1404   Load_SRecordFile_23:
00000F78  6000 FEF0 1405          bra       Load_SRecordFile_1
                    1406   Load_SRecordFile_3:
                    1407   ; }
                    1408   ; if (LoadFailed == 1) {
00000F7C  0C87 0000 1409          cmp.l     #1,D7
00000F80  0001      
00000F82  6610      1410          bne.s     Load_SRecordFile_25
                    1411   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress);
00000F84  2F2E FFE6 1412          move.l    -26(A6),-(A7)
00000F88  4879 0000 1413          pea       @m68kde~1_15.L
00000F8C  3E28      
00000F8E  4E94      1414          jsr       (A4)
00000F90  504F      1415          addq.w    #8,A7
00000F92  600C      1416          bra.s     Load_SRecordFile_26
                    1417   Load_SRecordFile_25:
                    1418   ; }
                    1419   ; else
                    1420   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal);
00000F94  2F0D      1421          move.l    A5,-(A7)
00000F96  4879 0000 1422          pea       @m68kde~1_16.L
00000F9A  3E4E      
00000F9C  4E94      1423          jsr       (A4)
00000F9E  504F      1424          addq.w    #8,A7
                    1425   Load_SRecordFile_26:
                    1426   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1427   ; for (i = 0; i < 400000; i++)
00000FA0  4282      1428          clr.l     D2
                    1429   Load_SRecordFile_27:
00000FA2  0C82 0006 1430          cmp.l     #400000,D2
00000FA6  1A80      
00000FA8  6C04      1431          bge.s     Load_SRecordFile_29
00000FAA  5282      1432          addq.l    #1,D2
00000FAC  60F4      1433          bra       Load_SRecordFile_27
                    1434   Load_SRecordFile_29:
                    1435   ; ;
                    1436   ; FlushKeyboard();
00000FAE  4EB8 0BA6 1437          jsr       _FlushKeyboard
                    1438   ; Echo = 1;
00000FB2  23FC 0000 1439          move.l    #1,_Echo.L
00000FB6  0001 0803 
00000FBA  00E0      
                    1440   Load_SRecordFile_8:
00000FBC  4CDF 3CFC 1441          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FC0  4E5E      1442          unlk      A6
00000FC2  4E75      1443          rts
                    1444   ; }
                    1445   ; void MemoryChange(void)
                    1446   ; {
                    1447   _MemoryChange:
00000FC4  48E7 3820 1448          movem.l   D2/D3/D4/A2,-(A7)
00000FC8  45F9 0000 1449          lea       _printf.L,A2
00000FCC  33B8      
                    1450   ; unsigned char* RamPtr, c; // pointer to memory
                    1451   ; int Data;
                    1452   ; printf("\r\nExamine and Change Memory");
00000FCE  4879 0000 1453          pea       @m68kde~1_17.L
00000FD2  3E70      
00000FD4  4E92      1454          jsr       (A2)
00000FD6  584F      1455          addq.w    #4,A7
                    1456   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change");
00000FD8  4879 0000 1457          pea       @m68kde~1_18.L
00000FDC  3E8C      
00000FDE  4E92      1458          jsr       (A2)
00000FE0  584F      1459          addq.w    #4,A7
                    1460   ; printf("\r\nEnter Address: ");
00000FE2  4879 0000 1461          pea       @m68kde~1_19.L
00000FE6  3ED2      
00000FE8  4E92      1462          jsr       (A2)
00000FEA  584F      1463          addq.w    #4,A7
                    1464   ; RamPtr = Get8HexDigits(0);
00000FEC  42A7      1465          clr.l     -(A7)
00000FEE  4EB8 0CA4 1466          jsr       _Get8HexDigits
00000FF2  584F      1467          addq.w    #4,A7
00000FF4  2600      1468          move.l    D0,D3
                    1469   ; while (1) {
                    1470   MemoryChange_1:
                    1471   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr);
00000FF6  2043      1472          move.l    D3,A0
00000FF8  1210      1473          move.b    (A0),D1
00000FFA  C2BC 0000 1474          and.l     #255,D1
00000FFE  00FF      
00001000  2F01      1475          move.l    D1,-(A7)
00001002  2F03      1476          move.l    D3,-(A7)
00001004  4879 0000 1477          pea       @m68kde~1_20.L
00001008  3EE4      
0000100A  4E92      1478          jsr       (A2)
0000100C  DEFC 000C 1479          add.w     #12,A7
                    1480   ; c = tolower(_getch());
00001010  2F00      1481          move.l    D0,-(A7)
00001012  4EB8 0B68 1482          jsr       __getch
00001016  2200      1483          move.l    D0,D1
00001018  201F      1484          move.l    (A7)+,D0
0000101A  2F01      1485          move.l    D1,-(A7)
0000101C  4EB9 0000 1486          jsr       _tolower
00001020  3316      
00001022  584F      1487          addq.w    #4,A7
00001024  1400      1488          move.b    D0,D2
                    1489   ; if (c == (char)(0x1b))
00001026  0C02 001B 1490          cmp.b     #27,D2
0000102A  6604      1491          bne.s     MemoryChange_4
                    1492   ; return;                                // abort on escape
0000102C  6000 0090 1493          bra       MemoryChange_6
                    1494   MemoryChange_4:
                    1495   ; else if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001030  0C02 0030 1496          cmp.b     #48,D2
00001034  6506      1497          blo.s     MemoryChange_10
00001036  0C02 0039 1498          cmp.b     #57,D2
0000103A  6310      1499          bls.s     MemoryChange_9
                    1500   MemoryChange_10:
0000103C  0C02 0061 1501          cmp.b     #97,D2
00001040  6500 006E 1502          blo       MemoryChange_7
00001044  0C02 0066 1503          cmp.b     #102,D2
00001048  6200 0066 1504          bhi       MemoryChange_7
                    1505   MemoryChange_9:
                    1506   ; Data = (xtod(c) << 4) | (xtod(_getch()));
0000104C  C4BC 0000 1507          and.l     #255,D2
00001050  00FF      
00001052  2F02      1508          move.l    D2,-(A7)
00001054  4EB8 0BD2 1509          jsr       _xtod
00001058  584F      1510          addq.w    #4,A7
0000105A  C0BC 0000 1511          and.l     #255,D0
0000105E  00FF      
00001060  E980      1512          asl.l     #4,D0
00001062  2F00      1513          move.l    D0,-(A7)
00001064  2F01      1514          move.l    D1,-(A7)
00001066  4EB8 0B68 1515          jsr       __getch
0000106A  221F      1516          move.l    (A7)+,D1
0000106C  2F00      1517          move.l    D0,-(A7)
0000106E  4EB8 0BD2 1518          jsr       _xtod
00001072  584F      1519          addq.w    #4,A7
00001074  2200      1520          move.l    D0,D1
00001076  201F      1521          move.l    (A7)+,D0
00001078  C2BC 0000 1522          and.l     #255,D1
0000107C  00FF      
0000107E  8081      1523          or.l      D1,D0
00001080  2800      1524          move.l    D0,D4
                    1525   ; *RamPtr = (char)(Data);
00001082  2043      1526          move.l    D3,A0
00001084  1084      1527          move.b    D4,(A0)
                    1528   ; if (*RamPtr != Data) {
00001086  2043      1529          move.l    D3,A0
00001088  1010      1530          move.b    (A0),D0
0000108A  C0BC 0000 1531          and.l     #255,D0
0000108E  00FF      
00001090  B084      1532          cmp.l     D4,D0
00001092  671A      1533          beq.s     MemoryChange_11
                    1534   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr);
00001094  2043      1535          move.l    D3,A0
00001096  1210      1536          move.b    (A0),D1
00001098  C2BC 0000 1537          and.l     #255,D1
0000109C  00FF      
0000109E  2F01      1538          move.l    D1,-(A7)
000010A0  2F04      1539          move.l    D4,-(A7)
000010A2  4879 0000 1540          pea       @m68kde~1_21.L
000010A6  3EF6      
000010A8  4E92      1541          jsr       (A2)
000010AA  DEFC 000C 1542          add.w     #12,A7
                    1543   MemoryChange_11:
000010AE  6008      1544          bra.s     MemoryChange_13
                    1545   MemoryChange_7:
                    1546   ; }
                    1547   ; }
                    1548   ; else if (c == (char)('-'))
000010B0  0C02 002D 1549          cmp.b     #45,D2
000010B4  6602      1550          bne.s     MemoryChange_13
                    1551   ; RamPtr -= 2; ;
000010B6  5583      1552          subq.l    #2,D3
                    1553   MemoryChange_13:
                    1554   ; RamPtr++;
000010B8  5283      1555          addq.l    #1,D3
000010BA  6000 FF3A 1556          bra       MemoryChange_1
                    1557   MemoryChange_6:
000010BE  4CDF 041C 1558          movem.l   (A7)+,D2/D3/D4/A2
000010C2  4E75      1559          rts
                    1560   ; }
                    1561   ; }
                    1562   ; /******************************************************************************************
                    1563   ; ** The following code is for the SPI controller
                    1564   ; *******************************************************************************************/
                    1565   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1566   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1567   ; int TestForSPITransmitDataComplete(void) {
                    1568   _TestForSPITransmitDataComplete:
000010C4  4E56 FFFC 1569          link      A6,#-4
                    1570   ; // Link for checking if the MSB - http://codepad.org/se6HiIGO
                    1571   ; //printf("\r\nTesting for transmit data...");
                    1572   ; //printf("\r\nThe SPI status register is %x", SPI_Status);
                    1573   ; int val;
                    1574   ; val = !!((SPI_Status) & 0x80);
000010C8  1039 0040 1575          move.b    4227106,D0
000010CC  8022      
000010CE  C07C 00FF 1576          and.w     #255,D0
000010D2  C07C 0080 1577          and.w     #128,D0
000010D6  6704      1578          beq.s     TestForSPITransmitDataComplete_1
000010D8  7001      1579          moveq     #1,D0
000010DA  6002      1580          bra.s     TestForSPITransmitDataComplete_2
                    1581   TestForSPITransmitDataComplete_1:
000010DC  4280      1582          clr.l     D0
                    1583   TestForSPITransmitDataComplete_2:
000010DE  2D40 FFFC 1584          move.l    D0,-4(A6)
                    1585   ; return val;
000010E2  202E FFFC 1586          move.l    -4(A6),D0
000010E6  4E5E      1587          unlk      A6
000010E8  4E75      1588          rts
                    1589   ; }
                    1590   ; /************************************************************************************
                    1591   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1592   ; ************************************************************************************/
                    1593   ; void SPI_Init(void)
                    1594   ; {
                    1595   _SPI_Init:
                    1596   ; //TODO
                    1597   ; //
                    1598   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1599   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1600   ; //
                    1601   ; // Here are some settings we want to create
                    1602   ; //
                    1603   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1604   ; // Interrupts disabled - 7th bit is a zero
                    1605   ; // Core enabled - 6th bit is a one
                    1606   ; // Reserved - 5th bit (zero)
                    1607   ; // Master Mode - 4th bit is a one
                    1608   ; // Clock Polarity - 3rd bit is a zero
                    1609   ; // Phase of Clock - 2nd bit is a zero
                    1610   ; // Speed rate - 1st to 0th bit is a 11
                    1611   ; // Binary value is 01010011
                    1612   ; SPI_Control = 0x53;
000010EA  13FC 0053 1613          move.b    #83,4227104
000010EE  0040 8020 
                    1614   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1615   ; // Interrupt Count - 7th and 6th bit 00
                    1616   ; // Reserved - 5th - 2nd bit (zero)
                    1617   ; // Extended SPI clock rate select  - 1st and 0th bit is 00
                    1618   ; // Binary value is 00000000
                    1619   ; SPI_Ext = 0x00;
000010F2  4239 0040 1620          clr.b     4227110
000010F6  8026      
                    1621   ; // No reason why we need to enable this in the init
                    1622   ; //  SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1623   ; //Enable_SPI_CS();
                    1624   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1625   ; // Serial Peripheral Interupt Flag - 7th bit is 1 (To clear interrupt write the status register with SPIF bit set to 1)
                    1626   ; // Write collision - 6th bit is set to 1 (To clear the write collision flag write the status register with the WCOL bit set to 1)
                    1627   ; // Reserved - 5th to the 4th bit is zet to 0
                    1628   ; // Write FIFO Full - 0
                    1629   ; // Write FIFO Empty - 1
                    1630   ; // Read FIFO Full - 0
                    1631   ; // Read FIFO Empty - 1
                    1632   ; // Binary is 00000101
                    1633   ; SPI_Status = 0x05;
000010F8  13FC 0005 1634          move.b    #5,4227106
000010FC  0040 8022 
00001100  4E75      1635          rts
                    1636   ; }
                    1637   ; /************************************************************************************
                    1638   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1639   ; ************************************************************************************/
                    1640   ; void WaitForSPITransmitComplete(void)
                    1641   ; {
                    1642   _WaitForSPITransmitComplete:
                    1643   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1644   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1645   ; // just in case they were set
                    1646   ; // This to to check the SPI_Status's MSB to is set to 1
                    1647   ; // 1. We want to stay in a loop while the SPI_STatus MSB isn't 1
                    1648   ; // 2. We have to clear the SPIF flag of the SPI_Status
                    1649   ; //printf("\r\nWaiting for SPI contoller to transmit a byte ...");
                    1650   ; while (!TestForSPITransmitDataComplete()) // Check to see if the SPIF is a 1
                    1651   WaitForSPITransmitComplete_1:
00001102  4EB8 10C4 1652          jsr       _TestForSPITransmitDataComplete
00001106  4A80      1653          tst.l     D0
00001108  6602      1654          bne.s     WaitForSPITransmitComplete_3
                    1655   ; {
                    1656   ; ;
0000110A  60F6      1657          bra       WaitForSPITransmitComplete_1
                    1658   WaitForSPITransmitComplete_3:
                    1659   ; }
                    1660   ; // Moved the reseting of the SPIF flag to WriteSPIChar
                    1661   ; SPI_Status = SPI_Status | 0xC0; // Clear the SPIF flag
0000110C  1039 0040 1662          move.b    4227106,D0
00001110  8022      
00001112  C07C 00FF 1663          and.w     #255,D0
00001116  807C 00C0 1664          or.w      #192,D0
0000111A  13C0 0040 1665          move.b    D0,4227106
0000111E  8022      
                    1666   ; //printf("\r\nThe Reseted SPI status register is %x", SPI_Status);
                    1667   ; return;
00001120  4E75      1668          rts
                    1669   ; }
                    1670   ; /************************************************************************************
                    1671   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1672   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1673   ; ************************************************************************************/
                    1674   ; int WriteSPIChar(int c)
                    1675   ; {
                    1676   _WriteSPIChar:
00001122  4E56 FFFC 1677          link      A6,#-4
                    1678   ; int result;
                    1679   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1680   ; // wait for completion of transmission
                    1681   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1682   ; // by reading fom the SPI controller Data Register.
                    1683   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1684   ; //
                    1685   ; // modify '0' below to return back read byte from data register
                    1686   ; //
                    1687   ; // How this is going to work
                    1688   ; // 1. We are going to send whatever c is into the SPI_Data (command/address/data)
                    1689   ; // 2. We have to check that it has transfered
                    1690   ; // 3. Return the result back to clear the read FIFO by assigning it
                    1691   ; SPI_Data = c;
00001126  202E 0008 1692          move.l    8(A6),D0
0000112A  13C0 0040 1693          move.b    D0,4227108
0000112E  8024      
                    1694   ; WaitForSPITransmitComplete();
00001130  4EB8 1102 1695          jsr       _WaitForSPITransmitComplete
                    1696   ; result = SPI_Data;
00001134  1039 0040 1697          move.b    4227108,D0
00001138  8024      
0000113A  C0BC 0000 1698          and.l     #255,D0
0000113E  00FF      
00001140  2D40 FFFC 1699          move.l    D0,-4(A6)
                    1700   ; return result;
00001144  202E FFFC 1701          move.l    -4(A6),D0
00001148  4E5E      1702          unlk      A6
0000114A  4E75      1703          rts
                    1704   ; }
                    1705   ; /************************************************************************************
                    1706   ; ** Poll the completion of command
                    1707   ; ************************************************************************************/
                    1708   ; void PollForCompletionOfCommand() {
                    1709   _PollForCompletionOfCommand:
0000114C  4E56 FFFC 1710          link      A6,#-4
                    1711   ; int statusRegister;
                    1712   ; // This is the poll for the completion of commands
                    1713   ; // since we can't send commands while the next one isn't done
                    1714   ; // 1. Enable CS
                    1715   ; // 2. Send a read status register command
                    1716   ; // 3. send dummy data
                    1717   ; // 4. read the data of the status register
                    1718   ; // 5. Stop when the MSB is a 1
                    1719   ; //printf("\r\nPolling for completion of command ...");
                    1720   ; Enable_SPI_CS();
00001150  13FC 00FE 1721          move.b    #254,4227112
00001154  0040 8028 
                    1722   ; WriteSPIChar(Read_Status_Register_Command);
00001158  2F39 0000 1723          move.l    _Read_Status_Register_Command.L,-(A7)
0000115C  5150      
0000115E  4EB8 1122 1724          jsr       _WriteSPIChar
00001162  584F      1725          addq.w    #4,A7
                    1726   ; do {
                    1727   PollForCompletionOfCommand_1:
                    1728   ; statusRegister = WriteSPIChar(Dummy_Data_Byte);
00001164  2F39 0000 1729          move.l    _Dummy_Data_Byte.L,-(A7)
00001168  5160      
0000116A  4EB8 1122 1730          jsr       _WriteSPIChar
0000116E  584F      1731          addq.w    #4,A7
00001170  2D40 FFFC 1732          move.l    D0,-4(A6)
00001174  202E FFFC 1733          move.l    -4(A6),D0
00001178  C0BC 0000 1734          and.l     #1,D0
0000117C  0001      
0000117E  66E4      1735          bne       PollForCompletionOfCommand_1
                    1736   ; //printf("\r\nThe status register is %x", statusRegister);
                    1737   ; } while (!!((statusRegister) & 0x01));
                    1738   ; Disable_SPI_CS();
00001180  13FC 00FF 1739          move.b    #255,4227112
00001184  0040 8028 
                    1740   ; return;
00001188  4E5E      1741          unlk      A6
0000118A  4E75      1742          rts
                    1743   ; }
                    1744   ; /************************************************************************************
                    1745   ; ** Enable write so we can write commands to the SPI Controller
                    1746   ; ************************************************************************************/
                    1747   ; void enableWrite()
                    1748   ; {
                    1749   _enableWrite:
                    1750   ; Enable_SPI_CS();
0000118C  13FC 00FE 1751          move.b    #254,4227112
00001190  0040 8028 
                    1752   ; WriteSPIChar(Write_Enable_Command);
00001194  2F39 0000 1753          move.l    _Write_Enable_Command.L,-(A7)
00001198  5144      
0000119A  4EB8 1122 1754          jsr       _WriteSPIChar
0000119E  584F      1755          addq.w    #4,A7
                    1756   ; Disable_SPI_CS();
000011A0  13FC 00FF 1757          move.b    #255,4227112
000011A4  0040 8028 
000011A8  4E75      1758          rts
                    1759   ; }
                    1760   ; /************************************************************************************
                    1761   ; ** Erase the Chip as we need to clear memeory locations before we write into it
                    1762   ; ************************************************************************************/
                    1763   ; void eraseTheChip()
                    1764   ; {
                    1765   _eraseTheChip:
                    1766   ; Enable_SPI_CS();
000011AA  13FC 00FE 1767          move.b    #254,4227112
000011AE  0040 8028 
                    1768   ; WriteSPIChar(Erase_Chip_Command);
000011B2  2F39 0000 1769          move.l    _Erase_Chip_Command.L,-(A7)
000011B6  514C      
000011B8  4EB8 1122 1770          jsr       _WriteSPIChar
000011BC  584F      1771          addq.w    #4,A7
                    1772   ; Disable_SPI_CS();
000011BE  13FC 00FF 1773          move.b    #255,4227112
000011C2  0040 8028 
000011C6  4E75      1774          rts
                    1775   ; }
                    1776   ; unsigned char* Write_SPI(unsigned char* RAM_addr_ptr, unsigned char flash_addr_lower, unsigned char flash_addr_mid, unsigned char flash_addr_upper) {
                    1777   _Write_SPI:
000011C8  4E56 0000 1778          link      A6,#0
000011CC  48E7 3020 1779          movem.l   D2/D3/A2,-(A7)
000011D0  45F8 1122 1780          lea       _WriteSPIChar.L,A2
000011D4  262E 0008 1781          move.l    8(A6),D3
                    1782   ; int i = 0;
000011D8  4282      1783          clr.l     D2
                    1784   ; enableWrite();
000011DA  4EB8 118C 1785          jsr       _enableWrite
                    1786   ; PollForCompletionOfCommand();
000011DE  4EB8 114C 1787          jsr       _PollForCompletionOfCommand
                    1788   ; Enable_SPI_CS();
000011E2  13FC 00FE 1789          move.b    #254,4227112
000011E6  0040 8028 
                    1790   ; WriteSPIChar(Page_Program_Command);
000011EA  2F39 0000 1791          move.l    _Page_Program_Command.L,-(A7)
000011EE  5148      
000011F0  4E92      1792          jsr       (A2)
000011F2  584F      1793          addq.w    #4,A7
                    1794   ; WriteSPIChar(flash_addr_lower);
000011F4  122E 000F 1795          move.b    15(A6),D1
000011F8  C2BC 0000 1796          and.l     #255,D1
000011FC  00FF      
000011FE  2F01      1797          move.l    D1,-(A7)
00001200  4E92      1798          jsr       (A2)
00001202  584F      1799          addq.w    #4,A7
                    1800   ; WriteSPIChar(flash_addr_mid);
00001204  122E 0013 1801          move.b    19(A6),D1
00001208  C2BC 0000 1802          and.l     #255,D1
0000120C  00FF      
0000120E  2F01      1803          move.l    D1,-(A7)
00001210  4E92      1804          jsr       (A2)
00001212  584F      1805          addq.w    #4,A7
                    1806   ; WriteSPIChar(flash_addr_upper);
00001214  122E 0017 1807          move.b    23(A6),D1
00001218  C2BC 0000 1808          and.l     #255,D1
0000121C  00FF      
0000121E  2F01      1809          move.l    D1,-(A7)
00001220  4E92      1810          jsr       (A2)
00001222  584F      1811          addq.w    #4,A7
                    1812   ; //printf("\r\nValues written to data register:\n");
                    1813   ; for (i = 0; i < 256; i++) {
00001224  4282      1814          clr.l     D2
                    1815   Write_SPI_1:
00001226  0C82 0000 1816          cmp.l     #256,D2
0000122A  0100      
0000122C  6C16      1817          bge.s     Write_SPI_3
                    1818   ; WriteSPIChar(RAM_addr_ptr[0]);
0000122E  2043      1819          move.l    D3,A0
00001230  1210      1820          move.b    (A0),D1
00001232  C2BC 0000 1821          and.l     #255,D1
00001236  00FF      
00001238  2F01      1822          move.l    D1,-(A7)
0000123A  4E92      1823          jsr       (A2)
0000123C  584F      1824          addq.w    #4,A7
                    1825   ; //printf("%x, ", RAM_addr_ptr[0]);
                    1826   ; RAM_addr_ptr++;
0000123E  5283      1827          addq.l    #1,D3
00001240  5282      1828          addq.l    #1,D2
00001242  60E2      1829          bra       Write_SPI_1
                    1830   Write_SPI_3:
                    1831   ; }
                    1832   ; Disable_SPI_CS();
00001244  13FC 00FF 1833          move.b    #255,4227112
00001248  0040 8028 
                    1834   ; PollForCompletionOfCommand();
0000124C  4EB8 114C 1835          jsr       _PollForCompletionOfCommand
                    1836   ; return RAM_addr_ptr;
00001250  2003      1837          move.l    D3,D0
00001252  4CDF 040C 1838          movem.l   (A7)+,D2/D3/A2
00001256  4E5E      1839          unlk      A6
00001258  4E75      1840          rts
                    1841   ; }
                    1842   ; void Read_SPI(unsigned char flash_addr_lower, unsigned char flash_addr_mid, unsigned char flash_addr_upper) {
                    1843   _Read_SPI:
0000125A  4E56 FFFC 1844          link      A6,#-4
0000125E  48E7 2020 1845          movem.l   D2/A2,-(A7)
00001262  45F8 1122 1846          lea       _WriteSPIChar.L,A2
                    1847   ; int j, read;
                    1848   ; Enable_SPI_CS();
00001266  13FC 00FE 1849          move.b    #254,4227112
0000126A  0040 8028 
                    1850   ; WriteSPIChar(Read_Flash_Chip_Command);
0000126E  2F39 0000 1851          move.l    _Read_Flash_Chip_Command.L,-(A7)
00001272  5154      
00001274  4E92      1852          jsr       (A2)
00001276  584F      1853          addq.w    #4,A7
                    1854   ; WriteSPIChar(flash_addr_lower);
00001278  122E 000B 1855          move.b    11(A6),D1
0000127C  C2BC 0000 1856          and.l     #255,D1
00001280  00FF      
00001282  2F01      1857          move.l    D1,-(A7)
00001284  4E92      1858          jsr       (A2)
00001286  584F      1859          addq.w    #4,A7
                    1860   ; WriteSPIChar(flash_addr_mid);
00001288  122E 000F 1861          move.b    15(A6),D1
0000128C  C2BC 0000 1862          and.l     #255,D1
00001290  00FF      
00001292  2F01      1863          move.l    D1,-(A7)
00001294  4E92      1864          jsr       (A2)
00001296  584F      1865          addq.w    #4,A7
                    1866   ; WriteSPIChar(flash_addr_upper);
00001298  122E 0013 1867          move.b    19(A6),D1
0000129C  C2BC 0000 1868          and.l     #255,D1
000012A0  00FF      
000012A2  2F01      1869          move.l    D1,-(A7)
000012A4  4E92      1870          jsr       (A2)
000012A6  584F      1871          addq.w    #4,A7
                    1872   ; //printf("\r\nValues read from data register:\n");
                    1873   ; for (j = 0; j < 256; j++) {
000012A8  4282      1874          clr.l     D2
                    1875   Read_SPI_1:
000012AA  0C82 0000 1876          cmp.l     #256,D2
000012AE  0100      
000012B0  6C12      1877          bge.s     Read_SPI_3
                    1878   ; read = WriteSPIChar(Dummy_Data_Byte);
000012B2  2F39 0000 1879          move.l    _Dummy_Data_Byte.L,-(A7)
000012B6  5160      
000012B8  4E92      1880          jsr       (A2)
000012BA  584F      1881          addq.w    #4,A7
000012BC  2D40 FFFC 1882          move.l    D0,-4(A6)
000012C0  5282      1883          addq.l    #1,D2
000012C2  60E6      1884          bra       Read_SPI_1
                    1885   Read_SPI_3:
                    1886   ; //printf("%x, ", read);
                    1887   ; }
                    1888   ; Disable_SPI_CS();
000012C4  13FC 00FF 1889          move.b    #255,4227112
000012C8  0040 8028 
                    1890   ; PollForCompletionOfCommand();
000012CC  4EB8 114C 1891          jsr       _PollForCompletionOfCommand
000012D0  4CDF 0404 1892          movem.l   (A7)+,D2/A2
000012D4  4E5E      1893          unlk      A6
000012D6  4E75      1894          rts
                    1895   ; }
                    1896   ; unsigned char* Read_SPI_Write_DRAM(unsigned char* RAM_addr_ptr, unsigned char flash_addr_lower, unsigned char flash_addr_mid, unsigned char flash_addr_upper) {
                    1897   _Read_SPI_Write_DRAM:
000012D8  4E56 FFFC 1898          link      A6,#-4
000012DC  48E7 3020 1899          movem.l   D2/D3/A2,-(A7)
000012E0  45F8 1122 1900          lea       _WriteSPIChar.L,A2
000012E4  242E 0008 1901          move.l    8(A6),D2
                    1902   ; int j, read;
                    1903   ; Enable_SPI_CS();
000012E8  13FC 00FE 1904          move.b    #254,4227112
000012EC  0040 8028 
                    1905   ; WriteSPIChar(Read_Flash_Chip_Command);
000012F0  2F39 0000 1906          move.l    _Read_Flash_Chip_Command.L,-(A7)
000012F4  5154      
000012F6  4E92      1907          jsr       (A2)
000012F8  584F      1908          addq.w    #4,A7
                    1909   ; WriteSPIChar(flash_addr_lower);
000012FA  122E 000F 1910          move.b    15(A6),D1
000012FE  C2BC 0000 1911          and.l     #255,D1
00001302  00FF      
00001304  2F01      1912          move.l    D1,-(A7)
00001306  4E92      1913          jsr       (A2)
00001308  584F      1914          addq.w    #4,A7
                    1915   ; WriteSPIChar(flash_addr_mid);
0000130A  122E 0013 1916          move.b    19(A6),D1
0000130E  C2BC 0000 1917          and.l     #255,D1
00001312  00FF      
00001314  2F01      1918          move.l    D1,-(A7)
00001316  4E92      1919          jsr       (A2)
00001318  584F      1920          addq.w    #4,A7
                    1921   ; WriteSPIChar(flash_addr_upper);
0000131A  122E 0017 1922          move.b    23(A6),D1
0000131E  C2BC 0000 1923          and.l     #255,D1
00001322  00FF      
00001324  2F01      1924          move.l    D1,-(A7)
00001326  4E92      1925          jsr       (A2)
00001328  584F      1926          addq.w    #4,A7
                    1927   ; //printf("\r\nValues read from data register:\n");
                    1928   ; for (j = 0; j < 256; j++) {
0000132A  4283      1929          clr.l     D3
                    1930   Read_SPI_Write_DRAM_1:
0000132C  0C83 0000 1931          cmp.l     #256,D3
00001330  0100      
00001332  6C1C      1932          bge.s     Read_SPI_Write_DRAM_3
                    1933   ; //printf("[Read: ");
                    1934   ; read = WriteSPIChar(Dummy_Data_Byte);
00001334  2F39 0000 1935          move.l    _Dummy_Data_Byte.L,-(A7)
00001338  5160      
0000133A  4E92      1936          jsr       (A2)
0000133C  584F      1937          addq.w    #4,A7
0000133E  2D40 FFFC 1938          move.l    D0,-4(A6)
                    1939   ; //printf("%x, ", read);
                    1940   ; RAM_addr_ptr[0] = read;
00001342  202E FFFC 1941          move.l    -4(A6),D0
00001346  2042      1942          move.l    D2,A0
00001348  1080      1943          move.b    D0,(A0)
                    1944   ; //printf("Written: %x]", RAM_addr_ptr[0]);
                    1945   ; RAM_addr_ptr++;
0000134A  5282      1946          addq.l    #1,D2
0000134C  5283      1947          addq.l    #1,D3
0000134E  60DC      1948          bra       Read_SPI_Write_DRAM_1
                    1949   Read_SPI_Write_DRAM_3:
                    1950   ; }
                    1951   ; Disable_SPI_CS();
00001350  13FC 00FF 1952          move.b    #255,4227112
00001354  0040 8028 
                    1953   ; PollForCompletionOfCommand();
00001358  4EB8 114C 1954          jsr       _PollForCompletionOfCommand
                    1955   ; return RAM_addr_ptr;
0000135C  2002      1956          move.l    D2,D0
0000135E  4CDF 040C 1957          movem.l   (A7)+,D2/D3/A2
00001362  4E5E      1958          unlk      A6
00001364  4E75      1959          rts
                    1960   ; }
                    1961   ; /*******************************************************************
                    1962   ; ** SPI CODE FOR LAB 3 STARTS HERE: Write a program to SPI Flash Chip from memory and verify by reading back
                    1963   ; ********************************************************************/
                    1964   ; void ProgramFlashChip(void)
                    1965   ; {
                    1966   _ProgramFlashChip:
00001366  48E7 3E20 1967          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
0000136A  45F9 0000 1968          lea       _printf.L,A2
0000136E  33B8      
                    1969   ; //
                    1970   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1971   ; // TODO : then verify by reading it back and comparing to memory
                    1972   ; //
                    1973   ; int a;
                    1974   ; unsigned char* RAM_addr_ptr = 0x08000000;
00001370  2C3C 0800 1975          move.l    #134217728,D6
00001374  0000      
                    1976   ; unsigned char flash_addr_lower = 0x00;
00001376  4202      1977          clr.b     D2
                    1978   ; unsigned char flash_addr_mid = 0x00;
00001378  4204      1979          clr.b     D4
                    1980   ; unsigned char flash_addr_upper = 0x00;
0000137A  4205      1981          clr.b     D5
                    1982   ; printf("\r\nExecuting Program Function....");
0000137C  4879 0000 1983          pea       @m68kde~1_22.L
00001380  3F2A      
00001382  4E92      1984          jsr       (A2)
00001384  584F      1985          addq.w    #4,A7
                    1986   ; //Initialize
                    1987   ; SPI_Init();
00001386  4EB8 10EA 1988          jsr       _SPI_Init
                    1989   ; // Erasing the chip
                    1990   ; enableWrite();
0000138A  4EB8 118C 1991          jsr       _enableWrite
                    1992   ; PollForCompletionOfCommand();
0000138E  4EB8 114C 1993          jsr       _PollForCompletionOfCommand
                    1994   ; eraseTheChip();
00001392  4EB8 11AA 1995          jsr       _eraseTheChip
                    1996   ; PollForCompletionOfCommand();
00001396  4EB8 114C 1997          jsr       _PollForCompletionOfCommand
                    1998   ; //For loops for write
                    1999   ; for (a = 0; a < 1000; a++) {
0000139A  4283      2000          clr.l     D3
                    2001   ProgramFlashChip_1:
0000139C  0C83 0000 2002          cmp.l     #1000,D3
000013A0  03E8      
000013A2  6C00 003C 2003          bge       ProgramFlashChip_3
                    2004   ; RAM_addr_ptr = Write_SPI(RAM_addr_ptr, flash_addr_lower, flash_addr_mid, flash_addr_upper);
000013A6  CABC 0000 2005          and.l     #255,D5
000013AA  00FF      
000013AC  2F05      2006          move.l    D5,-(A7)
000013AE  C8BC 0000 2007          and.l     #255,D4
000013B2  00FF      
000013B4  2F04      2008          move.l    D4,-(A7)
000013B6  C4BC 0000 2009          and.l     #255,D2
000013BA  00FF      
000013BC  2F02      2010          move.l    D2,-(A7)
000013BE  2F06      2011          move.l    D6,-(A7)
000013C0  4EB8 11C8 2012          jsr       _Write_SPI
000013C4  DEFC 0010 2013          add.w     #16,A7
000013C8  2C00      2014          move.l    D0,D6
                    2015   ; if (flash_addr_lower == 255) {
000013CA  C47C 00FF 2016          and.w     #255,D2
000013CE  0C42 00FF 2017          cmp.w     #255,D2
000013D2  6606      2018          bne.s     ProgramFlashChip_4
                    2019   ; flash_addr_mid++;
000013D4  5204      2020          addq.b    #1,D4
                    2021   ; flash_addr_lower = 0x00;
000013D6  4202      2022          clr.b     D2
000013D8  6002      2023          bra.s     ProgramFlashChip_5
                    2024   ProgramFlashChip_4:
                    2025   ; }
                    2026   ; else {
                    2027   ; flash_addr_lower++;
000013DA  5202      2028          addq.b    #1,D2
                    2029   ProgramFlashChip_5:
000013DC  5283      2030          addq.l    #1,D3
000013DE  60BC      2031          bra       ProgramFlashChip_1
                    2032   ProgramFlashChip_3:
                    2033   ; }
                    2034   ; }
                    2035   ; printf("\n");
000013E0  4879 0000 2036          pea       @m68kde~1_23.L
000013E4  3F4C      
000013E6  4E92      2037          jsr       (A2)
000013E8  584F      2038          addq.w    #4,A7
                    2039   ; flash_addr_lower = 0x00;
000013EA  4202      2040          clr.b     D2
                    2041   ; flash_addr_mid = 0x00;
000013EC  4204      2042          clr.b     D4
                    2043   ; flash_addr_upper = 0x00;
000013EE  4205      2044          clr.b     D5
                    2045   ; // CODE BELOW IS FOR TESTING PURPOSES
                    2046   ; // Code below is to verify the data (through reading) we write to the flash drive
                    2047   ; for (a = 0; a < 1000; a++) {
000013F0  4283      2048          clr.l     D3
                    2049   ProgramFlashChip_6:
000013F2  0C83 0000 2050          cmp.l     #1000,D3
000013F6  03E8      
000013F8  6C00 0036 2051          bge       ProgramFlashChip_8
                    2052   ; Read_SPI(flash_addr_lower, flash_addr_mid, flash_addr_upper);
000013FC  CABC 0000 2053          and.l     #255,D5
00001400  00FF      
00001402  2F05      2054          move.l    D5,-(A7)
00001404  C8BC 0000 2055          and.l     #255,D4
00001408  00FF      
0000140A  2F04      2056          move.l    D4,-(A7)
0000140C  C4BC 0000 2057          and.l     #255,D2
00001410  00FF      
00001412  2F02      2058          move.l    D2,-(A7)
00001414  4EB8 125A 2059          jsr       _Read_SPI
00001418  DEFC 000C 2060          add.w     #12,A7
                    2061   ; if (flash_addr_lower == 255) {
0000141C  C47C 00FF 2062          and.w     #255,D2
00001420  0C42 00FF 2063          cmp.w     #255,D2
00001424  6604      2064          bne.s     ProgramFlashChip_9
                    2065   ; flash_addr_mid++;
00001426  5204      2066          addq.b    #1,D4
                    2067   ; flash_addr_lower = 0x00;
00001428  4202      2068          clr.b     D2
                    2069   ProgramFlashChip_9:
                    2070   ; } {
                    2071   ; flash_addr_lower++;
0000142A  5202      2072          addq.b    #1,D2
0000142C  5283      2073          addq.l    #1,D3
0000142E  60C2      2074          bra       ProgramFlashChip_6
                    2075   ProgramFlashChip_8:
                    2076   ; }
                    2077   ; }
                    2078   ; // END OF TESTING PURPOSE CODE
                    2079   ; printf("\r\nP Command Completed.");
00001430  4879 0000 2080          pea       @m68kde~1_24.L
00001434  3F4E      
00001436  4E92      2081          jsr       (A2)
00001438  584F      2082          addq.w    #4,A7
0000143A  4CDF 047C 2083          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
0000143E  4E75      2084          rts
                    2085   ; }
                    2086   ; /*************************************************************************
                    2087   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2088   ; **************************************************************************/
                    2089   ; void LoadFromFlashChip(void)
                    2090   ; {
                    2091   _LoadFromFlashChip:
00001440  4E56 FFFC 2092          link      A6,#-4
00001444  48E7 3C00 2093          movem.l   D2/D3/D4/D5,-(A7)
                    2094   ; int b;
                    2095   ; unsigned char* RAM_addr_ptr = 0x08000000;
00001448  2A3C 0800 2096          move.l    #134217728,D5
0000144C  0000      
                    2097   ; unsigned char flash_addr_lower = 0x00;
0000144E  4202      2098          clr.b     D2
                    2099   ; unsigned char flash_addr_mid = 0x00;
00001450  4204      2100          clr.b     D4
                    2101   ; unsigned char flash_addr_upper = 0x00;
00001452  422E FFFF 2102          clr.b     -1(A6)
                    2103   ; printf("\r\nLoading Program From SPI Flash....");
00001456  4879 0000 2104          pea       @m68kde~1_25.L
0000145A  3F66      
0000145C  4EB9 0000 2105          jsr       _printf
00001460  33B8      
00001462  584F      2106          addq.w    #4,A7
                    2107   ; //Initialize for C command
                    2108   ; SPI_Init();
00001464  4EB8 10EA 2109          jsr       _SPI_Init
                    2110   ; //Read to DRAM
                    2111   ; for (b = 0; b < 1000; b++) {
00001468  4283      2112          clr.l     D3
                    2113   LoadFromFlashChip_1:
0000146A  0C83 0000 2114          cmp.l     #1000,D3
0000146E  03E8      
00001470  6C00 0040 2115          bge       LoadFromFlashChip_3
                    2116   ; RAM_addr_ptr = Read_SPI_Write_DRAM(RAM_addr_ptr, flash_addr_lower, flash_addr_mid, flash_addr_upper);
00001474  122E FFFF 2117          move.b    -1(A6),D1
00001478  C2BC 0000 2118          and.l     #255,D1
0000147C  00FF      
0000147E  2F01      2119          move.l    D1,-(A7)
00001480  C8BC 0000 2120          and.l     #255,D4
00001484  00FF      
00001486  2F04      2121          move.l    D4,-(A7)
00001488  C4BC 0000 2122          and.l     #255,D2
0000148C  00FF      
0000148E  2F02      2123          move.l    D2,-(A7)
00001490  2F05      2124          move.l    D5,-(A7)
00001492  4EB8 12D8 2125          jsr       _Read_SPI_Write_DRAM
00001496  DEFC 0010 2126          add.w     #16,A7
0000149A  2A00      2127          move.l    D0,D5
                    2128   ; if (flash_addr_lower == 255) {
0000149C  C47C 00FF 2129          and.w     #255,D2
000014A0  0C42 00FF 2130          cmp.w     #255,D2
000014A4  6606      2131          bne.s     LoadFromFlashChip_4
                    2132   ; flash_addr_mid++;
000014A6  5204      2133          addq.b    #1,D4
                    2134   ; flash_addr_lower = 0x00;
000014A8  4202      2135          clr.b     D2
000014AA  6002      2136          bra.s     LoadFromFlashChip_5
                    2137   LoadFromFlashChip_4:
                    2138   ; }
                    2139   ; else {
                    2140   ; flash_addr_lower++;
000014AC  5202      2141          addq.b    #1,D2
                    2142   LoadFromFlashChip_5:
000014AE  5283      2143          addq.l    #1,D3
000014B0  60B8      2144          bra       LoadFromFlashChip_1
                    2145   LoadFromFlashChip_3:
                    2146   ; }
                    2147   ; }
                    2148   ; printf("\r\nC Command Completed.");
000014B2  4879 0000 2149          pea       @m68kde~1_26.L
000014B6  3F8C      
000014B8  4EB9 0000 2150          jsr       _printf
000014BC  33B8      
000014BE  584F      2151          addq.w    #4,A7
000014C0  4CDF 003C 2152          movem.l   (A7)+,D2/D3/D4/D5
000014C4  4E5E      2153          unlk      A6
000014C6  4E75      2154          rts
                    2155   ; }
                    2156   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2157   ; // IMPORTANT
                    2158   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2159   ; // has to be done with an interrupt (IRQ Level 6)
                    2160   ; //
                    2161   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2162   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2163   ; //
                    2164   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2165   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2166   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2167   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2168   ; // program area
                    2169   ; //
                    2170   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2171   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2172   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2173   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2174   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2175   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2176   ; void DumpRegisters()
                    2177   ; {
                    2178   _DumpRegisters:
000014C8  48E7 3F3C 2179          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000014CC  45F9 0000 2180          lea       _putch.L,A2
000014D0  32AA      
000014D2  47F9 0000 2181          lea       _printf.L,A3
000014D6  33B8      
000014D8  49F9 0803 2182          lea       _SR.L,A4
000014DC  012C      
000014DE  4BF9 0803 2183          lea       _WatchPointString.L,A5
000014E2  01C2      
                    2184   ; short i, x, j, k;
                    2185   ; unsigned char c, * BytePointer;
                    2186   ; // buld up strings for displaying watchpoints
                    2187   ; for (x = 0; x < (short)(8); x++)
000014E4  4242      2188          clr.w     D2
                    2189   DumpRegisters_1:
000014E6  0C42 0008 2190          cmp.w     #8,D2
000014EA  6C00 01C6 2191          bge       DumpRegisters_3
                    2192   ; {
                    2193   ; if (WatchPointSetOrCleared[x] == 1)
000014EE  48C2      2194          ext.l     D2
000014F0  2002      2195          move.l    D2,D0
000014F2  E588      2196          lsl.l     #2,D0
000014F4  41F9 0803 2197          lea       _WatchPointSetOrCleared.L,A0
000014F8  01A2      
000014FA  2030 0800 2198          move.l    0(A0,D0.L),D0
000014FE  0C80 0000 2199          cmp.l     #1,D0
00001502  0001      
00001504  6600 0186 2200          bne       DumpRegisters_4
                    2201   ; {
                    2202   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]);
00001508  48C2      2203          ext.l     D2
0000150A  2202      2204          move.l    D2,D1
0000150C  E589      2205          lsl.l     #2,D1
0000150E  41F9 0803 2206          lea       _WatchPointAddress.L,A0
00001512  0182      
00001514  2F30 1800 2207          move.l    0(A0,D1.L),-(A7)
00001518  4879 0000 2208          pea       @m68kde~1_27.L
0000151C  3FA4      
0000151E  220D      2209          move.l    A5,D1
00001520  48C2      2210          ext.l     D2
00001522  2F00      2211          move.l    D0,-(A7)
00001524  2002      2212          move.l    D2,D0
00001526  C1FC 0064 2213          muls      #100,D0
0000152A  D280      2214          add.l     D0,D1
0000152C  201F      2215          move.l    (A7)+,D0
0000152E  2F01      2216          move.l    D1,-(A7)
00001530  4EB9 0000 2217          jsr       _sprintf
00001534  3342      
00001536  DEFC 000C 2218          add.w     #12,A7
                    2219   ; BytePointer = (char*)(WatchPointAddress[x]);
0000153A  48C2      2220          ext.l     D2
0000153C  2002      2221          move.l    D2,D0
0000153E  E588      2222          lsl.l     #2,D0
00001540  41F9 0803 2223          lea       _WatchPointAddress.L,A0
00001544  0182      
00001546  2A30 0800 2224          move.l    0(A0,D0.L),D5
                    2225   ; for (j = 0; j < (short)(16); j += 2)
0000154A  4243      2226          clr.w     D3
                    2227   DumpRegisters_6:
0000154C  0C43 0010 2228          cmp.w     #16,D3
00001550  6C00 0082 2229          bge       DumpRegisters_8
                    2230   ; {
                    2231   ; for (k = 0; k < (short)(2); k++)
00001554  4246      2232          clr.w     D6
                    2233   DumpRegisters_9:
00001556  0C46 0002 2234          cmp.w     #2,D6
0000155A  6C00 0052 2235          bge       DumpRegisters_11
                    2236   ; {
                    2237   ; sprintf(TempString, "%02X", BytePointer[j + k]);
0000155E  2045      2238          move.l    D5,A0
00001560  48C3      2239          ext.l     D3
00001562  2203      2240          move.l    D3,D1
00001564  48C6      2241          ext.l     D6
00001566  D286      2242          add.l     D6,D1
00001568  1230 1800 2243          move.b    0(A0,D1.L),D1
0000156C  C2BC 0000 2244          and.l     #255,D1
00001570  00FF      
00001572  2F01      2245          move.l    D1,-(A7)
00001574  4879 0000 2246          pea       @m68kde~1_8.L
00001578  3D80      
0000157A  4879 0803 2247          pea       _TempString.L
0000157E  04E2      
00001580  4EB9 0000 2248          jsr       _sprintf
00001584  3342      
00001586  DEFC 000C 2249          add.w     #12,A7
                    2250   ; strcat(WatchPointString[x], TempString);
0000158A  4879 0803 2251          pea       _TempString.L
0000158E  04E2      
00001590  220D      2252          move.l    A5,D1
00001592  48C2      2253          ext.l     D2
00001594  2F00      2254          move.l    D0,-(A7)
00001596  2002      2255          move.l    D2,D0
00001598  C1FC 0064 2256          muls      #100,D0
0000159C  D280      2257          add.l     D0,D1
0000159E  201F      2258          move.l    (A7)+,D0
000015A0  2F01      2259          move.l    D1,-(A7)
000015A2  4EB9 0000 2260          jsr       _strcat
000015A6  3376      
000015A8  504F      2261          addq.w    #8,A7
000015AA  5246      2262          addq.w    #1,D6
000015AC  60A8      2263          bra       DumpRegisters_9
                    2264   DumpRegisters_11:
                    2265   ; }
                    2266   ; strcat(WatchPointString[x], " ");
000015AE  4879 0000 2267          pea       @m68kde~1_28.L
000015B2  3FAC      
000015B4  220D      2268          move.l    A5,D1
000015B6  48C2      2269          ext.l     D2
000015B8  2F00      2270          move.l    D0,-(A7)
000015BA  2002      2271          move.l    D2,D0
000015BC  C1FC 0064 2272          muls      #100,D0
000015C0  D280      2273          add.l     D0,D1
000015C2  201F      2274          move.l    (A7)+,D0
000015C4  2F01      2275          move.l    D1,-(A7)
000015C6  4EB9 0000 2276          jsr       _strcat
000015CA  3376      
000015CC  504F      2277          addq.w    #8,A7
000015CE  5443      2278          addq.w    #2,D3
000015D0  6000 FF7A 2279          bra       DumpRegisters_6
                    2280   DumpRegisters_8:
                    2281   ; }
                    2282   ; strcat(WatchPointString[x], "  ");
000015D4  4879 0000 2283          pea       @m68kde~1_9.L
000015D8  3D86      
000015DA  220D      2284          move.l    A5,D1
000015DC  48C2      2285          ext.l     D2
000015DE  2F00      2286          move.l    D0,-(A7)
000015E0  2002      2287          move.l    D2,D0
000015E2  C1FC 0064 2288          muls      #100,D0
000015E6  D280      2289          add.l     D0,D1
000015E8  201F      2290          move.l    (A7)+,D0
000015EA  2F01      2291          move.l    D1,-(A7)
000015EC  4EB9 0000 2292          jsr       _strcat
000015F0  3376      
000015F2  504F      2293          addq.w    #8,A7
                    2294   ; BytePointer = (char*)(WatchPointAddress[x]);
000015F4  48C2      2295          ext.l     D2
000015F6  2002      2296          move.l    D2,D0
000015F8  E588      2297          lsl.l     #2,D0
000015FA  41F9 0803 2298          lea       _WatchPointAddress.L,A0
000015FE  0182      
00001600  2A30 0800 2299          move.l    0(A0,D0.L),D5
                    2300   ; for (j = 0; j < (short)(16); j++)
00001604  4243      2301          clr.w     D3
                    2302   DumpRegisters_12:
00001606  0C43 0010 2303          cmp.w     #16,D3
0000160A  6C00 007E 2304          bge       DumpRegisters_14
                    2305   ; {
                    2306   ; c = ((char)(BytePointer[j]) & 0x7f);
0000160E  2045      2307          move.l    D5,A0
00001610  48C3      2308          ext.l     D3
00001612  1030 3800 2309          move.b    0(A0,D3.L),D0
00001616  C03C 007F 2310          and.b     #127,D0
0000161A  1E00      2311          move.b    D0,D7
                    2312   ; if ((c > (char)(0x7f)) || (c < (char)(' ')))
0000161C  0C07 007F 2313          cmp.b     #127,D7
00001620  6206      2314          bhi.s     DumpRegisters_17
00001622  0C07 0020 2315          cmp.b     #32,D7
00001626  6416      2316          bhs.s     DumpRegisters_15
                    2317   DumpRegisters_17:
                    2318   ; sprintf(TempString, ".");
00001628  4879 0000 2319          pea       @m68kde~1_29.L
0000162C  3FAE      
0000162E  4879 0803 2320          pea       _TempString.L
00001632  04E2      
00001634  4EB9 0000 2321          jsr       _sprintf
00001638  3342      
0000163A  504F      2322          addq.w    #8,A7
0000163C  6026      2323          bra.s     DumpRegisters_16
                    2324   DumpRegisters_15:
                    2325   ; else
                    2326   ; sprintf(TempString, "%c", BytePointer[j]);
0000163E  2045      2327          move.l    D5,A0
00001640  48C3      2328          ext.l     D3
00001642  1230 3800 2329          move.b    0(A0,D3.L),D1
00001646  C2BC 0000 2330          and.l     #255,D1
0000164A  00FF      
0000164C  2F01      2331          move.l    D1,-(A7)
0000164E  4879 0000 2332          pea       @m68kde~1_30.L
00001652  3FB0      
00001654  4879 0803 2333          pea       _TempString.L
00001658  04E2      
0000165A  4EB9 0000 2334          jsr       _sprintf
0000165E  3342      
00001660  DEFC 000C 2335          add.w     #12,A7
                    2336   DumpRegisters_16:
                    2337   ; strcat(WatchPointString[x], TempString);
00001664  4879 0803 2338          pea       _TempString.L
00001668  04E2      
0000166A  220D      2339          move.l    A5,D1
0000166C  48C2      2340          ext.l     D2
0000166E  2F00      2341          move.l    D0,-(A7)
00001670  2002      2342          move.l    D2,D0
00001672  C1FC 0064 2343          muls      #100,D0
00001676  D280      2344          add.l     D0,D1
00001678  201F      2345          move.l    (A7)+,D0
0000167A  2F01      2346          move.l    D1,-(A7)
0000167C  4EB9 0000 2347          jsr       _strcat
00001680  3376      
00001682  504F      2348          addq.w    #8,A7
00001684  5243      2349          addq.w    #1,D3
00001686  6000 FF7E 2350          bra       DumpRegisters_12
                    2351   DumpRegisters_14:
0000168A  6020      2352          bra.s     DumpRegisters_5
                    2353   DumpRegisters_4:
                    2354   ; }
                    2355   ; }
                    2356   ; else
                    2357   ; strcpy(WatchPointString[x], "");
0000168C  4879 0000 2358          pea       @m68kde~1_31.L
00001690  3FB4      
00001692  220D      2359          move.l    A5,D1
00001694  48C2      2360          ext.l     D2
00001696  2F00      2361          move.l    D0,-(A7)
00001698  2002      2362          move.l    D2,D0
0000169A  C1FC 0064 2363          muls      #100,D0
0000169E  D280      2364          add.l     D0,D1
000016A0  201F      2365          move.l    (A7)+,D0
000016A2  2F01      2366          move.l    D1,-(A7)
000016A4  4EB9 0000 2367          jsr       _strcpy
000016A8  31BC      
000016AA  504F      2368          addq.w    #8,A7
                    2369   DumpRegisters_5:
000016AC  5242      2370          addq.w    #1,D2
000016AE  6000 FE36 2371          bra       DumpRegisters_1
                    2372   DumpRegisters_3:
                    2373   ; }
                    2374   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X", d0, a0);
000016B2  2F39 0803 2375          move.l    _a0.L,-(A7)
000016B6  0104      
000016B8  2F39 0803 2376          move.l    _d0.L,-(A7)
000016BC  00E4      
000016BE  4879 0000 2377          pea       @m68kde~1_32.L
000016C2  3FB6      
000016C4  4E93      2378          jsr       (A3)
000016C6  DEFC 000C 2379          add.w     #12,A7
                    2380   ; printf("\r\n D1 = $%08X  A1 = $%08X", d1, a1);
000016CA  2F39 0803 2381          move.l    _a1.L,-(A7)
000016CE  0108      
000016D0  2F39 0803 2382          move.l    _d1.L,-(A7)
000016D4  00E8      
000016D6  4879 0000 2383          pea       @m68kde~1_33.L
000016DA  3FD2      
000016DC  4E93      2384          jsr       (A3)
000016DE  DEFC 000C 2385          add.w     #12,A7
                    2386   ; printf("\r\n D2 = $%08X  A2 = $%08X", d2, a2);
000016E2  2F39 0803 2387          move.l    _a2.L,-(A7)
000016E6  010C      
000016E8  2F39 0803 2388          move.l    _d2.L,-(A7)
000016EC  00EC      
000016EE  4879 0000 2389          pea       @m68kde~1_34.L
000016F2  3FEC      
000016F4  4E93      2390          jsr       (A3)
000016F6  DEFC 000C 2391          add.w     #12,A7
                    2392   ; printf("\r\n D3 = $%08X  A3 = $%08X", d3, a3);
000016FA  2F39 0803 2393          move.l    _a3.L,-(A7)
000016FE  0110      
00001700  2F39 0803 2394          move.l    _d3.L,-(A7)
00001704  00F0      
00001706  4879 0000 2395          pea       @m68kde~1_35.L
0000170A  4006      
0000170C  4E93      2396          jsr       (A3)
0000170E  DEFC 000C 2397          add.w     #12,A7
                    2398   ; printf("\r\n D4 = $%08X  A4 = $%08X", d4, a4);
00001712  2F39 0803 2399          move.l    _a4.L,-(A7)
00001716  0114      
00001718  2F39 0803 2400          move.l    _d4.L,-(A7)
0000171C  00F4      
0000171E  4879 0000 2401          pea       @m68kde~1_36.L
00001722  4020      
00001724  4E93      2402          jsr       (A3)
00001726  DEFC 000C 2403          add.w     #12,A7
                    2404   ; printf("\r\n D5 = $%08X  A5 = $%08X", d5, a5);
0000172A  2F39 0803 2405          move.l    _a5.L,-(A7)
0000172E  0118      
00001730  2F39 0803 2406          move.l    _d5.L,-(A7)
00001734  00F8      
00001736  4879 0000 2407          pea       @m68kde~1_37.L
0000173A  403A      
0000173C  4E93      2408          jsr       (A3)
0000173E  DEFC 000C 2409          add.w     #12,A7
                    2410   ; printf("\r\n D6 = $%08X  A6 = $%08X", d6, a6);
00001742  2F39 0803 2411          move.l    _a6.L,-(A7)
00001746  011C      
00001748  2F39 0803 2412          move.l    _d6.L,-(A7)
0000174C  00FC      
0000174E  4879 0000 2413          pea       @m68kde~1_38.L
00001752  4054      
00001754  4E93      2414          jsr       (A3)
00001756  DEFC 000C 2415          add.w     #12,A7
                    2416   ; printf("\r\n D7 = $%08X  A7 = $%08X", d7, ((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP);
0000175A  3214      2417          move.w    (A4),D1
0000175C  C27C 2000 2418          and.w     #8192,D1
00001760  0C41 2000 2419          cmp.w     #8192,D1
00001764  6608      2420          bne.s     DumpRegisters_18
00001766  2239 0803 2421          move.l    _SSP.L,D1
0000176A  0124      
0000176C  6006      2422          bra.s     DumpRegisters_19
                    2423   DumpRegisters_18:
0000176E  2239 0803 2424          move.l    _USP.L,D1
00001772  0128      
                    2425   DumpRegisters_19:
00001774  2F01      2426          move.l    D1,-(A7)
00001776  2F39 0803 2427          move.l    _d7.L,-(A7)
0000177A  0100      
0000177C  4879 0000 2428          pea       @m68kde~1_39.L
00001780  406E      
00001782  4E93      2429          jsr       (A3)
00001784  DEFC 000C 2430          add.w     #12,A7
                    2431   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP);
00001788  2F39 0803 2432          move.l    _USP.L,-(A7)
0000178C  0128      
0000178E  4879 0000 2433          pea       @m68kde~1_40.L
00001792  4088      
00001794  4E93      2434          jsr       (A3)
00001796  504F      2435          addq.w    #8,A7
                    2436   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP);
00001798  2F39 0803 2437          move.l    _SSP.L,-(A7)
0000179C  0124      
0000179E  4879 0000 2438          pea       @m68kde~1_41.L
000017A2  40A6      
000017A4  4E93      2439          jsr       (A3)
000017A6  504F      2440          addq.w    #8,A7
                    2441   ; printf("\r\n SR = $%04X   ", SR);
000017A8  3214      2442          move.w    (A4),D1
000017AA  C2BC 0000 2443          and.l     #65535,D1
000017AE  FFFF      
000017B0  2F01      2444          move.l    D1,-(A7)
000017B2  4879 0000 2445          pea       @m68kde~1_42.L
000017B6  40C8      
000017B8  4E93      2446          jsr       (A3)
000017BA  504F      2447          addq.w    #8,A7
                    2448   ; // display the status word in characters etc.
                    2449   ; printf("   [");
000017BC  4879 0000 2450          pea       @m68kde~1_43.L
000017C0  40DA      
000017C2  4E93      2451          jsr       (A3)
000017C4  584F      2452          addq.w    #4,A7
                    2453   ; if ((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T');
000017C6  3014      2454          move.w    (A4),D0
000017C8  C07C 8000 2455          and.w     #32768,D0
000017CC  0C40 8000 2456          cmp.w     #32768,D0
000017D0  660A      2457          bne.s     DumpRegisters_20
000017D2  4878 0054 2458          pea       84
000017D6  4E92      2459          jsr       (A2)
000017D8  584F      2460          addq.w    #4,A7
000017DA  6008      2461          bra.s     DumpRegisters_21
                    2462   DumpRegisters_20:
                    2463   ; else putchar('-');      // Trace bit(bit 15)
000017DC  4878 002D 2464          pea       45
000017E0  4E92      2465          jsr       (A2)
000017E2  584F      2466          addq.w    #4,A7
                    2467   DumpRegisters_21:
                    2468   ; if ((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S');
000017E4  3014      2469          move.w    (A4),D0
000017E6  C07C 2000 2470          and.w     #8192,D0
000017EA  0C40 2000 2471          cmp.w     #8192,D0
000017EE  660A      2472          bne.s     DumpRegisters_22
000017F0  4878 0053 2473          pea       83
000017F4  4E92      2474          jsr       (A2)
000017F6  584F      2475          addq.w    #4,A7
000017F8  6008      2476          bra.s     DumpRegisters_23
                    2477   DumpRegisters_22:
                    2478   ; else putchar('U');      // supervisor bit  (bit 13)
000017FA  4878 0055 2479          pea       85
000017FE  4E92      2480          jsr       (A2)
00001800  584F      2481          addq.w    #4,A7
                    2482   DumpRegisters_23:
                    2483   ; if ((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1');
00001802  3014      2484          move.w    (A4),D0
00001804  C07C 0400 2485          and.w     #1024,D0
00001808  0C40 0400 2486          cmp.w     #1024,D0
0000180C  660A      2487          bne.s     DumpRegisters_24
0000180E  4878 0031 2488          pea       49
00001812  4E92      2489          jsr       (A2)
00001814  584F      2490          addq.w    #4,A7
00001816  6008      2491          bra.s     DumpRegisters_25
                    2492   DumpRegisters_24:
                    2493   ; else putchar('0');      // IRQ2 Bit (bit 10)
00001818  4878 0030 2494          pea       48
0000181C  4E92      2495          jsr       (A2)
0000181E  584F      2496          addq.w    #4,A7
                    2497   DumpRegisters_25:
                    2498   ; if ((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1');
00001820  3014      2499          move.w    (A4),D0
00001822  C07C 0200 2500          and.w     #512,D0
00001826  0C40 0200 2501          cmp.w     #512,D0
0000182A  660A      2502          bne.s     DumpRegisters_26
0000182C  4878 0031 2503          pea       49
00001830  4E92      2504          jsr       (A2)
00001832  584F      2505          addq.w    #4,A7
00001834  6008      2506          bra.s     DumpRegisters_27
                    2507   DumpRegisters_26:
                    2508   ; else putchar('0');      // IRQ1 Bit (bit 9)
00001836  4878 0030 2509          pea       48
0000183A  4E92      2510          jsr       (A2)
0000183C  584F      2511          addq.w    #4,A7
                    2512   DumpRegisters_27:
                    2513   ; if ((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1');
0000183E  3014      2514          move.w    (A4),D0
00001840  C07C 0100 2515          and.w     #256,D0
00001844  0C40 0100 2516          cmp.w     #256,D0
00001848  660A      2517          bne.s     DumpRegisters_28
0000184A  4878 0031 2518          pea       49
0000184E  4E92      2519          jsr       (A2)
00001850  584F      2520          addq.w    #4,A7
00001852  6008      2521          bra.s     DumpRegisters_29
                    2522   DumpRegisters_28:
                    2523   ; else putchar('0');      // IRQ0 Bit (bit 8)
00001854  4878 0030 2524          pea       48
00001858  4E92      2525          jsr       (A2)
0000185A  584F      2526          addq.w    #4,A7
                    2527   DumpRegisters_29:
                    2528   ; if ((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X');
0000185C  3014      2529          move.w    (A4),D0
0000185E  C07C 0010 2530          and.w     #16,D0
00001862  0C40 0010 2531          cmp.w     #16,D0
00001866  660A      2532          bne.s     DumpRegisters_30
00001868  4878 0058 2533          pea       88
0000186C  4E92      2534          jsr       (A2)
0000186E  584F      2535          addq.w    #4,A7
00001870  6008      2536          bra.s     DumpRegisters_31
                    2537   DumpRegisters_30:
                    2538   ; else putchar('-');      // X Bit (bit 4)
00001872  4878 002D 2539          pea       45
00001876  4E92      2540          jsr       (A2)
00001878  584F      2541          addq.w    #4,A7
                    2542   DumpRegisters_31:
                    2543   ; if ((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N');
0000187A  3014      2544          move.w    (A4),D0
0000187C  C07C 0008 2545          and.w     #8,D0
00001880  0C40 0008 2546          cmp.w     #8,D0
00001884  660A      2547          bne.s     DumpRegisters_32
00001886  4878 004E 2548          pea       78
0000188A  4E92      2549          jsr       (A2)
0000188C  584F      2550          addq.w    #4,A7
0000188E  6008      2551          bra.s     DumpRegisters_33
                    2552   DumpRegisters_32:
                    2553   ; else putchar('-');      // N Bit (bit 3)
00001890  4878 002D 2554          pea       45
00001894  4E92      2555          jsr       (A2)
00001896  584F      2556          addq.w    #4,A7
                    2557   DumpRegisters_33:
                    2558   ; if ((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z');
00001898  3014      2559          move.w    (A4),D0
0000189A  C07C 0004 2560          and.w     #4,D0
0000189E  0C40 0004 2561          cmp.w     #4,D0
000018A2  660A      2562          bne.s     DumpRegisters_34
000018A4  4878 005A 2563          pea       90
000018A8  4E92      2564          jsr       (A2)
000018AA  584F      2565          addq.w    #4,A7
000018AC  6008      2566          bra.s     DumpRegisters_35
                    2567   DumpRegisters_34:
                    2568   ; else putchar('-');      // Z Bit (bit 2)
000018AE  4878 002D 2569          pea       45
000018B2  4E92      2570          jsr       (A2)
000018B4  584F      2571          addq.w    #4,A7
                    2572   DumpRegisters_35:
                    2573   ; if ((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V');
000018B6  3014      2574          move.w    (A4),D0
000018B8  C07C 0002 2575          and.w     #2,D0
000018BC  0C40 0002 2576          cmp.w     #2,D0
000018C0  660A      2577          bne.s     DumpRegisters_36
000018C2  4878 0056 2578          pea       86
000018C6  4E92      2579          jsr       (A2)
000018C8  584F      2580          addq.w    #4,A7
000018CA  6008      2581          bra.s     DumpRegisters_37
                    2582   DumpRegisters_36:
                    2583   ; else putchar('-');      // V Bit (bit 1)
000018CC  4878 002D 2584          pea       45
000018D0  4E92      2585          jsr       (A2)
000018D2  584F      2586          addq.w    #4,A7
                    2587   DumpRegisters_37:
                    2588   ; if ((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C');
000018D4  3014      2589          move.w    (A4),D0
000018D6  C07C 0001 2590          and.w     #1,D0
000018DA  0C40 0001 2591          cmp.w     #1,D0
000018DE  660A      2592          bne.s     DumpRegisters_38
000018E0  4878 0043 2593          pea       67
000018E4  4E92      2594          jsr       (A2)
000018E6  584F      2595          addq.w    #4,A7
000018E8  6008      2596          bra.s     DumpRegisters_39
                    2597   DumpRegisters_38:
                    2598   ; else putchar('-');      // C Bit (bit 0)
000018EA  4878 002D 2599          pea       45
000018EE  4E92      2600          jsr       (A2)
000018F0  584F      2601          addq.w    #4,A7
                    2602   DumpRegisters_39:
                    2603   ; putchar(']');
000018F2  4878 005D 2604          pea       93
000018F6  4E92      2605          jsr       (A2)
000018F8  584F      2606          addq.w    #4,A7
                    2607   ; printf("\r\n PC = $%08X  ", PC);
000018FA  2F39 0803 2608          move.l    _PC.L,-(A7)
000018FE  0120      
00001900  4879 0000 2609          pea       @m68kde~1_44.L
00001904  40E0      
00001906  4E93      2610          jsr       (A3)
00001908  504F      2611          addq.w    #8,A7
                    2612   ; if (*(unsigned short int*)(PC) == 0x4e4e)
0000190A  2039 0803 2613          move.l    _PC.L,D0
0000190E  0120      
00001910  2040      2614          move.l    D0,A0
00001912  3010      2615          move.w    (A0),D0
00001914  0C40 4E4E 2616          cmp.w     #20046,D0
00001918  660A      2617          bne.s     DumpRegisters_40
                    2618   ; printf("[@ BREAKPOINT]");
0000191A  4879 0000 2619          pea       @m68kde~1_45.L
0000191E  40F0      
00001920  4E93      2620          jsr       (A3)
00001922  584F      2621          addq.w    #4,A7
                    2622   DumpRegisters_40:
                    2623   ; printf("\r\n");
00001924  4879 0000 2624          pea       @m68kde~1_1.L
00001928  3D08      
0000192A  4E93      2625          jsr       (A3)
0000192C  584F      2626          addq.w    #4,A7
                    2627   ; for (i = 0; i < 8; i++) {
0000192E  4244      2628          clr.w     D4
                    2629   DumpRegisters_42:
00001930  0C44 0008 2630          cmp.w     #8,D4
00001934  6C00 0040 2631          bge       DumpRegisters_44
                    2632   ; if (WatchPointSetOrCleared[i] == 1)
00001938  48C4      2633          ext.l     D4
0000193A  2004      2634          move.l    D4,D0
0000193C  E588      2635          lsl.l     #2,D0
0000193E  41F9 0803 2636          lea       _WatchPointSetOrCleared.L,A0
00001942  01A2      
00001944  2030 0800 2637          move.l    0(A0,D0.L),D0
00001948  0C80 0000 2638          cmp.l     #1,D0
0000194C  0001      
0000194E  6622      2639          bne.s     DumpRegisters_45
                    2640   ; printf("\r\nWP%d = %s", i, WatchPointString[i]);
00001950  220D      2641          move.l    A5,D1
00001952  48C4      2642          ext.l     D4
00001954  2F00      2643          move.l    D0,-(A7)
00001956  2004      2644          move.l    D4,D0
00001958  C1FC 0064 2645          muls      #100,D0
0000195C  D280      2646          add.l     D0,D1
0000195E  201F      2647          move.l    (A7)+,D0
00001960  2F01      2648          move.l    D1,-(A7)
00001962  48C4      2649          ext.l     D4
00001964  2F04      2650          move.l    D4,-(A7)
00001966  4879 0000 2651          pea       @m68kde~1_46.L
0000196A  4100      
0000196C  4E93      2652          jsr       (A3)
0000196E  DEFC 000C 2653          add.w     #12,A7
                    2654   DumpRegisters_45:
00001972  5244      2655          addq.w    #1,D4
00001974  60BA      2656          bra       DumpRegisters_42
                    2657   DumpRegisters_44:
00001976  4CDF 3CFC 2658          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0000197A  4E75      2659          rts
                    2660   ; }
                    2661   ; }
                    2662   ; // Trace Exception Handler
                    2663   ; void DumpRegistersandPause(void)
                    2664   ; {
                    2665   _DumpRegistersandPause:
0000197C  2F0A      2666          move.l    A2,-(A7)
0000197E  45F9 0000 2667          lea       _printf.L,A2
00001982  33B8      
                    2668   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]");
00001984  4879 0000 2669          pea       @m68kde~1_47.L
00001988  410C      
0000198A  4E92      2670          jsr       (A2)
0000198C  584F      2671          addq.w    #4,A7
                    2672   ; printf("\r\nBreak Points :[Disabled]");
0000198E  4879 0000 2673          pea       @m68kde~1_48.L
00001992  412C      
00001994  4E92      2674          jsr       (A2)
00001996  584F      2675          addq.w    #4,A7
                    2676   ; DumpRegisters();
00001998  4EB8 14C8 2677          jsr       _DumpRegisters
                    2678   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000199C  4879 0000 2679          pea       @m68kde~1_49.L
000019A0  4148      
000019A2  4E92      2680          jsr       (A2)
000019A4  584F      2681          addq.w    #4,A7
                    2682   ; printf("\r\nPress <ESC> to Resume Program");
000019A6  4879 0000 2683          pea       @m68kde~1_50.L
000019AA  4174      
000019AC  4E92      2684          jsr       (A2)
000019AE  584F      2685          addq.w    #4,A7
                    2686   ; menu();
000019B0  4EB9 0000 2687          jsr       _menu
000019B4  2560      
000019B6  245F      2688          move.l    (A7)+,A2
000019B8  4E75      2689          rts
                    2690   ; }
                    2691   ; void ChangeRegisters(void)
                    2692   ; {
                    2693   _ChangeRegisters:
000019BA  4E56 FFFC 2694          link      A6,#-4
000019BE  48E7 303C 2695          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000019C2  45F9 0000 2696          lea       _printf.L,A2
000019C6  33B8      
000019C8  47EE FFFC 2697          lea       -4(A6),A3
000019CC  49F8 0CA4 2698          lea       _Get8HexDigits.L,A4
000019D0  4BF8 0B68 2699          lea       __getch.L,A5
                    2700   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2701   ; int reg_val;
                    2702   ; char c, reg[3];
                    2703   ; reg[0] = tolower(_getch());
000019D4  2F00      2704          move.l    D0,-(A7)
000019D6  4E95      2705          jsr       (A5)
000019D8  2200      2706          move.l    D0,D1
000019DA  201F      2707          move.l    (A7)+,D0
000019DC  2F01      2708          move.l    D1,-(A7)
000019DE  4EB9 0000 2709          jsr       _tolower
000019E2  3316      
000019E4  584F      2710          addq.w    #4,A7
000019E6  1680      2711          move.b    D0,(A3)
                    2712   ; reg[1] = c = tolower(_getch());
000019E8  2F00      2713          move.l    D0,-(A7)
000019EA  4E95      2714          jsr       (A5)
000019EC  2200      2715          move.l    D0,D1
000019EE  201F      2716          move.l    (A7)+,D0
000019F0  2F01      2717          move.l    D1,-(A7)
000019F2  4EB9 0000 2718          jsr       _tolower
000019F6  3316      
000019F8  584F      2719          addq.w    #4,A7
000019FA  1400      2720          move.b    D0,D2
000019FC  1740 0001 2721          move.b    D0,1(A3)
                    2722   ; if (reg[0] == (char)('d')) {    // change data register
00001A00  1013      2723          move.b    (A3),D0
00001A02  0C00 0064 2724          cmp.b     #100,D0
00001A06  6600 00AE 2725          bne       ChangeRegisters_1
                    2726   ; if ((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
00001A0A  102B 0001 2727          move.b    1(A3),D0
00001A0E  0C00 0037 2728          cmp.b     #55,D0
00001A12  6E0A      2729          bgt.s     ChangeRegisters_5
00001A14  102B 0001 2730          move.b    1(A3),D0
00001A18  0C00 0030 2731          cmp.b     #48,D0
00001A1C  6C0E      2732          bge.s     ChangeRegisters_3
                    2733   ChangeRegisters_5:
                    2734   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n");
00001A1E  4879 0000 2735          pea       @m68kde~1_51.L
00001A22  4194      
00001A24  4E92      2736          jsr       (A2)
00001A26  584F      2737          addq.w    #4,A7
                    2738   ; return;
00001A28  6000 0244 2739          bra       ChangeRegisters_6
                    2740   ChangeRegisters_3:
                    2741   ; }
                    2742   ; else {
                    2743   ; printf("\r\nD%c = ", c);
00001A2C  4882      2744          ext.w     D2
00001A2E  48C2      2745          ext.l     D2
00001A30  2F02      2746          move.l    D2,-(A7)
00001A32  4879 0000 2747          pea       @m68kde~1_52.L
00001A36  41C0      
00001A38  4E92      2748          jsr       (A2)
00001A3A  504F      2749          addq.w    #8,A7
                    2750   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001A3C  42A7      2751          clr.l     -(A7)
00001A3E  4E94      2752          jsr       (A4)
00001A40  584F      2753          addq.w    #4,A7
00001A42  2600      2754          move.l    D0,D3
                    2755   ; }
                    2756   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2757   ; if (c == (char)('0'))
00001A44  0C02 0030 2758          cmp.b     #48,D2
00001A48  660A      2759          bne.s     ChangeRegisters_7
                    2760   ; d0 = reg_val;
00001A4A  23C3 0803 2761          move.l    D3,_d0.L
00001A4E  00E4      
00001A50  6000 0060 2762          bra       ChangeRegisters_20
                    2763   ChangeRegisters_7:
                    2764   ; else if (c == (char)('1'))
00001A54  0C02 0031 2765          cmp.b     #49,D2
00001A58  660A      2766          bne.s     ChangeRegisters_9
                    2767   ; d1 = reg_val;
00001A5A  23C3 0803 2768          move.l    D3,_d1.L
00001A5E  00E8      
00001A60  6000 0050 2769          bra       ChangeRegisters_20
                    2770   ChangeRegisters_9:
                    2771   ; else if (c == (char)('2'))
00001A64  0C02 0032 2772          cmp.b     #50,D2
00001A68  660A      2773          bne.s     ChangeRegisters_11
                    2774   ; d2 = reg_val;
00001A6A  23C3 0803 2775          move.l    D3,_d2.L
00001A6E  00EC      
00001A70  6000 0040 2776          bra       ChangeRegisters_20
                    2777   ChangeRegisters_11:
                    2778   ; else if (c == (char)('3'))
00001A74  0C02 0033 2779          cmp.b     #51,D2
00001A78  6608      2780          bne.s     ChangeRegisters_13
                    2781   ; d3 = reg_val;
00001A7A  23C3 0803 2782          move.l    D3,_d3.L
00001A7E  00F0      
00001A80  6030      2783          bra.s     ChangeRegisters_20
                    2784   ChangeRegisters_13:
                    2785   ; else if (c == (char)('4'))
00001A82  0C02 0034 2786          cmp.b     #52,D2
00001A86  6608      2787          bne.s     ChangeRegisters_15
                    2788   ; d4 = reg_val;
00001A88  23C3 0803 2789          move.l    D3,_d4.L
00001A8C  00F4      
00001A8E  6022      2790          bra.s     ChangeRegisters_20
                    2791   ChangeRegisters_15:
                    2792   ; else if (c == (char)('5'))
00001A90  0C02 0035 2793          cmp.b     #53,D2
00001A94  6608      2794          bne.s     ChangeRegisters_17
                    2795   ; d5 = reg_val;
00001A96  23C3 0803 2796          move.l    D3,_d5.L
00001A9A  00F8      
00001A9C  6014      2797          bra.s     ChangeRegisters_20
                    2798   ChangeRegisters_17:
                    2799   ; else if (c == (char)('6'))
00001A9E  0C02 0036 2800          cmp.b     #54,D2
00001AA2  6608      2801          bne.s     ChangeRegisters_19
                    2802   ; d6 = reg_val;
00001AA4  23C3 0803 2803          move.l    D3,_d6.L
00001AA8  00FC      
00001AAA  6006      2804          bra.s     ChangeRegisters_20
                    2805   ChangeRegisters_19:
                    2806   ; else
                    2807   ; d7 = reg_val;
00001AAC  23C3 0803 2808          move.l    D3,_d7.L
00001AB0  0100      
                    2809   ChangeRegisters_20:
00001AB2  6000 01B6 2810          bra       ChangeRegisters_51
                    2811   ChangeRegisters_1:
                    2812   ; }
                    2813   ; else if (reg[0] == (char)('a')) {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001AB6  1013      2814          move.b    (A3),D0
00001AB8  0C00 0061 2815          cmp.b     #97,D0
00001ABC  6600 00A6 2816          bne       ChangeRegisters_21
                    2817   ; if ((c > (char)('7')) || (c < (char)('0'))) {
00001AC0  0C02 0037 2818          cmp.b     #55,D2
00001AC4  6E06      2819          bgt.s     ChangeRegisters_25
00001AC6  0C02 0030 2820          cmp.b     #48,D2
00001ACA  6C0E      2821          bge.s     ChangeRegisters_23
                    2822   ChangeRegisters_25:
                    2823   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n");
00001ACC  4879 0000 2824          pea       @m68kde~1_53.L
00001AD0  41CA      
00001AD2  4E92      2825          jsr       (A2)
00001AD4  584F      2826          addq.w    #4,A7
                    2827   ; return;
00001AD6  6000 0196 2828          bra       ChangeRegisters_6
                    2829   ChangeRegisters_23:
                    2830   ; }
                    2831   ; else {
                    2832   ; printf("\r\nA%c = ", c);
00001ADA  4882      2833          ext.w     D2
00001ADC  48C2      2834          ext.l     D2
00001ADE  2F02      2835          move.l    D2,-(A7)
00001AE0  4879 0000 2836          pea       @m68kde~1_54.L
00001AE4  41F8      
00001AE6  4E92      2837          jsr       (A2)
00001AE8  504F      2838          addq.w    #8,A7
                    2839   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001AEA  42A7      2840          clr.l     -(A7)
00001AEC  4E94      2841          jsr       (A4)
00001AEE  584F      2842          addq.w    #4,A7
00001AF0  2600      2843          move.l    D0,D3
                    2844   ; }
                    2845   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2846   ; if (c == (char)('0'))
00001AF2  0C02 0030 2847          cmp.b     #48,D2
00001AF6  660A      2848          bne.s     ChangeRegisters_26
                    2849   ; a0 = reg_val;
00001AF8  23C3 0803 2850          move.l    D3,_a0.L
00001AFC  0104      
00001AFE  6000 0060 2851          bra       ChangeRegisters_39
                    2852   ChangeRegisters_26:
                    2853   ; else if (c == (char)('1'))
00001B02  0C02 0031 2854          cmp.b     #49,D2
00001B06  660A      2855          bne.s     ChangeRegisters_28
                    2856   ; a1 = reg_val;
00001B08  23C3 0803 2857          move.l    D3,_a1.L
00001B0C  0108      
00001B0E  6000 0050 2858          bra       ChangeRegisters_39
                    2859   ChangeRegisters_28:
                    2860   ; else if (c == (char)('2'))
00001B12  0C02 0032 2861          cmp.b     #50,D2
00001B16  660A      2862          bne.s     ChangeRegisters_30
                    2863   ; a2 = reg_val;
00001B18  23C3 0803 2864          move.l    D3,_a2.L
00001B1C  010C      
00001B1E  6000 0040 2865          bra       ChangeRegisters_39
                    2866   ChangeRegisters_30:
                    2867   ; else if (c == (char)('3'))
00001B22  0C02 0033 2868          cmp.b     #51,D2
00001B26  6608      2869          bne.s     ChangeRegisters_32
                    2870   ; a3 = reg_val;
00001B28  23C3 0803 2871          move.l    D3,_a3.L
00001B2C  0110      
00001B2E  6030      2872          bra.s     ChangeRegisters_39
                    2873   ChangeRegisters_32:
                    2874   ; else if (c == (char)('4'))
00001B30  0C02 0034 2875          cmp.b     #52,D2
00001B34  6608      2876          bne.s     ChangeRegisters_34
                    2877   ; a4 = reg_val;
00001B36  23C3 0803 2878          move.l    D3,_a4.L
00001B3A  0114      
00001B3C  6022      2879          bra.s     ChangeRegisters_39
                    2880   ChangeRegisters_34:
                    2881   ; else if (c == (char)('5'))
00001B3E  0C02 0035 2882          cmp.b     #53,D2
00001B42  6608      2883          bne.s     ChangeRegisters_36
                    2884   ; a5 = reg_val;
00001B44  23C3 0803 2885          move.l    D3,_a5.L
00001B48  0118      
00001B4A  6014      2886          bra.s     ChangeRegisters_39
                    2887   ChangeRegisters_36:
                    2888   ; else if (c == (char)('6'))
00001B4C  0C02 0036 2889          cmp.b     #54,D2
00001B50  6608      2890          bne.s     ChangeRegisters_38
                    2891   ; a6 = reg_val;
00001B52  23C3 0803 2892          move.l    D3,_a6.L
00001B56  011C      
00001B58  6006      2893          bra.s     ChangeRegisters_39
                    2894   ChangeRegisters_38:
                    2895   ; else
                    2896   ; USP = reg_val;
00001B5A  23C3 0803 2897          move.l    D3,_USP.L
00001B5E  0128      
                    2898   ChangeRegisters_39:
00001B60  6000 0108 2899          bra       ChangeRegisters_51
                    2900   ChangeRegisters_21:
                    2901   ; }
                    2902   ; else if ((reg[0] == (char)('u')) && (c == (char)('s'))) {
00001B64  1013      2903          move.b    (A3),D0
00001B66  0C00 0075 2904          cmp.b     #117,D0
00001B6A  6600 004E 2905          bne       ChangeRegisters_40
00001B6E  0C02 0073 2906          cmp.b     #115,D2
00001B72  6600 0046 2907          bne       ChangeRegisters_40
                    2908   ; if (tolower(_getch()) == 'p') {    // change user stack pointer
00001B76  2F00      2909          move.l    D0,-(A7)
00001B78  4E95      2910          jsr       (A5)
00001B7A  2200      2911          move.l    D0,D1
00001B7C  201F      2912          move.l    (A7)+,D0
00001B7E  2F01      2913          move.l    D1,-(A7)
00001B80  4EB9 0000 2914          jsr       _tolower
00001B84  3316      
00001B86  584F      2915          addq.w    #4,A7
00001B88  0C80 0000 2916          cmp.l     #112,D0
00001B8C  0070      
00001B8E  6618      2917          bne.s     ChangeRegisters_42
                    2918   ; printf("\r\nUser SP = ");
00001B90  4879 0000 2919          pea       @m68kde~1_55.L
00001B94  4202      
00001B96  4E92      2920          jsr       (A2)
00001B98  584F      2921          addq.w    #4,A7
                    2922   ; USP = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001B9A  42A7      2923          clr.l     -(A7)
00001B9C  4E94      2924          jsr       (A4)
00001B9E  584F      2925          addq.w    #4,A7
00001BA0  23C0 0803 2926          move.l    D0,_USP.L
00001BA4  0128      
00001BA6  600E      2927          bra.s     ChangeRegisters_43
                    2928   ChangeRegisters_42:
                    2929   ; }
                    2930   ; else {
                    2931   ; printf("\r\nIllegal Register....");
00001BA8  4879 0000 2932          pea       @m68kde~1_56.L
00001BAC  4210      
00001BAE  4E92      2933          jsr       (A2)
00001BB0  584F      2934          addq.w    #4,A7
                    2935   ; return;
00001BB2  6000 00BA 2936          bra       ChangeRegisters_6
                    2937   ChangeRegisters_43:
00001BB6  6000 00B2 2938          bra       ChangeRegisters_51
                    2939   ChangeRegisters_40:
                    2940   ; }
                    2941   ; }
                    2942   ; else if ((reg[0] == (char)('s')) && (c == (char)('s'))) {
00001BBA  1013      2943          move.b    (A3),D0
00001BBC  0C00 0073 2944          cmp.b     #115,D0
00001BC0  6600 004E 2945          bne       ChangeRegisters_44
00001BC4  0C02 0073 2946          cmp.b     #115,D2
00001BC8  6600 0046 2947          bne       ChangeRegisters_44
                    2948   ; if (tolower(_getch()) == 'p') {    // change system stack pointer
00001BCC  2F00      2949          move.l    D0,-(A7)
00001BCE  4E95      2950          jsr       (A5)
00001BD0  2200      2951          move.l    D0,D1
00001BD2  201F      2952          move.l    (A7)+,D0
00001BD4  2F01      2953          move.l    D1,-(A7)
00001BD6  4EB9 0000 2954          jsr       _tolower
00001BDA  3316      
00001BDC  584F      2955          addq.w    #4,A7
00001BDE  0C80 0000 2956          cmp.l     #112,D0
00001BE2  0070      
00001BE4  6618      2957          bne.s     ChangeRegisters_46
                    2958   ; printf("\r\nSystem SP = ");
00001BE6  4879 0000 2959          pea       @m68kde~1_57.L
00001BEA  4228      
00001BEC  4E92      2960          jsr       (A2)
00001BEE  584F      2961          addq.w    #4,A7
                    2962   ; SSP = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001BF0  42A7      2963          clr.l     -(A7)
00001BF2  4E94      2964          jsr       (A4)
00001BF4  584F      2965          addq.w    #4,A7
00001BF6  23C0 0803 2966          move.l    D0,_SSP.L
00001BFA  0124      
00001BFC  600E      2967          bra.s     ChangeRegisters_47
                    2968   ChangeRegisters_46:
                    2969   ; }
                    2970   ; else {
                    2971   ; printf("\r\nIllegal Register....");
00001BFE  4879 0000 2972          pea       @m68kde~1_56.L
00001C02  4210      
00001C04  4E92      2973          jsr       (A2)
00001C06  584F      2974          addq.w    #4,A7
                    2975   ; return;
00001C08  6000 0064 2976          bra       ChangeRegisters_6
                    2977   ChangeRegisters_47:
00001C0C  6000 005C 2978          bra       ChangeRegisters_51
                    2979   ChangeRegisters_44:
                    2980   ; }
                    2981   ; }
                    2982   ; else if ((reg[0] == (char)('p')) && (c == (char)('c'))) {    // change program counter
00001C10  1013      2983          move.b    (A3),D0
00001C12  0C00 0070 2984          cmp.b     #112,D0
00001C16  6620      2985          bne.s     ChangeRegisters_48
00001C18  0C02 0063 2986          cmp.b     #99,D2
00001C1C  661A      2987          bne.s     ChangeRegisters_48
                    2988   ; printf("\r\nPC = ");
00001C1E  4879 0000 2989          pea       @m68kde~1_58.L
00001C22  4238      
00001C24  4E92      2990          jsr       (A2)
00001C26  584F      2991          addq.w    #4,A7
                    2992   ; PC = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001C28  42A7      2993          clr.l     -(A7)
00001C2A  4E94      2994          jsr       (A4)
00001C2C  584F      2995          addq.w    #4,A7
00001C2E  23C0 0803 2996          move.l    D0,_PC.L
00001C32  0120      
00001C34  6000 0034 2997          bra       ChangeRegisters_51
                    2998   ChangeRegisters_48:
                    2999   ; }
                    3000   ; else if ((reg[0] == (char)('s')) && (c == (char)('r'))) {    // change status register
00001C38  1013      3001          move.b    (A3),D0
00001C3A  0C00 0073 3002          cmp.b     #115,D0
00001C3E  6620      3003          bne.s     ChangeRegisters_50
00001C40  0C02 0072 3004          cmp.b     #114,D2
00001C44  661A      3005          bne.s     ChangeRegisters_50
                    3006   ; printf("\r\nSR = ");
00001C46  4879 0000 3007          pea       @m68kde~1_59.L
00001C4A  4240      
00001C4C  4E92      3008          jsr       (A2)
00001C4E  584F      3009          addq.w    #4,A7
                    3010   ; SR = Get4HexDigits(0);    // read 16 bit value from user keyboard
00001C50  42A7      3011          clr.l     -(A7)
00001C52  4EB8 0C58 3012          jsr       _Get4HexDigits
00001C56  584F      3013          addq.w    #4,A7
00001C58  33C0 0803 3014          move.w    D0,_SR.L
00001C5C  012C      
00001C5E  600A      3015          bra.s     ChangeRegisters_51
                    3016   ChangeRegisters_50:
                    3017   ; }
                    3018   ; else
                    3019   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n");
00001C60  4879 0000 3020          pea       @m68kde~1_60.L
00001C64  4248      
00001C66  4E92      3021          jsr       (A2)
00001C68  584F      3022          addq.w    #4,A7
                    3023   ChangeRegisters_51:
                    3024   ; DumpRegisters();
00001C6A  4EB8 14C8 3025          jsr       _DumpRegisters
                    3026   ChangeRegisters_6:
00001C6E  4CDF 3C0C 3027          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001C72  4E5E      3028          unlk      A6
00001C74  4E75      3029          rts
                    3030   ; }
                    3031   ; void BreakPointDisplay(void)
                    3032   ; {
                    3033   _BreakPointDisplay:
00001C76  48E7 3030 3034          movem.l   D2/D3/A2/A3,-(A7)
00001C7A  45F9 0000 3035          lea       _printf.L,A2
00001C7E  33B8      
00001C80  47F9 0803 3036          lea       _BreakPointAddress.L,A3
00001C84  012E      
                    3037   ; int i, BreakPointsSet = 0;
00001C86  4283      3038          clr.l     D3
                    3039   ; // any break points  set
                    3040   ; for (i = 0; i < 8; i++) {
00001C88  4282      3041          clr.l     D2
                    3042   BreakPointDisplay_1:
00001C8A  0C82 0000 3043          cmp.l     #8,D2
00001C8E  0008      
00001C90  6C1C      3044          bge.s     BreakPointDisplay_3
                    3045   ; if (BreakPointSetOrCleared[i] == 1)
00001C92  2002      3046          move.l    D2,D0
00001C94  E588      3047          lsl.l     #2,D0
00001C96  41F9 0803 3048          lea       _BreakPointSetOrCleared.L,A0
00001C9A  015E      
00001C9C  2030 0800 3049          move.l    0(A0,D0.L),D0
00001CA0  0C80 0000 3050          cmp.l     #1,D0
00001CA4  0001      
00001CA6  6602      3051          bne.s     BreakPointDisplay_4
                    3052   ; BreakPointsSet = 1;
00001CA8  7601      3053          moveq     #1,D3
                    3054   BreakPointDisplay_4:
00001CAA  5282      3055          addq.l    #1,D2
00001CAC  60DC      3056          bra       BreakPointDisplay_1
                    3057   BreakPointDisplay_3:
                    3058   ; }
                    3059   ; if (BreakPointsSet == 1) {
00001CAE  0C83 0000 3060          cmp.l     #1,D3
00001CB2  0001      
00001CB4  6616      3061          bne.s     BreakPointDisplay_6
                    3062   ; printf("\r\n\r\nNum     Address      Instruction");
00001CB6  4879 0000 3063          pea       @m68kde~1_61.L
00001CBA  4284      
00001CBC  4E92      3064          jsr       (A2)
00001CBE  584F      3065          addq.w    #4,A7
                    3066   ; printf("\r\n---     ---------    -----------");
00001CC0  4879 0000 3067          pea       @m68kde~1_62.L
00001CC4  42AA      
00001CC6  4E92      3068          jsr       (A2)
00001CC8  584F      3069          addq.w    #4,A7
00001CCA  600A      3070          bra.s     BreakPointDisplay_7
                    3071   BreakPointDisplay_6:
                    3072   ; }
                    3073   ; else
                    3074   ; printf("\r\nNo BreakPoints Set");
00001CCC  4879 0000 3075          pea       @m68kde~1_63.L
00001CD0  42CE      
00001CD2  4E92      3076          jsr       (A2)
00001CD4  584F      3077          addq.w    #4,A7
                    3078   BreakPointDisplay_7:
                    3079   ; for (i = 0; i < 8; i++) {
00001CD6  4282      3080          clr.l     D2
                    3081   BreakPointDisplay_8:
00001CD8  0C82 0000 3082          cmp.l     #8,D2
00001CDC  0008      
00001CDE  6C00 005A 3083          bge       BreakPointDisplay_10
                    3084   ; // put opcode back, then put break point back
                    3085   ; if (BreakPointSetOrCleared[i] == 1) {
00001CE2  2002      3086          move.l    D2,D0
00001CE4  E588      3087          lsl.l     #2,D0
00001CE6  41F9 0803 3088          lea       _BreakPointSetOrCleared.L,A0
00001CEA  015E      
00001CEC  2030 0800 3089          move.l    0(A0,D0.L),D0
00001CF0  0C80 0000 3090          cmp.l     #1,D0
00001CF4  0001      
00001CF6  6600 003E 3091          bne       BreakPointDisplay_11
                    3092   ; *(unsigned short int*)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001CFA  2002      3093          move.l    D2,D0
00001CFC  E388      3094          lsl.l     #1,D0
00001CFE  41F9 0803 3095          lea       _BreakPointInstruction.L,A0
00001D02  014E      
00001D04  2202      3096          move.l    D2,D1
00001D06  E589      3097          lsl.l     #2,D1
00001D08  2233 1800 3098          move.l    0(A3,D1.L),D1
00001D0C  2241      3099          move.l    D1,A1
00001D0E  32B0 0800 3100          move.w    0(A0,D0.L),(A1)
                    3101   ; *(unsigned short int*)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e);
00001D12  2002      3102          move.l    D2,D0
00001D14  E588      3103          lsl.l     #2,D0
00001D16  2033 0800 3104          move.l    0(A3,D0.L),D0
00001D1A  2040      3105          move.l    D0,A0
00001D1C  30BC 4E4E 3106          move.w    #20046,(A0)
                    3107   ; printf("\r\n%3d     $%08x", i, BreakPointAddress[i]);
00001D20  2202      3108          move.l    D2,D1
00001D22  E589      3109          lsl.l     #2,D1
00001D24  2F33 1800 3110          move.l    0(A3,D1.L),-(A7)
00001D28  2F02      3111          move.l    D2,-(A7)
00001D2A  4879 0000 3112          pea       @m68kde~1_64.L
00001D2E  42E4      
00001D30  4E92      3113          jsr       (A2)
00001D32  DEFC 000C 3114          add.w     #12,A7
                    3115   BreakPointDisplay_11:
00001D36  5282      3116          addq.l    #1,D2
00001D38  609E      3117          bra       BreakPointDisplay_8
                    3118   BreakPointDisplay_10:
                    3119   ; }
                    3120   ; }
                    3121   ; printf("\r\n");
00001D3A  4879 0000 3122          pea       @m68kde~1_1.L
00001D3E  3D08      
00001D40  4E92      3123          jsr       (A2)
00001D42  584F      3124          addq.w    #4,A7
00001D44  4CDF 0C0C 3125          movem.l   (A7)+,D2/D3/A2/A3
00001D48  4E75      3126          rts
                    3127   ; }
                    3128   ; void WatchPointDisplay(void)
                    3129   ; {
                    3130   _WatchPointDisplay:
00001D4A  48E7 3020 3131          movem.l   D2/D3/A2,-(A7)
00001D4E  45F9 0000 3132          lea       _printf.L,A2
00001D52  33B8      
                    3133   ; int i;
                    3134   ; int WatchPointsSet = 0;
00001D54  4283      3135          clr.l     D3
                    3136   ; // any watchpoints set
                    3137   ; for (i = 0; i < 8; i++) {
00001D56  4282      3138          clr.l     D2
                    3139   WatchPointDisplay_1:
00001D58  0C82 0000 3140          cmp.l     #8,D2
00001D5C  0008      
00001D5E  6C1C      3141          bge.s     WatchPointDisplay_3
                    3142   ; if (WatchPointSetOrCleared[i] == 1)
00001D60  2002      3143          move.l    D2,D0
00001D62  E588      3144          lsl.l     #2,D0
00001D64  41F9 0803 3145          lea       _WatchPointSetOrCleared.L,A0
00001D68  01A2      
00001D6A  2030 0800 3146          move.l    0(A0,D0.L),D0
00001D6E  0C80 0000 3147          cmp.l     #1,D0
00001D72  0001      
00001D74  6602      3148          bne.s     WatchPointDisplay_4
                    3149   ; WatchPointsSet = 1;
00001D76  7601      3150          moveq     #1,D3
                    3151   WatchPointDisplay_4:
00001D78  5282      3152          addq.l    #1,D2
00001D7A  60DC      3153          bra       WatchPointDisplay_1
                    3154   WatchPointDisplay_3:
                    3155   ; }
                    3156   ; if (WatchPointsSet == 1) {
00001D7C  0C83 0000 3157          cmp.l     #1,D3
00001D80  0001      
00001D82  6616      3158          bne.s     WatchPointDisplay_6
                    3159   ; printf("\r\nNum     Address");
00001D84  4879 0000 3160          pea       @m68kde~1_65.L
00001D88  42F4      
00001D8A  4E92      3161          jsr       (A2)
00001D8C  584F      3162          addq.w    #4,A7
                    3163   ; printf("\r\n---     ---------");
00001D8E  4879 0000 3164          pea       @m68kde~1_66.L
00001D92  4306      
00001D94  4E92      3165          jsr       (A2)
00001D96  584F      3166          addq.w    #4,A7
00001D98  600A      3167          bra.s     WatchPointDisplay_7
                    3168   WatchPointDisplay_6:
                    3169   ; }
                    3170   ; else
                    3171   ; printf("\r\nNo WatchPoints Set");
00001D9A  4879 0000 3172          pea       @m68kde~1_67.L
00001D9E  431A      
00001DA0  4E92      3173          jsr       (A2)
00001DA2  584F      3174          addq.w    #4,A7
                    3175   WatchPointDisplay_7:
                    3176   ; for (i = 0; i < 8; i++) {
00001DA4  4282      3177          clr.l     D2
                    3178   WatchPointDisplay_8:
00001DA6  0C82 0000 3179          cmp.l     #8,D2
00001DAA  0008      
00001DAC  6C00 0038 3180          bge       WatchPointDisplay_10
                    3181   ; if (WatchPointSetOrCleared[i] == 1)
00001DB0  2002      3182          move.l    D2,D0
00001DB2  E588      3183          lsl.l     #2,D0
00001DB4  41F9 0803 3184          lea       _WatchPointSetOrCleared.L,A0
00001DB8  01A2      
00001DBA  2030 0800 3185          move.l    0(A0,D0.L),D0
00001DBE  0C80 0000 3186          cmp.l     #1,D0
00001DC2  0001      
00001DC4  661C      3187          bne.s     WatchPointDisplay_11
                    3188   ; printf("\r\n%3d     $%08x", i, WatchPointAddress[i]);
00001DC6  2202      3189          move.l    D2,D1
00001DC8  E589      3190          lsl.l     #2,D1
00001DCA  41F9 0803 3191          lea       _WatchPointAddress.L,A0
00001DCE  0182      
00001DD0  2F30 1800 3192          move.l    0(A0,D1.L),-(A7)
00001DD4  2F02      3193          move.l    D2,-(A7)
00001DD6  4879 0000 3194          pea       @m68kde~1_64.L
00001DDA  42E4      
00001DDC  4E92      3195          jsr       (A2)
00001DDE  DEFC 000C 3196          add.w     #12,A7
                    3197   WatchPointDisplay_11:
00001DE2  5282      3198          addq.l    #1,D2
00001DE4  60C0      3199          bra       WatchPointDisplay_8
                    3200   WatchPointDisplay_10:
                    3201   ; }
                    3202   ; printf("\r\n");
00001DE6  4879 0000 3203          pea       @m68kde~1_1.L
00001DEA  3D08      
00001DEC  4E92      3204          jsr       (A2)
00001DEE  584F      3205          addq.w    #4,A7
00001DF0  4CDF 040C 3206          movem.l   (A7)+,D2/D3/A2
00001DF4  4E75      3207          rts
                    3208   ; }
                    3209   ; void BreakPointClear(void)
                    3210   ; {
                    3211   _BreakPointClear:
00001DF6  4E56 FFFC 3212          link      A6,#-4
00001DFA  48E7 2020 3213          movem.l   D2/A2,-(A7)
00001DFE  45F9 0000 3214          lea       _printf.L,A2
00001E02  33B8      
                    3215   ; unsigned int i;
                    3216   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3217   ; BreakPointDisplay();
00001E04  4EB8 1C76 3218          jsr       _BreakPointDisplay
                    3219   ; printf("\r\nEnter Break Point Number: ");
00001E08  4879 0000 3220          pea       @m68kde~1_68.L
00001E0C  4330      
00001E0E  4E92      3221          jsr       (A2)
00001E10  584F      3222          addq.w    #4,A7
                    3223   ; i = xtod(_getch());           // get break pointer number
00001E12  2F00      3224          move.l    D0,-(A7)
00001E14  4EB8 0B68 3225          jsr       __getch
00001E18  2200      3226          move.l    D0,D1
00001E1A  201F      3227          move.l    (A7)+,D0
00001E1C  2F01      3228          move.l    D1,-(A7)
00001E1E  4EB8 0BD2 3229          jsr       _xtod
00001E22  584F      3230          addq.w    #4,A7
00001E24  C0BC 0000 3231          and.l     #255,D0
00001E28  00FF      
00001E2A  2400      3232          move.l    D0,D2
                    3233   ; if ((i < 0) || (i > 7)) {
00001E2C  0C82 0000 3234          cmp.l     #0,D2
00001E30  0000      
00001E32  6508      3235          blo.s     BreakPointClear_3
00001E34  0C82 0000 3236          cmp.l     #7,D2
00001E38  0007      
00001E3A  630E      3237          bls.s     BreakPointClear_1
                    3238   BreakPointClear_3:
                    3239   ; printf("\r\nIllegal Range : Use 0 - 7");
00001E3C  4879 0000 3240          pea       @m68kde~1_69.L
00001E40  434E      
00001E42  4E92      3241          jsr       (A2)
00001E44  584F      3242          addq.w    #4,A7
                    3243   ; return;
00001E46  6000 0080 3244          bra       BreakPointClear_4
                    3245   BreakPointClear_1:
                    3246   ; }
                    3247   ; if (BreakPointSetOrCleared[i] == 1) {       // if break point set
00001E4A  2002      3248          move.l    D2,D0
00001E4C  E588      3249          lsl.l     #2,D0
00001E4E  41F9 0803 3250          lea       _BreakPointSetOrCleared.L,A0
00001E52  015E      
00001E54  2030 0800 3251          move.l    0(A0,D0.L),D0
00001E58  0C80 0000 3252          cmp.l     #1,D0
00001E5C  0001      
00001E5E  6600 005A 3253          bne       BreakPointClear_5
                    3254   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program we are about to change
00001E62  2002      3255          move.l    D2,D0
00001E64  E588      3256          lsl.l     #2,D0
00001E66  41F9 0803 3257          lea       _BreakPointAddress.L,A0
00001E6A  012E      
00001E6C  2D70 0800 3258          move.l    0(A0,D0.L),-4(A6)
00001E70  FFFC      
                    3259   ; BreakPointAddress[i] = 0;
00001E72  2002      3260          move.l    D2,D0
00001E74  E588      3261          lsl.l     #2,D0
00001E76  41F9 0803 3262          lea       _BreakPointAddress.L,A0
00001E7A  012E      
00001E7C  42B0 0800 3263          clr.l     0(A0,D0.L)
                    3264   ; BreakPointSetOrCleared[i] = 0;
00001E80  2002      3265          move.l    D2,D0
00001E82  E588      3266          lsl.l     #2,D0
00001E84  41F9 0803 3267          lea       _BreakPointSetOrCleared.L,A0
00001E88  015E      
00001E8A  42B0 0800 3268          clr.l     0(A0,D0.L)
                    3269   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
00001E8E  2002      3270          move.l    D2,D0
00001E90  E388      3271          lsl.l     #1,D0
00001E92  41F9 0803 3272          lea       _BreakPointInstruction.L,A0
00001E96  014E      
00001E98  226E FFFC 3273          move.l    -4(A6),A1
00001E9C  32B0 0800 3274          move.w    0(A0,D0.L),(A1)
                    3275   ; BreakPointInstruction[i] = 0;
00001EA0  2002      3276          move.l    D2,D0
00001EA2  E388      3277          lsl.l     #1,D0
00001EA4  41F9 0803 3278          lea       _BreakPointInstruction.L,A0
00001EA8  014E      
00001EAA  4270 0800 3279          clr.w     0(A0,D0.L)
                    3280   ; printf("\r\nBreak Point Cleared.....\r\n");
00001EAE  4879 0000 3281          pea       @m68kde~1_70.L
00001EB2  436A      
00001EB4  4E92      3282          jsr       (A2)
00001EB6  584F      3283          addq.w    #4,A7
00001EB8  600A      3284          bra.s     BreakPointClear_6
                    3285   BreakPointClear_5:
                    3286   ; }
                    3287   ; else
                    3288   ; printf("\r\nBreak Point wasn't Set.....");
00001EBA  4879 0000 3289          pea       @m68kde~1_71.L
00001EBE  4388      
00001EC0  4E92      3290          jsr       (A2)
00001EC2  584F      3291          addq.w    #4,A7
                    3292   BreakPointClear_6:
                    3293   ; BreakPointDisplay();
00001EC4  4EB8 1C76 3294          jsr       _BreakPointDisplay
                    3295   ; return;
                    3296   BreakPointClear_4:
00001EC8  4CDF 0404 3297          movem.l   (A7)+,D2/A2
00001ECC  4E5E      3298          unlk      A6
00001ECE  4E75      3299          rts
                    3300   ; }
                    3301   ; void WatchPointClear(void)
                    3302   ; {
                    3303   _WatchPointClear:
00001ED0  48E7 2020 3304          movem.l   D2/A2,-(A7)
00001ED4  45F9 0000 3305          lea       _printf.L,A2
00001ED8  33B8      
                    3306   ; unsigned int i;
                    3307   ; WatchPointDisplay();
00001EDA  4EB8 1D4A 3308          jsr       _WatchPointDisplay
                    3309   ; printf("\r\nEnter Watch Point Number: ");
00001EDE  4879 0000 3310          pea       @m68kde~1_72.L
00001EE2  43A6      
00001EE4  4E92      3311          jsr       (A2)
00001EE6  584F      3312          addq.w    #4,A7
                    3313   ; i = xtod(_getch());           // get watch pointer number
00001EE8  2F00      3314          move.l    D0,-(A7)
00001EEA  4EB8 0B68 3315          jsr       __getch
00001EEE  2200      3316          move.l    D0,D1
00001EF0  201F      3317          move.l    (A7)+,D0
00001EF2  2F01      3318          move.l    D1,-(A7)
00001EF4  4EB8 0BD2 3319          jsr       _xtod
00001EF8  584F      3320          addq.w    #4,A7
00001EFA  C0BC 0000 3321          and.l     #255,D0
00001EFE  00FF      
00001F00  2400      3322          move.l    D0,D2
                    3323   ; if ((i < 0) || (i > 7)) {
00001F02  0C82 0000 3324          cmp.l     #0,D2
00001F06  0000      
00001F08  6508      3325          blo.s     WatchPointClear_3
00001F0A  0C82 0000 3326          cmp.l     #7,D2
00001F0E  0007      
00001F10  630E      3327          bls.s     WatchPointClear_1
                    3328   WatchPointClear_3:
                    3329   ; printf("\r\nIllegal Range : Use 0 - 7");
00001F12  4879 0000 3330          pea       @m68kde~1_69.L
00001F16  434E      
00001F18  4E92      3331          jsr       (A2)
00001F1A  584F      3332          addq.w    #4,A7
                    3333   ; return;
00001F1C  6000 004E 3334          bra       WatchPointClear_4
                    3335   WatchPointClear_1:
                    3336   ; }
                    3337   ; if (WatchPointSetOrCleared[i] == 1) {       // if watch point set
00001F20  2002      3338          move.l    D2,D0
00001F22  E588      3339          lsl.l     #2,D0
00001F24  41F9 0803 3340          lea       _WatchPointSetOrCleared.L,A0
00001F28  01A2      
00001F2A  2030 0800 3341          move.l    0(A0,D0.L),D0
00001F2E  0C80 0000 3342          cmp.l     #1,D0
00001F32  0001      
00001F34  6628      3343          bne.s     WatchPointClear_5
                    3344   ; WatchPointAddress[i] = 0;
00001F36  2002      3345          move.l    D2,D0
00001F38  E588      3346          lsl.l     #2,D0
00001F3A  41F9 0803 3347          lea       _WatchPointAddress.L,A0
00001F3E  0182      
00001F40  42B0 0800 3348          clr.l     0(A0,D0.L)
                    3349   ; WatchPointSetOrCleared[i] = 0;
00001F44  2002      3350          move.l    D2,D0
00001F46  E588      3351          lsl.l     #2,D0
00001F48  41F9 0803 3352          lea       _WatchPointSetOrCleared.L,A0
00001F4C  01A2      
00001F4E  42B0 0800 3353          clr.l     0(A0,D0.L)
                    3354   ; printf("\r\nWatch Point Cleared.....\r\n");
00001F52  4879 0000 3355          pea       @m68kde~1_73.L
00001F56  43C4      
00001F58  4E92      3356          jsr       (A2)
00001F5A  584F      3357          addq.w    #4,A7
00001F5C  600A      3358          bra.s     WatchPointClear_6
                    3359   WatchPointClear_5:
                    3360   ; }
                    3361   ; else
                    3362   ; printf("\r\nWatch Point Was not Set.....");
00001F5E  4879 0000 3363          pea       @m68kde~1_74.L
00001F62  43E2      
00001F64  4E92      3364          jsr       (A2)
00001F66  584F      3365          addq.w    #4,A7
                    3366   WatchPointClear_6:
                    3367   ; WatchPointDisplay();
00001F68  4EB8 1D4A 3368          jsr       _WatchPointDisplay
                    3369   ; return;
                    3370   WatchPointClear_4:
00001F6C  4CDF 0404 3371          movem.l   (A7)+,D2/A2
00001F70  4E75      3372          rts
                    3373   ; }
                    3374   ; void DisableBreakPoints(void)
                    3375   ; {
                    3376   _DisableBreakPoints:
00001F72  4E56 FFFC 3377          link      A6,#-4
00001F76  2F02      3378          move.l    D2,-(A7)
                    3379   ; int i;
                    3380   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3381   ; for (i = 0; i < 8; i++) {
00001F78  4282      3382          clr.l     D2
                    3383   DisableBreakPoints_1:
00001F7A  0C82 0000 3384          cmp.l     #8,D2
00001F7E  0008      
00001F80  6C00 003E 3385          bge       DisableBreakPoints_3
                    3386   ; if (BreakPointSetOrCleared[i] == 1) {                                                    // if break point set
00001F84  2002      3387          move.l    D2,D0
00001F86  E588      3388          lsl.l     #2,D0
00001F88  41F9 0803 3389          lea       _BreakPointSetOrCleared.L,A0
00001F8C  015E      
00001F8E  2030 0800 3390          move.l    0(A0,D0.L),D0
00001F92  0C80 0000 3391          cmp.l     #1,D0
00001F96  0001      
00001F98  6622      3392          bne.s     DisableBreakPoints_4
                    3393   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001F9A  2002      3394          move.l    D2,D0
00001F9C  E588      3395          lsl.l     #2,D0
00001F9E  41F9 0803 3396          lea       _BreakPointAddress.L,A0
00001FA2  012E      
00001FA4  2D70 0800 3397          move.l    0(A0,D0.L),-4(A6)
00001FA8  FFFC      
                    3398   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001FAA  2002      3399          move.l    D2,D0
00001FAC  E388      3400          lsl.l     #1,D0
00001FAE  41F9 0803 3401          lea       _BreakPointInstruction.L,A0
00001FB2  014E      
00001FB4  226E FFFC 3402          move.l    -4(A6),A1
00001FB8  32B0 0800 3403          move.w    0(A0,D0.L),(A1)
                    3404   DisableBreakPoints_4:
00001FBC  5282      3405          addq.l    #1,D2
00001FBE  60BA      3406          bra       DisableBreakPoints_1
                    3407   DisableBreakPoints_3:
00001FC0  241F      3408          move.l    (A7)+,D2
00001FC2  4E5E      3409          unlk      A6
00001FC4  4E75      3410          rts
                    3411   ; }
                    3412   ; }
                    3413   ; }
                    3414   ; void EnableBreakPoints(void)
                    3415   ; {
                    3416   _EnableBreakPoints:
00001FC6  4E56 FFFC 3417          link      A6,#-4
00001FCA  2F02      3418          move.l    D2,-(A7)
                    3419   ; int i;
                    3420   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3421   ; for (i = 0; i < 8; i++) {
00001FCC  4282      3422          clr.l     D2
                    3423   EnableBreakPoints_1:
00001FCE  0C82 0000 3424          cmp.l     #8,D2
00001FD2  0008      
00001FD4  6C32      3425          bge.s     EnableBreakPoints_3
                    3426   ; if (BreakPointSetOrCleared[i] == 1) {                                                     // if break point set
00001FD6  2002      3427          move.l    D2,D0
00001FD8  E588      3428          lsl.l     #2,D0
00001FDA  41F9 0803 3429          lea       _BreakPointSetOrCleared.L,A0
00001FDE  015E      
00001FE0  2030 0800 3430          move.l    0(A0,D0.L),D0
00001FE4  0C80 0000 3431          cmp.l     #1,D0
00001FE8  0001      
00001FEA  6618      3432          bne.s     EnableBreakPoints_4
                    3433   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001FEC  2002      3434          move.l    D2,D0
00001FEE  E588      3435          lsl.l     #2,D0
00001FF0  41F9 0803 3436          lea       _BreakPointAddress.L,A0
00001FF4  012E      
00001FF6  2D70 0800 3437          move.l    0(A0,D0.L),-4(A6)
00001FFA  FFFC      
                    3438   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001FFC  206E FFFC 3439          move.l    -4(A6),A0
00002000  30BC 4E4E 3440          move.w    #20046,(A0)
                    3441   EnableBreakPoints_4:
00002004  5282      3442          addq.l    #1,D2
00002006  60C6      3443          bra       EnableBreakPoints_1
                    3444   EnableBreakPoints_3:
00002008  241F      3445          move.l    (A7)+,D2
0000200A  4E5E      3446          unlk      A6
0000200C  4E75      3447          rts
                    3448   ; }
                    3449   ; }
                    3450   ; }
                    3451   ; void KillAllBreakPoints(void)
                    3452   ; {
                    3453   _KillAllBreakPoints:
0000200E  4E56 FFFC 3454          link      A6,#-4
00002012  2F02      3455          move.l    D2,-(A7)
                    3456   ; int i;
                    3457   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3458   ; for (i = 0; i < 8; i++) {
00002014  4282      3459          clr.l     D2
                    3460   KillAllBreakPoints_1:
00002016  0C82 0000 3461          cmp.l     #8,D2
0000201A  0008      
0000201C  6C00 0052 3462          bge       KillAllBreakPoints_3
                    3463   ; // clear BP
                    3464   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00002020  2002      3465          move.l    D2,D0
00002022  E588      3466          lsl.l     #2,D0
00002024  41F9 0803 3467          lea       _BreakPointAddress.L,A0
00002028  012E      
0000202A  2D70 0800 3468          move.l    0(A0,D0.L),-4(A6)
0000202E  FFFC      
                    3469   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00002030  2002      3470          move.l    D2,D0
00002032  E388      3471          lsl.l     #1,D0
00002034  41F9 0803 3472          lea       _BreakPointInstruction.L,A0
00002038  014E      
0000203A  226E FFFC 3473          move.l    -4(A6),A1
0000203E  32B0 0800 3474          move.w    0(A0,D0.L),(A1)
                    3475   ; BreakPointAddress[i] = 0;                                                             // set BP address to NULL
00002042  2002      3476          move.l    D2,D0
00002044  E588      3477          lsl.l     #2,D0
00002046  41F9 0803 3478          lea       _BreakPointAddress.L,A0
0000204A  012E      
0000204C  42B0 0800 3479          clr.l     0(A0,D0.L)
                    3480   ; BreakPointInstruction[i] = 0;
00002050  2002      3481          move.l    D2,D0
00002052  E388      3482          lsl.l     #1,D0
00002054  41F9 0803 3483          lea       _BreakPointInstruction.L,A0
00002058  014E      
0000205A  4270 0800 3484          clr.w     0(A0,D0.L)
                    3485   ; BreakPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
0000205E  2002      3486          move.l    D2,D0
00002060  E588      3487          lsl.l     #2,D0
00002062  41F9 0803 3488          lea       _BreakPointSetOrCleared.L,A0
00002066  015E      
00002068  42B0 0800 3489          clr.l     0(A0,D0.L)
0000206C  5282      3490          addq.l    #1,D2
0000206E  60A6      3491          bra       KillAllBreakPoints_1
                    3492   KillAllBreakPoints_3:
00002070  241F      3493          move.l    (A7)+,D2
00002072  4E5E      3494          unlk      A6
00002074  4E75      3495          rts
                    3496   ; }
                    3497   ; //BreakPointDisplay() ;       // display the break points
                    3498   ; }
                    3499   ; void KillAllWatchPoints(void)
                    3500   ; {
                    3501   _KillAllWatchPoints:
00002076  2F02      3502          move.l    D2,-(A7)
                    3503   ; int i;
                    3504   ; for (i = 0; i < 8; i++) {
00002078  4282      3505          clr.l     D2
                    3506   KillAllWatchPoints_1:
0000207A  0C82 0000 3507          cmp.l     #8,D2
0000207E  0008      
00002080  6C20      3508          bge.s     KillAllWatchPoints_3
                    3509   ; WatchPointAddress[i] = 0;                                                             // set BP address to NULL
00002082  2002      3510          move.l    D2,D0
00002084  E588      3511          lsl.l     #2,D0
00002086  41F9 0803 3512          lea       _WatchPointAddress.L,A0
0000208A  0182      
0000208C  42B0 0800 3513          clr.l     0(A0,D0.L)
                    3514   ; WatchPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
00002090  2002      3515          move.l    D2,D0
00002092  E588      3516          lsl.l     #2,D0
00002094  41F9 0803 3517          lea       _WatchPointSetOrCleared.L,A0
00002098  01A2      
0000209A  42B0 0800 3518          clr.l     0(A0,D0.L)
0000209E  5282      3519          addq.l    #1,D2
000020A0  60D8      3520          bra       KillAllWatchPoints_1
                    3521   KillAllWatchPoints_3:
000020A2  241F      3522          move.l    (A7)+,D2
000020A4  4E75      3523          rts
                    3524   ; }
                    3525   ; //WatchPointDisplay() ;       // display the break points
                    3526   ; }
                    3527   ; void SetBreakPoint(void)
                    3528   ; {
                    3529   _SetBreakPoint:
000020A6  4E56 FFFC 3530          link      A6,#-4
000020AA  48E7 3830 3531          movem.l   D2/D3/D4/A2/A3,-(A7)
000020AE  45F9 0000 3532          lea       _printf.L,A2
000020B2  33B8      
000020B4  47F9 0803 3533          lea       _BreakPointSetOrCleared.L,A3
000020B8  015E      
                    3534   ; int i;
                    3535   ; int BPNumber;
                    3536   ; int BPAddress;
                    3537   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3538   ; // see if any free break points
                    3539   ; for (i = 0; i < 8; i++) {
000020BA  4282      3540          clr.l     D2
                    3541   SetBreakPoint_1:
000020BC  0C82 0000 3542          cmp.l     #8,D2
000020C0  0008      
000020C2  6C10      3543          bge.s     SetBreakPoint_3
                    3544   ; if (BreakPointSetOrCleared[i] == 0)
000020C4  2002      3545          move.l    D2,D0
000020C6  E588      3546          lsl.l     #2,D0
000020C8  2033 0800 3547          move.l    0(A3,D0.L),D0
000020CC  6602      3548          bne.s     SetBreakPoint_4
                    3549   ; break;         // if spare BP found allow user to set it
000020CE  6004      3550          bra.s     SetBreakPoint_3
                    3551   SetBreakPoint_4:
000020D0  5282      3552          addq.l    #1,D2
000020D2  60E8      3553          bra       SetBreakPoint_1
                    3554   SetBreakPoint_3:
                    3555   ; }
                    3556   ; if (i == 8) {
000020D4  0C82 0000 3557          cmp.l     #8,D2
000020D8  0008      
000020DA  660E      3558          bne.s     SetBreakPoint_6
                    3559   ; printf("\r\nNo FREE Break Points.....");
000020DC  4879 0000 3560          pea       @m68kde~1_75.L
000020E0  4402      
000020E2  4E92      3561          jsr       (A2)
000020E4  584F      3562          addq.w    #4,A7
                    3563   ; return;
000020E6  6000 00D6 3564          bra       SetBreakPoint_15
                    3565   SetBreakPoint_6:
                    3566   ; }
                    3567   ; printf("\r\nBreak Point Address: ");
000020EA  4879 0000 3568          pea       @m68kde~1_76.L
000020EE  441E      
000020F0  4E92      3569          jsr       (A2)
000020F2  584F      3570          addq.w    #4,A7
                    3571   ; BPAddress = Get8HexDigits(0);
000020F4  42A7      3572          clr.l     -(A7)
000020F6  4EB8 0CA4 3573          jsr       _Get8HexDigits
000020FA  584F      3574          addq.w    #4,A7
000020FC  2600      3575          move.l    D0,D3
                    3576   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BPAddress);     // point to the instruction in the user program we are about to change
000020FE  2803      3577          move.l    D3,D4
                    3578   ; if ((BPAddress & 0x00000001) == 0x00000001) {   // cannot set BP at an odd address
00002100  2003      3579          move.l    D3,D0
00002102  C0BC 0000 3580          and.l     #1,D0
00002106  0001      
00002108  0C80 0000 3581          cmp.l     #1,D0
0000210C  0001      
0000210E  660E      3582          bne.s     SetBreakPoint_9
                    3583   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses");
00002110  4879 0000 3584          pea       @m68kde~1_77.L
00002114  4436      
00002116  4E92      3585          jsr       (A2)
00002118  584F      3586          addq.w    #4,A7
                    3587   ; return;
0000211A  6000 00A2 3588          bra       SetBreakPoint_15
                    3589   SetBreakPoint_9:
                    3590   ; }
                    3591   ; if (BPAddress < 0x00008000) {   // cannot set BP in ROM
0000211E  0C83 0000 3592          cmp.l     #32768,D3
00002122  8000      
00002124  640E      3593          bhs.s     SetBreakPoint_11
                    3594   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]");
00002126  4879 0000 3595          pea       @m68kde~1_78.L
0000212A  446C      
0000212C  4E92      3596          jsr       (A2)
0000212E  584F      3597          addq.w    #4,A7
                    3598   ; return;
00002130  6000 008C 3599          bra       SetBreakPoint_15
                    3600   SetBreakPoint_11:
                    3601   ; }
                    3602   ; // search for first free bp or existing same BP
                    3603   ; for (i = 0; i < 8; i++) {
00002134  4282      3604          clr.l     D2
                    3605   SetBreakPoint_13:
00002136  0C82 0000 3606          cmp.l     #8,D2
0000213A  0008      
0000213C  6C00 0080 3607          bge       SetBreakPoint_15
                    3608   ; if (BreakPointAddress[i] == BPAddress) {
00002140  2002      3609          move.l    D2,D0
00002142  E588      3610          lsl.l     #2,D0
00002144  41F9 0803 3611          lea       _BreakPointAddress.L,A0
00002148  012E      
0000214A  B6B0 0800 3612          cmp.l     0(A0,D0.L),D3
0000214E  6610      3613          bne.s     SetBreakPoint_16
                    3614   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress);
00002150  2F03      3615          move.l    D3,-(A7)
00002152  4879 0000 3616          pea       @m68kde~1_79.L
00002156  44B4      
00002158  4E92      3617          jsr       (A2)
0000215A  504F      3618          addq.w    #8,A7
                    3619   ; return;
0000215C  6000 0060 3620          bra       SetBreakPoint_15
                    3621   SetBreakPoint_16:
                    3622   ; }
                    3623   ; if (BreakPointSetOrCleared[i] == 0) {
00002160  2002      3624          move.l    D2,D0
00002162  E588      3625          lsl.l     #2,D0
00002164  2033 0800 3626          move.l    0(A3,D0.L),D0
00002168  6600 004E 3627          bne       SetBreakPoint_18
                    3628   ; // set BP here
                    3629   ; BreakPointSetOrCleared[i] = 1;                                 // mark this breakpoint as set
0000216C  2002      3630          move.l    D2,D0
0000216E  E588      3631          lsl.l     #2,D0
00002170  27BC 0000 3632          move.l    #1,0(A3,D0.L)
00002174  0001 0800 
                    3633   ; BreakPointInstruction[i] = *ProgramBreakPointAddress;          // copy the user program instruction here so we can put it back afterwards
00002178  2044      3634          move.l    D4,A0
0000217A  2002      3635          move.l    D2,D0
0000217C  E388      3636          lsl.l     #1,D0
0000217E  43F9 0803 3637          lea       _BreakPointInstruction.L,A1
00002182  014E      
00002184  3390 0800 3638          move.w    (A0),0(A1,D0.L)
                    3639   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress);
00002188  2F04      3640          move.l    D4,-(A7)
0000218A  4879 0000 3641          pea       @m68kde~1_80.L
0000218E  44EC      
00002190  4E92      3642          jsr       (A2)
00002192  504F      3643          addq.w    #8,A7
                    3644   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);   // put a Trap14 instruction at the user specified address
00002194  2044      3645          move.l    D4,A0
00002196  30BC 4E4E 3646          move.w    #20046,(A0)
                    3647   ; BreakPointAddress[i] = BPAddress;                              // record the address of this break point in the debugger
0000219A  2002      3648          move.l    D2,D0
0000219C  E588      3649          lsl.l     #2,D0
0000219E  41F9 0803 3650          lea       _BreakPointAddress.L,A0
000021A2  012E      
000021A4  2183 0800 3651          move.l    D3,0(A0,D0.L)
                    3652   ; printf("\r\n");
000021A8  4879 0000 3653          pea       @m68kde~1_1.L
000021AC  3D08      
000021AE  4E92      3654          jsr       (A2)
000021B0  584F      3655          addq.w    #4,A7
                    3656   ; BreakPointDisplay();       // display the break points
000021B2  4EB8 1C76 3657          jsr       _BreakPointDisplay
                    3658   ; return;
000021B6  6006      3659          bra.s     SetBreakPoint_15
                    3660   SetBreakPoint_18:
000021B8  5282      3661          addq.l    #1,D2
000021BA  6000 FF7A 3662          bra       SetBreakPoint_13
                    3663   SetBreakPoint_15:
000021BE  4CDF 0C1C 3664          movem.l   (A7)+,D2/D3/D4/A2/A3
000021C2  4E5E      3665          unlk      A6
000021C4  4E75      3666          rts
                    3667   ; }
                    3668   ; }
                    3669   ; }
                    3670   ; void SetWatchPoint(void)
                    3671   ; {
                    3672   _SetWatchPoint:
000021C6  4E56 FFF8 3673          link      A6,#-8
000021CA  48E7 3030 3674          movem.l   D2/D3/A2/A3,-(A7)
000021CE  45F9 0000 3675          lea       _printf.L,A2
000021D2  33B8      
000021D4  47F9 0803 3676          lea       _WatchPointSetOrCleared.L,A3
000021D8  01A2      
                    3677   ; int i;
                    3678   ; int WPNumber;
                    3679   ; int WPAddress;
                    3680   ; volatile unsigned short int* ProgramWatchPointAddress;
                    3681   ; // see if any free break points
                    3682   ; for (i = 0; i < 8; i++) {
000021DA  4282      3683          clr.l     D2
                    3684   SetWatchPoint_1:
000021DC  0C82 0000 3685          cmp.l     #8,D2
000021E0  0008      
000021E2  6C10      3686          bge.s     SetWatchPoint_3
                    3687   ; if (WatchPointSetOrCleared[i] == 0)
000021E4  2002      3688          move.l    D2,D0
000021E6  E588      3689          lsl.l     #2,D0
000021E8  2033 0800 3690          move.l    0(A3,D0.L),D0
000021EC  6602      3691          bne.s     SetWatchPoint_4
                    3692   ; break;         // if spare WP found allow user to set it
000021EE  6004      3693          bra.s     SetWatchPoint_3
                    3694   SetWatchPoint_4:
000021F0  5282      3695          addq.l    #1,D2
000021F2  60E8      3696          bra       SetWatchPoint_1
                    3697   SetWatchPoint_3:
                    3698   ; }
                    3699   ; if (i == 8) {
000021F4  0C82 0000 3700          cmp.l     #8,D2
000021F8  0008      
000021FA  660E      3701          bne.s     SetWatchPoint_6
                    3702   ; printf("\r\nNo FREE Watch Points.....");
000021FC  4879 0000 3703          pea       @m68kde~1_81.L
00002200  4512      
00002202  4E92      3704          jsr       (A2)
00002204  584F      3705          addq.w    #4,A7
                    3706   ; return;
00002206  6000 008C 3707          bra       SetWatchPoint_11
                    3708   SetWatchPoint_6:
                    3709   ; }
                    3710   ; printf("\r\nWatch Point Address: ");
0000220A  4879 0000 3711          pea       @m68kde~1_82.L
0000220E  452E      
00002210  4E92      3712          jsr       (A2)
00002212  584F      3713          addq.w    #4,A7
                    3714   ; WPAddress = Get8HexDigits(0);
00002214  42A7      3715          clr.l     -(A7)
00002216  4EB8 0CA4 3716          jsr       _Get8HexDigits
0000221A  584F      3717          addq.w    #4,A7
0000221C  2600      3718          move.l    D0,D3
                    3719   ; // search for first free wp or existing same wp
                    3720   ; for (i = 0; i < 8; i++) {
0000221E  4282      3721          clr.l     D2
                    3722   SetWatchPoint_9:
00002220  0C82 0000 3723          cmp.l     #8,D2
00002224  0008      
00002226  6C00 006C 3724          bge       SetWatchPoint_11
                    3725   ; if (WatchPointAddress[i] == WPAddress && WPAddress != 0) {     //so we can set a wp at 0
0000222A  2002      3726          move.l    D2,D0
0000222C  E588      3727          lsl.l     #2,D0
0000222E  41F9 0803 3728          lea       _WatchPointAddress.L,A0
00002232  0182      
00002234  B6B0 0800 3729          cmp.l     0(A0,D0.L),D3
00002238  6614      3730          bne.s     SetWatchPoint_12
0000223A  4A83      3731          tst.l     D3
0000223C  6710      3732          beq.s     SetWatchPoint_12
                    3733   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress);
0000223E  2F03      3734          move.l    D3,-(A7)
00002240  4879 0000 3735          pea       @m68kde~1_83.L
00002244  4546      
00002246  4E92      3736          jsr       (A2)
00002248  504F      3737          addq.w    #8,A7
                    3738   ; return;
0000224A  6000 0048 3739          bra       SetWatchPoint_11
                    3740   SetWatchPoint_12:
                    3741   ; }
                    3742   ; if (WatchPointSetOrCleared[i] == 0) {
0000224E  2002      3743          move.l    D2,D0
00002250  E588      3744          lsl.l     #2,D0
00002252  2033 0800 3745          move.l    0(A3,D0.L),D0
00002256  6600 0038 3746          bne       SetWatchPoint_14
                    3747   ; WatchPointSetOrCleared[i] = 1;                                 // mark this watchpoint as set
0000225A  2002      3748          move.l    D2,D0
0000225C  E588      3749          lsl.l     #2,D0
0000225E  27BC 0000 3750          move.l    #1,0(A3,D0.L)
00002262  0001 0800 
                    3751   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress);
00002266  2F03      3752          move.l    D3,-(A7)
00002268  4879 0000 3753          pea       @m68kde~1_84.L
0000226C  457C      
0000226E  4E92      3754          jsr       (A2)
00002270  504F      3755          addq.w    #8,A7
                    3756   ; WatchPointAddress[i] = WPAddress;                              // record the address of this watch point in the debugger
00002272  2002      3757          move.l    D2,D0
00002274  E588      3758          lsl.l     #2,D0
00002276  41F9 0803 3759          lea       _WatchPointAddress.L,A0
0000227A  0182      
0000227C  2183 0800 3760          move.l    D3,0(A0,D0.L)
                    3761   ; printf("\r\n");
00002280  4879 0000 3762          pea       @m68kde~1_1.L
00002284  3D08      
00002286  4E92      3763          jsr       (A2)
00002288  584F      3764          addq.w    #4,A7
                    3765   ; WatchPointDisplay();       // display the break points
0000228A  4EB8 1D4A 3766          jsr       _WatchPointDisplay
                    3767   ; return;
0000228E  6004      3768          bra.s     SetWatchPoint_11
                    3769   SetWatchPoint_14:
00002290  5282      3770          addq.l    #1,D2
00002292  608C      3771          bra       SetWatchPoint_9
                    3772   SetWatchPoint_11:
00002294  4CDF 0C0C 3773          movem.l   (A7)+,D2/D3/A2/A3
00002298  4E5E      3774          unlk      A6
0000229A  4E75      3775          rts
                    3776   ; }
                    3777   ; }
                    3778   ; }
                    3779   ; void HandleBreakPoint(void)
                    3780   ; {
                    3781   _HandleBreakPoint:
0000229C  4E56 FFFC 3782          link      A6,#-4
000022A0  48E7 0038 3783          movem.l   A2/A3/A4,-(A7)
000022A4  45F9 0803 3784          lea       _i.L,A2
000022A8  00C4      
000022AA  47F9 0000 3785          lea       _printf.L,A3
000022AE  33B8      
000022B0  49F9 0803 3786          lea       _PC.L,A4
000022B4  0120      
                    3787   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3788   ; // now we have to put the break point back to run the instruction
                    3789   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3790   ; PC = PC - 2;  // ready for user to resume after reaching breakpoint
000022B6  5594      3791          subq.l    #2,(A4)
                    3792   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT");
000022B8  4879 0000 3793          pea       @m68kde~1_85.L
000022BC  45A2      
000022BE  4E93      3794          jsr       (A3)
000022C0  584F      3795          addq.w    #4,A7
                    3796   ; printf("\r\nSingle Step : [ON]");
000022C2  4879 0000 3797          pea       @m68kde~1_86.L
000022C6  45B6      
000022C8  4E93      3798          jsr       (A3)
000022CA  584F      3799          addq.w    #4,A7
                    3800   ; printf("\r\nBreakPoints : [Enabled]");
000022CC  4879 0000 3801          pea       @m68kde~1_87.L
000022D0  45CC      
000022D2  4E93      3802          jsr       (A3)
000022D4  584F      3803          addq.w    #4,A7
                    3804   ; // now clear the break point (put original instruction back)
                    3805   ; ProgramBreakPointAddress = PC;
000022D6  2D54 FFFC 3806          move.l    (A4),-4(A6)
                    3807   ; for (i = 0; i < 8; i++) {
000022DA  4292      3808          clr.l     (A2)
                    3809   HandleBreakPoint_1:
000022DC  2012      3810          move.l    (A2),D0
000022DE  0C80 0000 3811          cmp.l     #8,D0
000022E2  0008      
000022E4  6400 0056 3812          bhs       HandleBreakPoint_3
                    3813   ; if (BreakPointAddress[i] == PC) {        // if we have found the breakpoint
000022E8  2012      3814          move.l    (A2),D0
000022EA  E588      3815          lsl.l     #2,D0
000022EC  41F9 0803 3816          lea       _BreakPointAddress.L,A0
000022F0  012E      
000022F2  2230 0800 3817          move.l    0(A0,D0.L),D1
000022F6  B294      3818          cmp.l     (A4),D1
000022F8  6600 003E 3819          bne       HandleBreakPoint_4
                    3820   ; BreakPointAddress[i] = 0;
000022FC  2012      3821          move.l    (A2),D0
000022FE  E588      3822          lsl.l     #2,D0
00002300  41F9 0803 3823          lea       _BreakPointAddress.L,A0
00002304  012E      
00002306  42B0 0800 3824          clr.l     0(A0,D0.L)
                    3825   ; BreakPointSetOrCleared[i] = 0;
0000230A  2012      3826          move.l    (A2),D0
0000230C  E588      3827          lsl.l     #2,D0
0000230E  41F9 0803 3828          lea       _BreakPointSetOrCleared.L,A0
00002312  015E      
00002314  42B0 0800 3829          clr.l     0(A0,D0.L)
                    3830   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
00002318  2012      3831          move.l    (A2),D0
0000231A  E388      3832          lsl.l     #1,D0
0000231C  41F9 0803 3833          lea       _BreakPointInstruction.L,A0
00002320  014E      
00002322  226E FFFC 3834          move.l    -4(A6),A1
00002326  32B0 0800 3835          move.w    0(A0,D0.L),(A1)
                    3836   ; BreakPointInstruction[i] = 0;
0000232A  2012      3837          move.l    (A2),D0
0000232C  E388      3838          lsl.l     #1,D0
0000232E  41F9 0803 3839          lea       _BreakPointInstruction.L,A0
00002332  014E      
00002334  4270 0800 3840          clr.w     0(A0,D0.L)
                    3841   HandleBreakPoint_4:
00002338  5292      3842          addq.l    #1,(A2)
0000233A  60A0      3843          bra       HandleBreakPoint_1
                    3844   HandleBreakPoint_3:
                    3845   ; }
                    3846   ; }
                    3847   ; DumpRegisters();
0000233C  4EB8 14C8 3848          jsr       _DumpRegisters
                    3849   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002340  4879 0000 3850          pea       @m68kde~1_49.L
00002344  4148      
00002346  4E93      3851          jsr       (A3)
00002348  584F      3852          addq.w    #4,A7
                    3853   ; printf("\r\nPress <ESC> to Resume User Program\r\n");
0000234A  4879 0000 3854          pea       @m68kde~1_88.L
0000234E  45E6      
00002350  4E93      3855          jsr       (A3)
00002352  584F      3856          addq.w    #4,A7
                    3857   ; menu();
00002354  4EB9 0000 3858          jsr       _menu
00002358  2560      
0000235A  4CDF 1C00 3859          movem.l   (A7)+,A2/A3/A4
0000235E  4E5E      3860          unlk      A6
00002360  4E75      3861          rts
                    3862   ; }
                    3863   ; void UnknownCommand()
                    3864   ; {
                    3865   _UnknownCommand:
                    3866   ; printf("\r\nUnknown Command.....\r\n");
00002362  4879 0000 3867          pea       @m68kde~1_89.L
00002366  460E      
00002368  4EB9 0000 3868          jsr       _printf
0000236C  33B8      
0000236E  584F      3869          addq.w    #4,A7
                    3870   ; Help();
00002370  4EB9 0000 3871          jsr       _Help
00002374  2486      
00002376  4E75      3872          rts
                    3873   ; }
                    3874   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3875   ; void CallDebugMonitor(void)
                    3876   ; {
                    3877   _CallDebugMonitor:
                    3878   ; printf("\r\nProgram Ended (TRAP #15)....");
00002378  4879 0000 3879          pea       @m68kde~1_90.L
0000237C  4628      
0000237E  4EB9 0000 3880          jsr       _printf
00002382  33B8      
00002384  584F      3881          addq.w    #4,A7
                    3882   ; menu();
00002386  4EB9 0000 3883          jsr       _menu
0000238A  2560      
0000238C  4E75      3884          rts
                    3885   ; }
                    3886   ; void Breakpoint(void)
                    3887   ; {
                    3888   _Breakpoint:
0000238E  2F02      3889          move.l    D2,-(A7)
                    3890   ; char c;
                    3891   ; c = toupper(_getch());
00002390  2F00      3892          move.l    D0,-(A7)
00002392  4EB8 0B68 3893          jsr       __getch
00002396  2200      3894          move.l    D0,D1
00002398  201F      3895          move.l    (A7)+,D0
0000239A  2F01      3896          move.l    D1,-(A7)
0000239C  4EB9 0000 3897          jsr       _toupper
000023A0  338C      
000023A2  584F      3898          addq.w    #4,A7
000023A4  1400      3899          move.b    D0,D2
                    3900   ; if (c == (char)('D'))                                      // BreakPoint Display
000023A6  0C02 0044 3901          cmp.b     #68,D2
000023AA  6608      3902          bne.s     Breakpoint_1
                    3903   ; BreakPointDisplay();
000023AC  4EB8 1C76 3904          jsr       _BreakPointDisplay
000023B0  6000 0054 3905          bra       Breakpoint_10
                    3906   Breakpoint_1:
                    3907   ; else if (c == (char)('K')) {                                 // breakpoint Kill
000023B4  0C02 004B 3908          cmp.b     #75,D2
000023B8  6630      3909          bne.s     Breakpoint_3
                    3910   ; printf("\r\nKill All Break Points...(y/n)?");
000023BA  4879 0000 3911          pea       @m68kde~1_91.L
000023BE  4648      
000023C0  4EB9 0000 3912          jsr       _printf
000023C4  33B8      
000023C6  584F      3913          addq.w    #4,A7
                    3914   ; c = toupper(_getch());
000023C8  2F00      3915          move.l    D0,-(A7)
000023CA  4EB8 0B68 3916          jsr       __getch
000023CE  2200      3917          move.l    D0,D1
000023D0  201F      3918          move.l    (A7)+,D0
000023D2  2F01      3919          move.l    D1,-(A7)
000023D4  4EB9 0000 3920          jsr       _toupper
000023D8  338C      
000023DA  584F      3921          addq.w    #4,A7
000023DC  1400      3922          move.b    D0,D2
                    3923   ; if (c == (char)('Y'))
000023DE  0C02 0059 3924          cmp.b     #89,D2
000023E2  6604      3925          bne.s     Breakpoint_5
                    3926   ; KillAllBreakPoints();
000023E4  4EB8 200E 3927          jsr       _KillAllBreakPoints
                    3928   Breakpoint_5:
000023E8  601C      3929          bra.s     Breakpoint_10
                    3930   Breakpoint_3:
                    3931   ; }
                    3932   ; else if (c == (char)('S')) {
000023EA  0C02 0053 3933          cmp.b     #83,D2
000023EE  6606      3934          bne.s     Breakpoint_7
                    3935   ; SetBreakPoint();
000023F0  4EB8 20A6 3936          jsr       _SetBreakPoint
000023F4  6010      3937          bra.s     Breakpoint_10
                    3938   Breakpoint_7:
                    3939   ; }
                    3940   ; else if (c == (char)('C')) {
000023F6  0C02 0043 3941          cmp.b     #67,D2
000023FA  6606      3942          bne.s     Breakpoint_9
                    3943   ; BreakPointClear();
000023FC  4EB8 1DF6 3944          jsr       _BreakPointClear
00002400  6004      3945          bra.s     Breakpoint_10
                    3946   Breakpoint_9:
                    3947   ; }
                    3948   ; else
                    3949   ; UnknownCommand();
00002402  4EB8 2362 3950          jsr       _UnknownCommand
                    3951   Breakpoint_10:
00002406  241F      3952          move.l    (A7)+,D2
00002408  4E75      3953          rts
                    3954   ; }
                    3955   ; void Watchpoint(void)
                    3956   ; {
                    3957   _Watchpoint:
0000240A  2F02      3958          move.l    D2,-(A7)
                    3959   ; char c;
                    3960   ; c = toupper(_getch());
0000240C  2F00      3961          move.l    D0,-(A7)
0000240E  4EB8 0B68 3962          jsr       __getch
00002412  2200      3963          move.l    D0,D1
00002414  201F      3964          move.l    (A7)+,D0
00002416  2F01      3965          move.l    D1,-(A7)
00002418  4EB9 0000 3966          jsr       _toupper
0000241C  338C      
0000241E  584F      3967          addq.w    #4,A7
00002420  1400      3968          move.b    D0,D2
                    3969   ; if (c == (char)('D'))                                      // WatchPoint Display
00002422  0C02 0044 3970          cmp.b     #68,D2
00002426  6608      3971          bne.s     Watchpoint_1
                    3972   ; WatchPointDisplay();
00002428  4EB8 1D4A 3973          jsr       _WatchPointDisplay
0000242C  6000 0054 3974          bra       Watchpoint_10
                    3975   Watchpoint_1:
                    3976   ; else if (c == (char)('K')) {                                 // wtahcpoint Kill
00002430  0C02 004B 3977          cmp.b     #75,D2
00002434  6630      3978          bne.s     Watchpoint_3
                    3979   ; printf("\r\nKill All Watch Points...(y/n)?");
00002436  4879 0000 3980          pea       @m68kde~1_92.L
0000243A  466A      
0000243C  4EB9 0000 3981          jsr       _printf
00002440  33B8      
00002442  584F      3982          addq.w    #4,A7
                    3983   ; c = toupper(_getch());
00002444  2F00      3984          move.l    D0,-(A7)
00002446  4EB8 0B68 3985          jsr       __getch
0000244A  2200      3986          move.l    D0,D1
0000244C  201F      3987          move.l    (A7)+,D0
0000244E  2F01      3988          move.l    D1,-(A7)
00002450  4EB9 0000 3989          jsr       _toupper
00002454  338C      
00002456  584F      3990          addq.w    #4,A7
00002458  1400      3991          move.b    D0,D2
                    3992   ; if (c == (char)('Y'))
0000245A  0C02 0059 3993          cmp.b     #89,D2
0000245E  6604      3994          bne.s     Watchpoint_5
                    3995   ; KillAllWatchPoints();
00002460  4EB8 2076 3996          jsr       _KillAllWatchPoints
                    3997   Watchpoint_5:
00002464  601C      3998          bra.s     Watchpoint_10
                    3999   Watchpoint_3:
                    4000   ; }
                    4001   ; else if (c == (char)('S')) {
00002466  0C02 0053 4002          cmp.b     #83,D2
0000246A  6606      4003          bne.s     Watchpoint_7
                    4004   ; SetWatchPoint();
0000246C  4EB8 21C6 4005          jsr       _SetWatchPoint
00002470  6010      4006          bra.s     Watchpoint_10
                    4007   Watchpoint_7:
                    4008   ; }
                    4009   ; else if (c == (char)('C')) {
00002472  0C02 0043 4010          cmp.b     #67,D2
00002476  6606      4011          bne.s     Watchpoint_9
                    4012   ; WatchPointClear();
00002478  4EB8 1ED0 4013          jsr       _WatchPointClear
0000247C  6004      4014          bra.s     Watchpoint_10
                    4015   Watchpoint_9:
                    4016   ; }
                    4017   ; else
                    4018   ; UnknownCommand();
0000247E  4EB8 2362 4019          jsr       _UnknownCommand
                    4020   Watchpoint_10:
00002482  241F      4021          move.l    (A7)+,D2
00002484  4E75      4022          rts
                    4023   ; }
                    4024   ; void Help(void)
                    4025   ; {
                    4026   _Help:
00002486  48E7 2020 4027          movem.l   D2/A2,-(A7)
0000248A  45F9 0000 4028          lea       _printf.L,A2
0000248E  33B8      
                    4029   ; char* banner = "\r\n----------------------------------------------------------------";
00002490  41F9 0000 4030          lea       @m68kde~1_93.L,A0
00002494  468C      
00002496  2408      4031          move.l    A0,D2
                    4032   ; printf(banner);
00002498  2F02      4033          move.l    D2,-(A7)
0000249A  4E92      4034          jsr       (A2)
0000249C  584F      4035          addq.w    #4,A7
                    4036   ; printf("\r\n  Debugger Command Summary");
0000249E  4879 0000 4037          pea       @m68kde~1_94.L
000024A2  46D0      
000024A4  4E92      4038          jsr       (A2)
000024A6  584F      4039          addq.w    #4,A7
                    4040   ; printf(banner);
000024A8  2F02      4041          move.l    D2,-(A7)
000024AA  4E92      4042          jsr       (A2)
000024AC  584F      4043          addq.w    #4,A7
                    4044   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
000024AE  4879 0000 4045          pea       @m68kde~1_95.L
000024B2  46EE      
000024B4  4E92      4046          jsr       (A2)
000024B6  584F      4047          addq.w    #4,A7
                    4048   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill");
000024B8  4879 0000 4049          pea       @m68kde~1_96.L
000024BC  4732      
000024BE  4E92      4050          jsr       (A2)
000024C0  584F      4051          addq.w    #4,A7
                    4052   ; printf("\r\n  C            - Copy Program from Flash to Main Memory");
000024C2  4879 0000 4053          pea       @m68kde~1_97.L
000024C6  476A      
000024C8  4E92      4054          jsr       (A2)
000024CA  584F      4055          addq.w    #4,A7
                    4056   ; printf("\r\n  D            - Dump Memory Contents to Screen");
000024CC  4879 0000 4057          pea       @m68kde~1_98.L
000024D0  47A4      
000024D2  4E92      4058          jsr       (A2)
000024D4  584F      4059          addq.w    #4,A7
                    4060   ; printf("\r\n  E            - Enter String into Memory");
000024D6  4879 0000 4061          pea       @m68kde~1_99.L
000024DA  47D6      
000024DC  4E92      4062          jsr       (A2)
000024DE  584F      4063          addq.w    #4,A7
                    4064   ; printf("\r\n  F            - Fill Memory with Data");
000024E0  4879 0000 4065          pea       @m68kde~1_100.L
000024E4  4802      
000024E6  4E92      4066          jsr       (A2)
000024E8  584F      4067          addq.w    #4,A7
                    4068   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC);
000024EA  2F39 0803 4069          move.l    _PC.L,-(A7)
000024EE  0120      
000024F0  4879 0000 4070          pea       @m68kde~1_101.L
000024F4  482C      
000024F6  4E92      4071          jsr       (A2)
000024F8  504F      4072          addq.w    #8,A7
                    4073   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop");
000024FA  4879 0000 4074          pea       @m68kde~1_102.L
000024FE  4866      
00002500  4E92      4075          jsr       (A2)
00002502  584F      4076          addq.w    #4,A7
                    4077   ; printf("\r\n  M            - Memory Examine and Change");
00002504  4879 0000 4078          pea       @m68kde~1_103.L
00002508  489E      
0000250A  4E92      4079          jsr       (A2)
0000250C  584F      4080          addq.w    #4,A7
                    4081   ; printf("\r\n  P            - Program Flash Memory with User Program");
0000250E  4879 0000 4082          pea       @m68kde~1_104.L
00002512  48CC      
00002514  4E92      4083          jsr       (A2)
00002516  584F      4084          addq.w    #4,A7
                    4085   ; printf("\r\n  R            - Display 68000 Registers");
00002518  4879 0000 4086          pea       @m68kde~1_105.L
0000251C  4906      
0000251E  4E92      4087          jsr       (A2)
00002520  584F      4088          addq.w    #4,A7
                    4089   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode");
00002522  4879 0000 4090          pea       @m68kde~1_106.L
00002526  4932      
00002528  4E92      4091          jsr       (A2)
0000252A  584F      4092          addq.w    #4,A7
                    4093   ; printf("\r\n  TM           - Test Memory");
0000252C  4879 0000 4094          pea       @m68kde~1_107.L
00002530  4964      
00002532  4E92      4095          jsr       (A2)
00002534  584F      4096          addq.w    #4,A7
                    4097   ; printf("\r\n  TS           - Test Switches: SW7-0");
00002536  4879 0000 4098          pea       @m68kde~1_108.L
0000253A  4984      
0000253C  4E92      4099          jsr       (A2)
0000253E  584F      4100          addq.w    #4,A7
                    4101   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment");
00002540  4879 0000 4102          pea       @m68kde~1_109.L
00002544  49AC      
00002546  4E92      4103          jsr       (A2)
00002548  584F      4104          addq.w    #4,A7
                    4105   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill");
0000254A  4879 0000 4106          pea       @m68kde~1_110.L
0000254E  49E2      
00002550  4E92      4107          jsr       (A2)
00002552  584F      4108          addq.w    #4,A7
                    4109   ; printf(banner);
00002554  2F02      4110          move.l    D2,-(A7)
00002556  4E92      4111          jsr       (A2)
00002558  584F      4112          addq.w    #4,A7
0000255A  4CDF 0404 4113          movem.l   (A7)+,D2/A2
0000255E  4E75      4114          rts
                    4115   ; }
                    4116   ; void menu(void)
                    4117   ; {
                    4118   _menu:
00002560  48E7 303C 4119          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002564  45F9 0000 4120          lea       _printf.L,A2
00002568  33B8      
0000256A  47F9 0803 4121          lea       _Trace.L,A3
0000256E  00D8      
00002570  49F9 0803 4122          lea       _x.L,A4
00002574  00C8      
00002576  4BF9 0803 4123          lea       _SR.L,A5
0000257A  012C      
                    4124   ; char c, c1;
                    4125   ; while (1) {
                    4126   menu_1:
                    4127   ; FlushKeyboard();               // dump unread characters from keyboard
0000257C  4EB8 0BA6 4128          jsr       _FlushKeyboard
                    4129   ; printf("\r\n#");
00002580  4879 0000 4130          pea       @m68kde~1_111.L
00002584  4A1A      
00002586  4E92      4131          jsr       (A2)
00002588  584F      4132          addq.w    #4,A7
                    4133   ; c = toupper(_getch());
0000258A  2F00      4134          move.l    D0,-(A7)
0000258C  4EB8 0B68 4135          jsr       __getch
00002590  2200      4136          move.l    D0,D1
00002592  201F      4137          move.l    (A7)+,D0
00002594  2F01      4138          move.l    D1,-(A7)
00002596  4EB9 0000 4139          jsr       _toupper
0000259A  338C      
0000259C  584F      4140          addq.w    #4,A7
0000259E  1400      4141          move.b    D0,D2
                    4142   ; if (c == (char)('L'))                  // load s record file
000025A0  0C02 004C 4143          cmp.b     #76,D2
000025A4  6608      4144          bne.s     menu_4
                    4145   ; Load_SRecordFile();
000025A6  4EB8 0E36 4146          jsr       _Load_SRecordFile
000025AA  6000 021E 4147          bra       menu_46
                    4148   menu_4:
                    4149   ; else if (c == (char)('D'))             // dump memory
000025AE  0C02 0044 4150          cmp.b     #68,D2
000025B2  6608      4151          bne.s     menu_6
                    4152   ; DumpMemory();
000025B4  4EB8 0CCC 4153          jsr       _DumpMemory
000025B8  6000 0210 4154          bra       menu_46
                    4155   menu_6:
                    4156   ; else if (c == (char)('E'))             // Enter String into memory
000025BC  0C02 0045 4157          cmp.b     #69,D2
000025C0  660A      4158          bne.s     menu_8
                    4159   ; EnterString();
000025C2  4EB9 0000 4160          jsr       _EnterString
000025C6  2912      
000025C8  6000 0200 4161          bra       menu_46
                    4162   menu_8:
                    4163   ; else if (c == (char)('F'))             // fill memory
000025CC  0C02 0046 4164          cmp.b     #70,D2
000025D0  6608      4165          bne.s     menu_10
                    4166   ; FillMemory();
000025D2  4EB8 0DBC 4167          jsr       _FillMemory
000025D6  6000 01F2 4168          bra       menu_46
                    4169   menu_10:
                    4170   ; else if (c == (char)('G')) {           // go user program
000025DA  0C02 0047 4171          cmp.b     #71,D2
000025DE  6626      4172          bne.s     menu_12
                    4173   ; printf("\r\nProgram Running.....");
000025E0  4879 0000 4174          pea       @m68kde~1_112.L
000025E4  4A1E      
000025E6  4E92      4175          jsr       (A2)
000025E8  584F      4176          addq.w    #4,A7
                    4177   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
000025EA  4879 0000 4178          pea       @m68kde~1_113.L
000025EE  4A36      
000025F0  4E92      4179          jsr       (A2)
000025F2  584F      4180          addq.w    #4,A7
                    4181   ; GoFlag = 1;
000025F4  23FC 0000 4182          move.l    #1,_GoFlag.L
000025F8  0001 0803 
000025FC  00DC      
                    4183   ; go();
000025FE  4EB8 08B8 4184          jsr       _go
00002602  6000 01C6 4185          bra       menu_46
                    4186   menu_12:
                    4187   ; }
                    4188   ; else if (c == (char)('M'))           // memory examine and modify
00002606  0C02 004D 4189          cmp.b     #77,D2
0000260A  6608      4190          bne.s     menu_14
                    4191   ; MemoryChange();
0000260C  4EB8 0FC4 4192          jsr       _MemoryChange
00002610  6000 01B8 4193          bra       menu_46
                    4194   menu_14:
                    4195   ; else if (c == (char)('P'))            // Program Flash Chip
00002614  0C02 0050 4196          cmp.b     #80,D2
00002618  6608      4197          bne.s     menu_16
                    4198   ; ProgramFlashChip();
0000261A  4EB8 1366 4199          jsr       _ProgramFlashChip
0000261E  6000 01AA 4200          bra       menu_46
                    4201   menu_16:
                    4202   ; else if (c == (char)('C'))             // copy flash chip to ram and go
00002622  0C02 0043 4203          cmp.b     #67,D2
00002626  6608      4204          bne.s     menu_18
                    4205   ; LoadFromFlashChip();
00002628  4EB8 1440 4206          jsr       _LoadFromFlashChip
0000262C  6000 019C 4207          bra       menu_46
                    4208   menu_18:
                    4209   ; else if (c == (char)('R'))             // dump registers
00002630  0C02 0052 4210          cmp.b     #82,D2
00002634  6608      4211          bne.s     menu_20
                    4212   ; DumpRegisters();
00002636  4EB8 14C8 4213          jsr       _DumpRegisters
0000263A  6000 018E 4214          bra       menu_46
                    4215   menu_20:
                    4216   ; else if (c == (char)('.'))           // change registers
0000263E  0C02 002E 4217          cmp.b     #46,D2
00002642  6608      4218          bne.s     menu_22
                    4219   ; ChangeRegisters();
00002644  4EB8 19BA 4220          jsr       _ChangeRegisters
00002648  6000 0180 4221          bra       menu_46
                    4222   menu_22:
                    4223   ; else if (c == (char)('B'))              // breakpoint command
0000264C  0C02 0042 4224          cmp.b     #66,D2
00002650  6608      4225          bne.s     menu_24
                    4226   ; Breakpoint();
00002652  4EB8 238E 4227          jsr       _Breakpoint
00002656  6000 0172 4228          bra       menu_46
                    4229   menu_24:
                    4230   ; else if (c == (char)('T')) {          // Test command
0000265A  0C02 0054 4231          cmp.b     #84,D2
0000265E  6600 0046 4232          bne       menu_26
                    4233   ; c1 = toupper(_getch());
00002662  2F00      4234          move.l    D0,-(A7)
00002664  4EB8 0B68 4235          jsr       __getch
00002668  2200      4236          move.l    D0,D1
0000266A  201F      4237          move.l    (A7)+,D0
0000266C  2F01      4238          move.l    D1,-(A7)
0000266E  4EB9 0000 4239          jsr       _toupper
00002672  338C      
00002674  584F      4240          addq.w    #4,A7
00002676  1600      4241          move.b    D0,D3
                    4242   ; if (c1 == (char)('M'))                    // memory test
00002678  0C03 004D 4243          cmp.b     #77,D3
0000267C  6608      4244          bne.s     menu_28
                    4245   ; MemoryTest();
0000267E  4EB9 0000 4246          jsr       _MemoryTest
00002682  2962      
00002684  601C      4247          bra.s     menu_33
                    4248   menu_28:
                    4249   ; else if (c1 == (char)('S'))              // Switch Test command
00002686  0C03 0053 4250          cmp.b     #83,D3
0000268A  6606      4251          bne.s     menu_30
                    4252   ; SwitchTest();
0000268C  4EB8 0AA4 4253          jsr       _SwitchTest
00002690  6010      4254          bra.s     menu_33
                    4255   menu_30:
                    4256   ; else if (c1 == (char)('D'))              // display Test command
00002692  0C03 0044 4257          cmp.b     #68,D3
00002696  6606      4258          bne.s     menu_32
                    4259   ; TestLEDS();
00002698  4EB8 0A50 4260          jsr       _TestLEDS
0000269C  6004      4261          bra.s     menu_33
                    4262   menu_32:
                    4263   ; else
                    4264   ; UnknownCommand();
0000269E  4EB8 2362 4265          jsr       _UnknownCommand
                    4266   menu_33:
000026A2  6000 0126 4267          bra       menu_46
                    4268   menu_26:
                    4269   ; }
                    4270   ; else if (c == (char)(' ')) {             // Next instruction command
000026A6  0C02 0020 4271          cmp.b     #32,D2
000026AA  6636      4272          bne.s     menu_34
                    4273   ; DisableBreakPoints();
000026AC  4EB8 1F72 4274          jsr       _DisableBreakPoints
                    4275   ; if (Trace == 1 && GoFlag == 1) {    // if the program is running and trace mode on then 'N' is valid
000026B0  2013      4276          move.l    (A3),D0
000026B2  0C80 0000 4277          cmp.l     #1,D0
000026B6  0001      
000026B8  661A      4278          bne.s     menu_36
000026BA  2039 0803 4279          move.l    _GoFlag.L,D0
000026BE  00DC      
000026C0  0C80 0000 4280          cmp.l     #1,D0
000026C4  0001      
000026C6  660C      4281          bne.s     menu_36
                    4282   ; TraceException = 1;             // generate a trace exception for the next instruction if user wants to single step though next instruction
000026C8  13FC 0001 4283          move.b    #1,4194314
000026CC  0040 000A 
                    4284   ; return;
000026D0  6000 00FC 4285          bra       menu_38
                    4286   menu_36:
                    4287   ; }
                    4288   ; else
                    4289   ; printf("\r\nError: Press 'G' first to start program");
000026D4  4879 0000 4290          pea       @m68kde~1_114.L
000026D8  4A64      
000026DA  4E92      4291          jsr       (A2)
000026DC  584F      4292          addq.w    #4,A7
000026DE  6000 00EA 4293          bra       menu_46
                    4294   menu_34:
                    4295   ; }
                    4296   ; else if (c == (char)('S')) {             // single step
000026E2  0C02 0053 4297          cmp.b     #83,D2
000026E6  6600 008C 4298          bne       menu_39
                    4299   ; if (Trace == 0) {
000026EA  2013      4300          move.l    (A3),D0
000026EC  6600 0050 4301          bne       menu_41
                    4302   ; DisableBreakPoints();
000026F0  4EB8 1F72 4303          jsr       _DisableBreakPoints
                    4304   ; printf("\r\nSingle Step  :[ON]");
000026F4  4879 0000 4305          pea       @m68kde~1_115.L
000026F8  4A8E      
000026FA  4E92      4306          jsr       (A2)
000026FC  584F      4307          addq.w    #4,A7
                    4308   ; printf("\r\nBreak Points :[Disabled]");
000026FE  4879 0000 4309          pea       @m68kde~1_48.L
00002702  412C      
00002704  4E92      4310          jsr       (A2)
00002706  584F      4311          addq.w    #4,A7
                    4312   ; SR = SR | (unsigned short int)(0x8000);    // set T bit in status register
00002708  0055 8000 4313          or.w      #32768,(A5)
                    4314   ; printf("\r\nPress 'G' to Trace Program from address $%X.....", PC);
0000270C  2F39 0803 4315          move.l    _PC.L,-(A7)
00002710  0120      
00002712  4879 0000 4316          pea       @m68kde~1_116.L
00002716  4AA4      
00002718  4E92      4317          jsr       (A2)
0000271A  504F      4318          addq.w    #8,A7
                    4319   ; printf("\r\nPush <RESET Button> to Stop.....");
0000271C  4879 0000 4320          pea       @m68kde~1_117.L
00002720  4AD8      
00002722  4E92      4321          jsr       (A2)
00002724  584F      4322          addq.w    #4,A7
                    4323   ; DumpRegisters();
00002726  4EB8 14C8 4324          jsr       _DumpRegisters
                    4325   ; Trace = 1;
0000272A  26BC 0000 4326          move.l    #1,(A3)
0000272E  0001      
                    4327   ; TraceException = 1;
00002730  13FC 0001 4328          move.b    #1,4194314
00002734  0040 000A 
                    4329   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002738  28B8 0074 4330          move.l    116,(A4)
0000273C  6032      4331          bra.s     menu_42
                    4332   menu_41:
                    4333   ; }
                    4334   ; else {
                    4335   ; Trace = 0;
0000273E  4293      4336          clr.l     (A3)
                    4337   ; TraceException = 0;
00002740  4239 0040 4338          clr.b     4194314
00002744  000A      
                    4339   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002746  28B8 0074 4340          move.l    116,(A4)
                    4341   ; EnableBreakPoints();
0000274A  4EB8 1FC6 4342          jsr       _EnableBreakPoints
                    4343   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000274E  0255 7FFF 4344          and.w     #32767,(A5)
                    4345   ; printf("\r\nSingle Step : [OFF]");
00002752  4879 0000 4346          pea       @m68kde~1_118.L
00002756  4AFC      
00002758  4E92      4347          jsr       (A2)
0000275A  584F      4348          addq.w    #4,A7
                    4349   ; printf("\r\nBreak Points :[Enabled]");
0000275C  4879 0000 4350          pea       @m68kde~1_119.L
00002760  4B12      
00002762  4E92      4351          jsr       (A2)
00002764  584F      4352          addq.w    #4,A7
                    4353   ; printf("\r\nPress <ESC> to Resume User Program.....");
00002766  4879 0000 4354          pea       @m68kde~1_120.L
0000276A  4B2C      
0000276C  4E92      4355          jsr       (A2)
0000276E  584F      4356          addq.w    #4,A7
                    4357   menu_42:
00002770  6000 0058 4358          bra       menu_46
                    4359   menu_39:
                    4360   ; }
                    4361   ; }
                    4362   ; else if (c == (char)(0x1b)) {   // if user choses to end trace and run program
00002774  0C02 001B 4363          cmp.b     #27,D2
00002778  6600 0040 4364          bne       menu_43
                    4365   ; Trace = 0;
0000277C  4293      4366          clr.l     (A3)
                    4367   ; TraceException = 0;
0000277E  4239 0040 4368          clr.b     4194314
00002782  000A      
                    4369   ; x = *(unsigned int*)(0x00000074);   // read IRQ 5 vector to reset trace vector generator
00002784  28B8 0074 4370          move.l    116,(A4)
                    4371   ; EnableBreakPoints();
00002788  4EB8 1FC6 4372          jsr       _EnableBreakPoints
                    4373   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000278C  0255 7FFF 4374          and.w     #32767,(A5)
                    4375   ; printf("\r\nSingle Step  :[OFF]");
00002790  4879 0000 4376          pea       @m68kde~1_121.L
00002794  4B56      
00002796  4E92      4377          jsr       (A2)
00002798  584F      4378          addq.w    #4,A7
                    4379   ; printf("\r\nBreak Points :[Enabled]");
0000279A  4879 0000 4380          pea       @m68kde~1_119.L
0000279E  4B12      
000027A0  4E92      4381          jsr       (A2)
000027A2  584F      4382          addq.w    #4,A7
                    4383   ; printf("\r\nProgram Running.....");
000027A4  4879 0000 4384          pea       @m68kde~1_112.L
000027A8  4A1E      
000027AA  4E92      4385          jsr       (A2)
000027AC  584F      4386          addq.w    #4,A7
                    4387   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
000027AE  4879 0000 4388          pea       @m68kde~1_113.L
000027B2  4A36      
000027B4  4E92      4389          jsr       (A2)
000027B6  584F      4390          addq.w    #4,A7
                    4391   ; return;
000027B8  6014      4392          bra.s     menu_38
                    4393   menu_43:
                    4394   ; }
                    4395   ; else if (c == (char)('W'))              // Watchpoint command
000027BA  0C02 0057 4396          cmp.b     #87,D2
000027BE  6606      4397          bne.s     menu_45
                    4398   ; Watchpoint();
000027C0  4EB8 240A 4399          jsr       _Watchpoint
000027C4  6004      4400          bra.s     menu_46
                    4401   menu_45:
                    4402   ; else
                    4403   ; UnknownCommand();
000027C6  4EB8 2362 4404          jsr       _UnknownCommand
                    4405   menu_46:
000027CA  6000 FDB0 4406          bra       menu_1
                    4407   menu_38:
000027CE  4CDF 3C0C 4408          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
000027D2  4E75      4409          rts
                    4410   ; }
                    4411   ; }
                    4412   ; void PrintErrorMessageandAbort(char* string) {
                    4413   _PrintErrorMessageandAbort:
000027D4  4E56 0000 4414          link      A6,#0
                    4415   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n");
000027D8  4879 0000 4416          pea       @m68kde~1_122.L
000027DC  4B6C      
000027DE  4EB9 0000 4417          jsr       _printf
000027E2  33B8      
000027E4  584F      4418          addq.w    #4,A7
                    4419   ; printf("%s\r\n", string);
000027E6  2F2E 0008 4420          move.l    8(A6),-(A7)
000027EA  4879 0000 4421          pea       @m68kde~1_123.L
000027EE  4B88      
000027F0  4EB9 0000 4422          jsr       _printf
000027F4  33B8      
000027F6  504F      4423          addq.w    #8,A7
                    4424   ; menu();
000027F8  4EB8 2560 4425          jsr       _menu
000027FC  4E5E      4426          unlk      A6
000027FE  4E75      4427          rts
                    4428   ; }
                    4429   ; void IRQMessage(int level) {
                    4430   _IRQMessage:
00002800  4E56 0000 4431          link      A6,#0
                    4432   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002804  4879 0000 4433          pea       @m68kde~1_124.L
00002808  4B8E      
0000280A  4EB9 0000 4434          jsr       _printf
0000280E  33B8      
00002810  584F      4435          addq.w    #4,A7
                    4436   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level);
00002812  2F2E 0008 4437          move.l    8(A6),-(A7)
00002816  4879 0000 4438          pea       @m68kde~1_125.L
0000281A  4BA6      
0000281C  4EB9 0000 4439          jsr       _printf
00002820  33B8      
00002822  504F      4440          addq.w    #8,A7
                    4441   ; menu();
00002824  4EB8 2560 4442          jsr       _menu
00002828  4E5E      4443          unlk      A6
0000282A  4E75      4444          rts
                    4445   ; }
                    4446   ; void UnhandledIRQ1(void) {
                    4447   _UnhandledIRQ1:
                    4448   ; IRQMessage(1);
0000282C  4878 0001 4449          pea       1
00002830  4EB8 2800 4450          jsr       _IRQMessage
00002834  584F      4451          addq.w    #4,A7
00002836  4E75      4452          rts
                    4453   ; }
                    4454   ; void UnhandledIRQ2(void) {
                    4455   _UnhandledIRQ2:
                    4456   ; IRQMessage(2);
00002838  4878 0002 4457          pea       2
0000283C  4EB8 2800 4458          jsr       _IRQMessage
00002840  584F      4459          addq.w    #4,A7
00002842  4E75      4460          rts
                    4461   ; }
                    4462   ; void UnhandledIRQ3(void) {
                    4463   _UnhandledIRQ3:
                    4464   ; IRQMessage(3);
00002844  4878 0003 4465          pea       3
00002848  4EB8 2800 4466          jsr       _IRQMessage
0000284C  584F      4467          addq.w    #4,A7
0000284E  4E75      4468          rts
                    4469   ; }
                    4470   ; void UnhandledIRQ4(void) {
                    4471   _UnhandledIRQ4:
                    4472   ; IRQMessage(4);
00002850  4878 0004 4473          pea       4
00002854  4EB8 2800 4474          jsr       _IRQMessage
00002858  584F      4475          addq.w    #4,A7
0000285A  4E75      4476          rts
                    4477   ; }
                    4478   ; void UnhandledIRQ5(void) {
                    4479   _UnhandledIRQ5:
                    4480   ; IRQMessage(5);
0000285C  4878 0005 4481          pea       5
00002860  4EB8 2800 4482          jsr       _IRQMessage
00002864  584F      4483          addq.w    #4,A7
00002866  4E75      4484          rts
                    4485   ; }
                    4486   ; void UnhandledIRQ6(void) {
                    4487   _UnhandledIRQ6:
                    4488   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....");
00002868  4879 0000 4489          pea       @m68kde~1_126.L
0000286C  4BCA      
0000286E  4EB8 27D4 4490          jsr       _PrintErrorMessageandAbort
00002872  584F      4491          addq.w    #4,A7
                    4492   ; menu();
00002874  4EB8 2560 4493          jsr       _menu
00002878  4E75      4494          rts
                    4495   ; }
                    4496   ; void UnhandledIRQ7(void) {
                    4497   _UnhandledIRQ7:
                    4498   ; IRQMessage(7);
0000287A  4878 0007 4499          pea       7
0000287E  4EB8 2800 4500          jsr       _IRQMessage
00002882  584F      4501          addq.w    #4,A7
00002884  4E75      4502          rts
                    4503   ; }
                    4504   ; void UnhandledTrap(void) {
                    4505   _UnhandledTrap:
                    4506   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!");
00002886  4879 0000 4507          pea       @m68kde~1_127.L
0000288A  4C0A      
0000288C  4EB8 27D4 4508          jsr       _PrintErrorMessageandAbort
00002890  584F      4509          addq.w    #4,A7
00002892  4E75      4510          rts
                    4511   ; }
                    4512   ; void BusError() {
                    4513   _BusError:
                    4514   ; PrintErrorMessageandAbort("BUS Error!");
00002894  4879 0000 4515          pea       @m68kde~1_128.L
00002898  4C20      
0000289A  4EB8 27D4 4516          jsr       _PrintErrorMessageandAbort
0000289E  584F      4517          addq.w    #4,A7
000028A0  4E75      4518          rts
                    4519   ; }
                    4520   ; void AddressError() {
                    4521   _AddressError:
                    4522   ; PrintErrorMessageandAbort("ADDRESS Error!");
000028A2  4879 0000 4523          pea       @m68kde~1_129.L
000028A6  4C2C      
000028A8  4EB8 27D4 4524          jsr       _PrintErrorMessageandAbort
000028AC  584F      4525          addq.w    #4,A7
000028AE  4E75      4526          rts
                    4527   ; }
                    4528   ; void IllegalInstruction() {
                    4529   _IllegalInstruction:
                    4530   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION");
000028B0  4879 0000 4531          pea       @m68kde~1_130.L
000028B4  4C3C      
000028B6  4EB8 27D4 4532          jsr       _PrintErrorMessageandAbort
000028BA  584F      4533          addq.w    #4,A7
000028BC  4E75      4534          rts
                    4535   ; }
                    4536   ; void Dividebyzero() {
                    4537   _Dividebyzero:
                    4538   ; PrintErrorMessageandAbort("DIVIDE BY ZERO");
000028BE  4879 0000 4539          pea       @m68kde~1_131.L
000028C2  4C50      
000028C4  4EB8 27D4 4540          jsr       _PrintErrorMessageandAbort
000028C8  584F      4541          addq.w    #4,A7
000028CA  4E75      4542          rts
                    4543   ; }
                    4544   ; void Check() {
                    4545   _Check:
                    4546   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION");
000028CC  4879 0000 4547          pea       @m68kde~1_132.L
000028D0  4C60      
000028D2  4EB8 27D4 4548          jsr       _PrintErrorMessageandAbort
000028D6  584F      4549          addq.w    #4,A7
000028D8  4E75      4550          rts
                    4551   ; }
                    4552   ; void Trapv() {
                    4553   _Trapv:
                    4554   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION");
000028DA  4879 0000 4555          pea       @m68kde~1_133.L
000028DE  4C72      
000028E0  4EB8 27D4 4556          jsr       _PrintErrorMessageandAbort
000028E4  584F      4557          addq.w    #4,A7
000028E6  4E75      4558          rts
                    4559   ; }
                    4560   ; void PrivError() {
                    4561   _PrivError:
                    4562   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION");
000028E8  4879 0000 4563          pea       @m68kde~1_134.L
000028EC  4C84      
000028EE  4EB8 27D4 4564          jsr       _PrintErrorMessageandAbort
000028F2  584F      4565          addq.w    #4,A7
000028F4  4E75      4566          rts
                    4567   ; }
                    4568   ; void UnitIRQ() {
                    4569   _UnitIRQ:
                    4570   ; PrintErrorMessageandAbort("UNINITIALISED IRQ");
000028F6  4879 0000 4571          pea       @m68kde~1_135.L
000028FA  4C98      
000028FC  4EB8 27D4 4572          jsr       _PrintErrorMessageandAbort
00002900  584F      4573          addq.w    #4,A7
00002902  4E75      4574          rts
                    4575   ; }
                    4576   ; void Spurious() {
                    4577   _Spurious:
                    4578   ; PrintErrorMessageandAbort("SPURIOUS IRQ");
00002904  4879 0000 4579          pea       @m68kde~1_136.L
00002908  4CAA      
0000290A  4EB8 27D4 4580          jsr       _PrintErrorMessageandAbort
0000290E  584F      4581          addq.w    #4,A7
00002910  4E75      4582          rts
                    4583   ; }
                    4584   ; void EnterString(void)
                    4585   ; {
                    4586   _EnterString:
00002912  4E56 FFFC 4587          link      A6,#-4
00002916  2F02      4588          move.l    D2,-(A7)
                    4589   ; unsigned char* Start;
                    4590   ; unsigned char c;
                    4591   ; printf("\r\nStart Address in Memory: ");
00002918  4879 0000 4592          pea       @m68kde~1_137.L
0000291C  4CB8      
0000291E  4EB9 0000 4593          jsr       _printf
00002922  33B8      
00002924  584F      4594          addq.w    #4,A7
                    4595   ; Start = Get8HexDigits(0);
00002926  42A7      4596          clr.l     -(A7)
00002928  4EB8 0CA4 4597          jsr       _Get8HexDigits
0000292C  584F      4598          addq.w    #4,A7
0000292E  2400      4599          move.l    D0,D2
                    4600   ; printf("\r\nEnter String (ESC to end) :");
00002930  4879 0000 4601          pea       @m68kde~1_138.L
00002934  4CD4      
00002936  4EB9 0000 4602          jsr       _printf
0000293A  33B8      
0000293C  584F      4603          addq.w    #4,A7
                    4604   ; while ((c = getchar()) != 0x1b)
                    4605   EnterString_1:
0000293E  4EB9 0000 4606          jsr       _getch
00002942  32DA      
00002944  1D40 FFFF 4607          move.b    D0,-1(A6)
00002948  0C00 001B 4608          cmp.b     #27,D0
0000294C  670A      4609          beq.s     EnterString_3
                    4610   ; *Start++ = c;
0000294E  2042      4611          move.l    D2,A0
00002950  5282      4612          addq.l    #1,D2
00002952  10AE FFFF 4613          move.b    -1(A6),(A0)
00002956  60E6      4614          bra       EnterString_1
                    4615   EnterString_3:
                    4616   ; *Start = 0x00;  // terminate with a null
00002958  2042      4617          move.l    D2,A0
0000295A  4210      4618          clr.b     (A0)
0000295C  241F      4619          move.l    (A7)+,D2
0000295E  4E5E      4620          unlk      A6
00002960  4E75      4621          rts
                    4622   ; }
                    4623   ; void MemoryTest(void)
                    4624   ; {
                    4625   _MemoryTest:
00002962  4E56 FFF8 4626          link      A6,#-8
00002966  48E7 3F3C 4627          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000296A  45F9 0000 4628          lea       _printf.L,A2
0000296E  33B8      
00002970  4BF9 0000 4629          lea       _getch.L,A5
00002974  32DA      
                    4630   ; unsigned char data_byte;
                    4631   ; unsigned short data_word;
                    4632   ; unsigned long data_long;
                    4633   ; unsigned char* byte_addr;
                    4634   ; unsigned short* word_addr;
                    4635   ; unsigned long* long_addr;
                    4636   ; int start_addr, end_addr;
                    4637   ; unsigned int counter1 = 0;
00002976  4284      4638          clr.l     D4
                    4639   ; char c, a;
                    4640   ; printf("\r\nThis is the code for the test.");
00002978  4879 0000 4641          pea       @m68kde~1_139.L
0000297C  4CF2      
0000297E  4E92      4642          jsr       (A2)
00002980  584F      4643          addq.w    #4,A7
                    4644   ; printf("\r\nWould you like to carry out the test for bytes, words, or long words?");
00002982  4879 0000 4645          pea       @m68kde~1_140.L
00002986  4D14      
00002988  4E92      4646          jsr       (A2)
0000298A  584F      4647          addq.w    #4,A7
                    4648   ; printf("\r\nEnter A for byte, B for words, C for long words: ");
0000298C  4879 0000 4649          pea       @m68kde~1_141.L
00002990  4D5C      
00002992  4E92      4650          jsr       (A2)
00002994  584F      4651          addq.w    #4,A7
                    4652   ; c = toupper(getchar());
00002996  2F00      4653          move.l    D0,-(A7)
00002998  4E95      4654          jsr       (A5)
0000299A  2200      4655          move.l    D0,D1
0000299C  201F      4656          move.l    (A7)+,D0
0000299E  2F01      4657          move.l    D1,-(A7)
000029A0  4EB9 0000 4658          jsr       _toupper
000029A4  338C      
000029A6  584F      4659          addq.w    #4,A7
000029A8  1600      4660          move.b    D0,D3
                    4661   ; while (c != 'A' && c != 'B' && c != 'C') {
                    4662   MemoryTest_1:
000029AA  0C03 0041 4663          cmp.b     #65,D3
000029AE  6700 002E 4664          beq       MemoryTest_3
000029B2  0C03 0042 4665          cmp.b     #66,D3
000029B6  6726      4666          beq.s     MemoryTest_3
000029B8  0C03 0043 4667          cmp.b     #67,D3
000029BC  6720      4668          beq.s     MemoryTest_3
                    4669   ; printf("\r\n Not a valid input, please try again.");
000029BE  4879 0000 4670          pea       @m68kde~1_142.L
000029C2  4D90      
000029C4  4E92      4671          jsr       (A2)
000029C6  584F      4672          addq.w    #4,A7
                    4673   ; c = toupper(getchar());
000029C8  2F00      4674          move.l    D0,-(A7)
000029CA  4E95      4675          jsr       (A5)
000029CC  2200      4676          move.l    D0,D1
000029CE  201F      4677          move.l    (A7)+,D0
000029D0  2F01      4678          move.l    D1,-(A7)
000029D2  4EB9 0000 4679          jsr       _toupper
000029D6  338C      
000029D8  584F      4680          addq.w    #4,A7
000029DA  1600      4681          move.b    D0,D3
000029DC  60CC      4682          bra       MemoryTest_1
                    4683   MemoryTest_3:
                    4684   ; }
                    4685   ; if (c == 'A') {
000029DE  0C03 0041 4686          cmp.b     #65,D3
000029E2  6600 009E 4687          bne       MemoryTest_4
                    4688   ; printf("\r\nPick the following test data to use.");
000029E6  4879 0000 4689          pea       @m68kde~1_143.L
000029EA  4DB8      
000029EC  4E92      4690          jsr       (A2)
000029EE  584F      4691          addq.w    #4,A7
                    4692   ; printf("\r\nEnter A for 55, B for AA, C for FF, D for 00: ");
000029F0  4879 0000 4693          pea       @m68kde~1_144.L
000029F4  4DE0      
000029F6  4E92      4694          jsr       (A2)
000029F8  584F      4695          addq.w    #4,A7
                    4696   ; a = toupper(getchar());
000029FA  2F00      4697          move.l    D0,-(A7)
000029FC  4E95      4698          jsr       (A5)
000029FE  2200      4699          move.l    D0,D1
00002A00  201F      4700          move.l    (A7)+,D0
00002A02  2F01      4701          move.l    D1,-(A7)
00002A04  4EB9 0000 4702          jsr       _toupper
00002A08  338C      
00002A0A  584F      4703          addq.w    #4,A7
00002A0C  1400      4704          move.b    D0,D2
                    4705   ; while (a != 'A' && a != 'B' && a != 'C' && a != 'D') {
                    4706   MemoryTest_6:
00002A0E  0C02 0041 4707          cmp.b     #65,D2
00002A12  6700 0036 4708          beq       MemoryTest_8
00002A16  0C02 0042 4709          cmp.b     #66,D2
00002A1A  6700 002E 4710          beq       MemoryTest_8
00002A1E  0C02 0043 4711          cmp.b     #67,D2
00002A22  6726      4712          beq.s     MemoryTest_8
00002A24  0C02 0044 4713          cmp.b     #68,D2
00002A28  6720      4714          beq.s     MemoryTest_8
                    4715   ; printf("\r\n Not a valid input, please try again.");
00002A2A  4879 0000 4716          pea       @m68kde~1_142.L
00002A2E  4D90      
00002A30  4E92      4717          jsr       (A2)
00002A32  584F      4718          addq.w    #4,A7
                    4719   ; a = toupper(getchar());
00002A34  2F00      4720          move.l    D0,-(A7)
00002A36  4E95      4721          jsr       (A5)
00002A38  2200      4722          move.l    D0,D1
00002A3A  201F      4723          move.l    (A7)+,D0
00002A3C  2F01      4724          move.l    D1,-(A7)
00002A3E  4EB9 0000 4725          jsr       _toupper
00002A42  338C      
00002A44  584F      4726          addq.w    #4,A7
00002A46  1400      4727          move.b    D0,D2
00002A48  60C4      4728          bra       MemoryTest_6
                    4729   MemoryTest_8:
                    4730   ; }
                    4731   ; if (a == 'A') {
00002A4A  0C02 0041 4732          cmp.b     #65,D2
00002A4E  6608      4733          bne.s     MemoryTest_9
                    4734   ; data_byte = 0x55;
00002A50  1D7C 0055 4735          move.b    #85,-7(A6)
00002A54  FFF9      
00002A56  6026      4736          bra.s     MemoryTest_15
                    4737   MemoryTest_9:
                    4738   ; }
                    4739   ; else if (a == 'B') {
00002A58  0C02 0042 4740          cmp.b     #66,D2
00002A5C  6608      4741          bne.s     MemoryTest_11
                    4742   ; data_byte = 0xAA;
00002A5E  1D7C 00AA 4743          move.b    #170,-7(A6)
00002A62  FFF9      
00002A64  6018      4744          bra.s     MemoryTest_15
                    4745   MemoryTest_11:
                    4746   ; }
                    4747   ; else if (a == 'C') {
00002A66  0C02 0043 4748          cmp.b     #67,D2
00002A6A  6608      4749          bne.s     MemoryTest_13
                    4750   ; data_byte = 0xFF;
00002A6C  1D7C 00FF 4751          move.b    #255,-7(A6)
00002A70  FFF9      
00002A72  600A      4752          bra.s     MemoryTest_15
                    4753   MemoryTest_13:
                    4754   ; }
                    4755   ; else if (a == 'D') {
00002A74  0C02 0044 4756          cmp.b     #68,D2
00002A78  6604      4757          bne.s     MemoryTest_15
                    4758   ; data_byte = 0x00;
00002A7A  422E FFF9 4759          clr.b     -7(A6)
                    4760   MemoryTest_15:
00002A7E  6000 014C 4761          bra       MemoryTest_41
                    4762   MemoryTest_4:
                    4763   ; }
                    4764   ; }
                    4765   ; else if (c == 'B') {
00002A82  0C03 0042 4766          cmp.b     #66,D3
00002A86  6600 009E 4767          bne       MemoryTest_17
                    4768   ; printf("\r\nPick the following test data to use:");
00002A8A  4879 0000 4769          pea       @m68kde~1_145.L
00002A8E  4E12      
00002A90  4E92      4770          jsr       (A2)
00002A92  584F      4771          addq.w    #4,A7
                    4772   ; printf("\r\nEnter A for 5555, B for AAAA, C for FFFF, D for 0000: ");
00002A94  4879 0000 4773          pea       @m68kde~1_146.L
00002A98  4E3A      
00002A9A  4E92      4774          jsr       (A2)
00002A9C  584F      4775          addq.w    #4,A7
                    4776   ; a = toupper(getchar());
00002A9E  2F00      4777          move.l    D0,-(A7)
00002AA0  4E95      4778          jsr       (A5)
00002AA2  2200      4779          move.l    D0,D1
00002AA4  201F      4780          move.l    (A7)+,D0
00002AA6  2F01      4781          move.l    D1,-(A7)
00002AA8  4EB9 0000 4782          jsr       _toupper
00002AAC  338C      
00002AAE  584F      4783          addq.w    #4,A7
00002AB0  1400      4784          move.b    D0,D2
                    4785   ; while (a != 'A' && a != 'B' && a != 'C' && a != 'D') {
                    4786   MemoryTest_19:
00002AB2  0C02 0041 4787          cmp.b     #65,D2
00002AB6  6700 0036 4788          beq       MemoryTest_21
00002ABA  0C02 0042 4789          cmp.b     #66,D2
00002ABE  6700 002E 4790          beq       MemoryTest_21
00002AC2  0C02 0043 4791          cmp.b     #67,D2
00002AC6  6726      4792          beq.s     MemoryTest_21
00002AC8  0C02 0044 4793          cmp.b     #68,D2
00002ACC  6720      4794          beq.s     MemoryTest_21
                    4795   ; printf("\r\n Not a valid input, please try again.");
00002ACE  4879 0000 4796          pea       @m68kde~1_142.L
00002AD2  4D90      
00002AD4  4E92      4797          jsr       (A2)
00002AD6  584F      4798          addq.w    #4,A7
                    4799   ; a = toupper(getchar());
00002AD8  2F00      4800          move.l    D0,-(A7)
00002ADA  4E95      4801          jsr       (A5)
00002ADC  2200      4802          move.l    D0,D1
00002ADE  201F      4803          move.l    (A7)+,D0
00002AE0  2F01      4804          move.l    D1,-(A7)
00002AE2  4EB9 0000 4805          jsr       _toupper
00002AE6  338C      
00002AE8  584F      4806          addq.w    #4,A7
00002AEA  1400      4807          move.b    D0,D2
00002AEC  60C4      4808          bra       MemoryTest_19
                    4809   MemoryTest_21:
                    4810   ; }
                    4811   ; if (a == 'A') {
00002AEE  0C02 0041 4812          cmp.b     #65,D2
00002AF2  6608      4813          bne.s     MemoryTest_22
                    4814   ; data_word = 0x5555;
00002AF4  3D7C 5555 4815          move.w    #21845,-6(A6)
00002AF8  FFFA      
00002AFA  6026      4816          bra.s     MemoryTest_28
                    4817   MemoryTest_22:
                    4818   ; }
                    4819   ; else if (a == 'B') {
00002AFC  0C02 0042 4820          cmp.b     #66,D2
00002B00  6608      4821          bne.s     MemoryTest_24
                    4822   ; data_word = 0xAAAA;
00002B02  3D7C AAAA 4823          move.w    #43690,-6(A6)
00002B06  FFFA      
00002B08  6018      4824          bra.s     MemoryTest_28
                    4825   MemoryTest_24:
                    4826   ; }
                    4827   ; else if (a == 'C') {
00002B0A  0C02 0043 4828          cmp.b     #67,D2
00002B0E  6608      4829          bne.s     MemoryTest_26
                    4830   ; data_word = 0xFFFF;
00002B10  3D7C FFFF 4831          move.w    #65535,-6(A6)
00002B14  FFFA      
00002B16  600A      4832          bra.s     MemoryTest_28
                    4833   MemoryTest_26:
                    4834   ; }
                    4835   ; else if (a == 'D') {
00002B18  0C02 0044 4836          cmp.b     #68,D2
00002B1C  6604      4837          bne.s     MemoryTest_28
                    4838   ; data_word = 0x0000;
00002B1E  426E FFFA 4839          clr.w     -6(A6)
                    4840   MemoryTest_28:
00002B22  6000 00A8 4841          bra       MemoryTest_41
                    4842   MemoryTest_17:
                    4843   ; }
                    4844   ; }
                    4845   ; else if (c == 'C') {
00002B26  0C03 0043 4846          cmp.b     #67,D3
00002B2A  6600 00A0 4847          bne       MemoryTest_41
                    4848   ; printf("\r\nPick the following test data to use:");
00002B2E  4879 0000 4849          pea       @m68kde~1_145.L
00002B32  4E12      
00002B34  4E92      4850          jsr       (A2)
00002B36  584F      4851          addq.w    #4,A7
                    4852   ; printf("\r\nEnter A for 5555 5555, B for AAAA AAAA, C for BBBF FFFF, D for 0000 0000: ");
00002B38  4879 0000 4853          pea       @m68kde~1_147.L
00002B3C  4E74      
00002B3E  4E92      4854          jsr       (A2)
00002B40  584F      4855          addq.w    #4,A7
                    4856   ; a = toupper(getchar());
00002B42  2F00      4857          move.l    D0,-(A7)
00002B44  4E95      4858          jsr       (A5)
00002B46  2200      4859          move.l    D0,D1
00002B48  201F      4860          move.l    (A7)+,D0
00002B4A  2F01      4861          move.l    D1,-(A7)
00002B4C  4EB9 0000 4862          jsr       _toupper
00002B50  338C      
00002B52  584F      4863          addq.w    #4,A7
00002B54  1400      4864          move.b    D0,D2
                    4865   ; while (a != 'A' && a != 'B' && a != 'C' && a != 'D') {
                    4866   MemoryTest_32:
00002B56  0C02 0041 4867          cmp.b     #65,D2
00002B5A  6700 0036 4868          beq       MemoryTest_34
00002B5E  0C02 0042 4869          cmp.b     #66,D2
00002B62  6700 002E 4870          beq       MemoryTest_34
00002B66  0C02 0043 4871          cmp.b     #67,D2
00002B6A  6726      4872          beq.s     MemoryTest_34
00002B6C  0C02 0044 4873          cmp.b     #68,D2
00002B70  6720      4874          beq.s     MemoryTest_34
                    4875   ; printf("\r\n Not a valid input, please try again.");
00002B72  4879 0000 4876          pea       @m68kde~1_142.L
00002B76  4D90      
00002B78  4E92      4877          jsr       (A2)
00002B7A  584F      4878          addq.w    #4,A7
                    4879   ; a = toupper(getchar());
00002B7C  2F00      4880          move.l    D0,-(A7)
00002B7E  4E95      4881          jsr       (A5)
00002B80  2200      4882          move.l    D0,D1
00002B82  201F      4883          move.l    (A7)+,D0
00002B84  2F01      4884          move.l    D1,-(A7)
00002B86  4EB9 0000 4885          jsr       _toupper
00002B8A  338C      
00002B8C  584F      4886          addq.w    #4,A7
00002B8E  1400      4887          move.b    D0,D2
00002B90  60C4      4888          bra       MemoryTest_32
                    4889   MemoryTest_34:
                    4890   ; }
                    4891   ; if (a == 'A') {
00002B92  0C02 0041 4892          cmp.b     #65,D2
00002B96  660A      4893          bne.s     MemoryTest_35
                    4894   ; data_long = 0x55555555;
00002B98  2D7C 5555 4895          move.l    #1431655765,-4(A6)
00002B9C  5555 FFFC 
00002BA0  602A      4896          bra.s     MemoryTest_41
                    4897   MemoryTest_35:
                    4898   ; }
                    4899   ; else if (a == 'B') {
00002BA2  0C02 0042 4900          cmp.b     #66,D2
00002BA6  660A      4901          bne.s     MemoryTest_37
                    4902   ; data_long = 0xAAAAAAAA;
00002BA8  2D7C AAAA 4903          move.l    #-1431655766,-4(A6)
00002BAC  AAAA FFFC 
00002BB0  601A      4904          bra.s     MemoryTest_41
                    4905   MemoryTest_37:
                    4906   ; }
                    4907   ; else if (a == 'C') {
00002BB2  0C02 0043 4908          cmp.b     #67,D2
00002BB6  660A      4909          bne.s     MemoryTest_39
                    4910   ; data_long = 0xBBBFFFFF;
00002BB8  2D7C BBBF 4911          move.l    #-1145044993,-4(A6)
00002BBC  FFFF FFFC 
00002BC0  600A      4912          bra.s     MemoryTest_41
                    4913   MemoryTest_39:
                    4914   ; }
                    4915   ; else if (a == 'D') {
00002BC2  0C02 0044 4916          cmp.b     #68,D2
00002BC6  6604      4917          bne.s     MemoryTest_41
                    4918   ; data_long = 0x00000000;
00002BC8  42AE FFFC 4919          clr.l     -4(A6)
                    4920   MemoryTest_41:
                    4921   ; }
                    4922   ; }
                    4923   ; //Specify start address
                    4924   ; printf("\r\nSpecify start address in hexadecimal: ");
00002BCC  4879 0000 4925          pea       @m68kde~1_148.L
00002BD0  4EC2      
00002BD2  4E92      4926          jsr       (A2)
00002BD4  584F      4927          addq.w    #4,A7
                    4928   ; start_addr = Get8HexDigits(0);
00002BD6  42A7      4929          clr.l     -(A7)
00002BD8  4EB8 0CA4 4930          jsr       _Get8HexDigits
00002BDC  584F      4931          addq.w    #4,A7
00002BDE  2840      4932          move.l    D0,A4
                    4933   ; //Specify end address
                    4934   ; printf("\r\nSpecify end address in hexadecimal: ");
00002BE0  4879 0000 4935          pea       @m68kde~1_149.L
00002BE4  4EEC      
00002BE6  4E92      4936          jsr       (A2)
00002BE8  584F      4937          addq.w    #4,A7
                    4938   ; end_addr = Get8HexDigits(0);
00002BEA  42A7      4939          clr.l     -(A7)
00002BEC  4EB8 0CA4 4940          jsr       _Get8HexDigits
00002BF0  584F      4941          addq.w    #4,A7
00002BF2  2640      4942          move.l    D0,A3
                    4943   ; printf("\r\nWriting to address.....");
00002BF4  4879 0000 4944          pea       @m68kde~1_150.L
00002BF8  4F14      
00002BFA  4E92      4945          jsr       (A2)
00002BFC  584F      4946          addq.w    #4,A7
                    4947   ; //Starting address must be less than end address
                    4948   ; if (start_addr > end_addr) {
00002BFE  200C      4949          move.l    A4,D0
00002C00  B08B      4950          cmp.l     A3,D0
00002C02  6F26      4951          ble.s     MemoryTest_43
                    4952   ; printf("\r\nCannot write word to address, starting address must be less than end address.");
00002C04  4879 0000 4953          pea       @m68kde~1_151.L
00002C08  4F2E      
00002C0A  4E92      4954          jsr       (A2)
00002C0C  584F      4955          addq.w    #4,A7
                    4956   ; printf("\r\nStart address tested: %x", start_addr);
00002C0E  2F0C      4957          move.l    A4,-(A7)
00002C10  4879 0000 4958          pea       @m68kde~1_152.L
00002C14  4F7E      
00002C16  4E92      4959          jsr       (A2)
00002C18  504F      4960          addq.w    #8,A7
                    4961   ; printf("\r\nEnd address tested: %x", end_addr);
00002C1A  2F0B      4962          move.l    A3,-(A7)
00002C1C  4879 0000 4963          pea       @m68kde~1_153.L
00002C20  4F9A      
00002C22  4E92      4964          jsr       (A2)
00002C24  504F      4965          addq.w    #8,A7
00002C26  6000 02D4 4966          bra       MemoryTest_71
                    4967   MemoryTest_43:
                    4968   ; }
                    4969   ; //Data greater than FF + Start/end address not even, throw error
                    4970   ; else if ((start_addr % 2 != 0 || end_addr % 2 != 0) && (c == 'B' || c == 'C')) {
00002C2A  2F0C      4971          move.l    A4,-(A7)
00002C2C  4878 0002 4972          pea       2
00002C30  4EB9 0000 4973          jsr       LDIV
00002C34  31DE      
00002C36  202F 0004 4974          move.l    4(A7),D0
00002C3A  504F      4975          addq.w    #8,A7
00002C3C  4A80      4976          tst.l     D0
00002C3E  6618      4977          bne.s     MemoryTest_47
00002C40  2F0B      4978          move.l    A3,-(A7)
00002C42  4878 0002 4979          pea       2
00002C46  4EB9 0000 4980          jsr       LDIV
00002C4A  31DE      
00002C4C  202F 0004 4981          move.l    4(A7),D0
00002C50  504F      4982          addq.w    #8,A7
00002C52  4A80      4983          tst.l     D0
00002C54  6700 0034 4984          beq       MemoryTest_45
                    4985   MemoryTest_47:
00002C58  0C03 0042 4986          cmp.b     #66,D3
00002C5C  6706      4987          beq.s     MemoryTest_48
00002C5E  0C03 0043 4988          cmp.b     #67,D3
00002C62  6626      4989          bne.s     MemoryTest_45
                    4990   MemoryTest_48:
                    4991   ; printf("\r\nCannot write word to address, uneven memory addressing.");
00002C64  4879 0000 4992          pea       @m68kde~1_154.L
00002C68  4FB4      
00002C6A  4E92      4993          jsr       (A2)
00002C6C  584F      4994          addq.w    #4,A7
                    4995   ; printf("\r\nStart address tested: %x", start_addr);
00002C6E  2F0C      4996          move.l    A4,-(A7)
00002C70  4879 0000 4997          pea       @m68kde~1_152.L
00002C74  4F7E      
00002C76  4E92      4998          jsr       (A2)
00002C78  504F      4999          addq.w    #8,A7
                    5000   ; printf("\r\nEnd address tested: %x", end_addr);
00002C7A  2F0B      5001          move.l    A3,-(A7)
00002C7C  4879 0000 5002          pea       @m68kde~1_153.L
00002C80  4F9A      
00002C82  4E92      5003          jsr       (A2)
00002C84  504F      5004          addq.w    #8,A7
00002C86  6000 0274 5005          bra       MemoryTest_71
                    5006   MemoryTest_45:
                    5007   ; }
                    5008   ; //If not, then it should work
                    5009   ; else {
                    5010   ; //Bytes
                    5011   ; if (c == 'A') {
00002C8A  0C03 0041 5012          cmp.b     #65,D3
00002C8E  6600 00D4 5013          bne       MemoryTest_49
                    5014   ; byte_addr = start_addr;
00002C92  2E0C      5015          move.l    A4,D7
                    5016   ; for (byte_addr; byte_addr < end_addr; byte_addr++) {
                    5017   MemoryTest_51:
00002C94  BE8B      5018          cmp.l     A3,D7
00002C96  6400 00C8 5019          bhs       MemoryTest_53
                    5020   ; *byte_addr = data_byte;
00002C9A  2047      5021          move.l    D7,A0
00002C9C  10AE FFF9 5022          move.b    -7(A6),(A0)
                    5023   ; if (byte_addr[0] != data_byte) {
00002CA0  2047      5024          move.l    D7,A0
00002CA2  1010      5025          move.b    (A0),D0
00002CA4  B02E FFF9 5026          cmp.b     -7(A6),D0
00002CA8  6700 0054 5027          beq       MemoryTest_54
                    5028   ; printf("\r\n---------------------------------");
00002CAC  4879 0000 5029          pea       @m68kde~1_155.L
00002CB0  4FEE      
00002CB2  4E92      5030          jsr       (A2)
00002CB4  584F      5031          addq.w    #4,A7
                    5032   ; printf("\r\nTest number %d...", counter1);
00002CB6  2F04      5033          move.l    D4,-(A7)
00002CB8  4879 0000 5034          pea       @m68kde~1_156.L
00002CBC  5012      
00002CBE  4E92      5035          jsr       (A2)
00002CC0  504F      5036          addq.w    #8,A7
                    5037   ; printf("\r\nFailed to write to address %x", byte_addr);
00002CC2  2F07      5038          move.l    D7,-(A7)
00002CC4  4879 0000 5039          pea       @m68kde~1_157.L
00002CC8  5026      
00002CCA  4E92      5040          jsr       (A2)
00002CCC  504F      5041          addq.w    #8,A7
                    5042   ; printf("\r\nValue to be written: %x", data_byte);
00002CCE  122E FFF9 5043          move.b    -7(A6),D1
00002CD2  C2BC 0000 5044          and.l     #255,D1
00002CD6  00FF      
00002CD8  2F01      5045          move.l    D1,-(A7)
00002CDA  4879 0000 5046          pea       @m68kde~1_158.L
00002CDE  5046      
00002CE0  4E92      5047          jsr       (A2)
00002CE2  504F      5048          addq.w    #8,A7
                    5049   ; printf("\r\nValue read: %x", byte_addr[0]);
00002CE4  2047      5050          move.l    D7,A0
00002CE6  1210      5051          move.b    (A0),D1
00002CE8  C2BC 0000 5052          and.l     #255,D1
00002CEC  00FF      
00002CEE  2F01      5053          move.l    D1,-(A7)
00002CF0  4879 0000 5054          pea       @m68kde~1_159.L
00002CF4  5060      
00002CF6  4E92      5055          jsr       (A2)
00002CF8  504F      5056          addq.w    #8,A7
                    5057   ; break;
00002CFA  6000 0064 5058          bra       MemoryTest_53
                    5059   MemoryTest_54:
                    5060   ; }
                    5061   ; if (counter1 % 1000 == 0) {
00002CFE  2F04      5062          move.l    D4,-(A7)
00002D00  4878 03E8 5063          pea       1000
00002D04  4EB9 0000 5064          jsr       ULDIV
00002D08  31CC      
00002D0A  202F 0004 5065          move.l    4(A7),D0
00002D0E  504F      5066          addq.w    #8,A7
00002D10  4A80      5067          tst.l     D0
00002D12  6600 0044 5068          bne       MemoryTest_56
                    5069   ; printf("\r\n---------------------------------");
00002D16  4879 0000 5070          pea       @m68kde~1_155.L
00002D1A  4FEE      
00002D1C  4E92      5071          jsr       (A2)
00002D1E  584F      5072          addq.w    #4,A7
                    5073   ; printf("\r\nTest number %d...", counter1);
00002D20  2F04      5074          move.l    D4,-(A7)
00002D22  4879 0000 5075          pea       @m68kde~1_156.L
00002D26  5012      
00002D28  4E92      5076          jsr       (A2)
00002D2A  504F      5077          addq.w    #8,A7
                    5078   ; printf("\r\nAddress:%x", byte_addr);
00002D2C  2F07      5079          move.l    D7,-(A7)
00002D2E  4879 0000 5080          pea       @m68kde~1_160.L
00002D32  5072      
00002D34  4E92      5081          jsr       (A2)
00002D36  504F      5082          addq.w    #8,A7
                    5083   ; printf("\r\nValue at specified address: %x", byte_addr[0]);
00002D38  2047      5084          move.l    D7,A0
00002D3A  1210      5085          move.b    (A0),D1
00002D3C  C2BC 0000 5086          and.l     #255,D1
00002D40  00FF      
00002D42  2F01      5087          move.l    D1,-(A7)
00002D44  4879 0000 5088          pea       @m68kde~1_161.L
00002D48  5080      
00002D4A  4E92      5089          jsr       (A2)
00002D4C  504F      5090          addq.w    #8,A7
                    5091   ; printf("\r\nTest Passed");
00002D4E  4879 0000 5092          pea       @m68kde~1_162.L
00002D52  50A2      
00002D54  4E92      5093          jsr       (A2)
00002D56  584F      5094          addq.w    #4,A7
                    5095   MemoryTest_56:
                    5096   ; }
                    5097   ; counter1++;
00002D58  5284      5098          addq.l    #1,D4
00002D5A  5287      5099          addq.l    #1,D7
00002D5C  6000 FF36 5100          bra       MemoryTest_51
                    5101   MemoryTest_53:
00002D60  6000 019A 5102          bra       MemoryTest_71
                    5103   MemoryTest_49:
                    5104   ; }
                    5105   ; }
                    5106   ; //Words
                    5107   ; else if (c == 'B') {
00002D64  0C03 0042 5108          cmp.b     #66,D3
00002D68  6600 00D4 5109          bne       MemoryTest_58
                    5110   ; word_addr = start_addr;
00002D6C  2C0C      5111          move.l    A4,D6
                    5112   ; for (word_addr; word_addr < end_addr; word_addr++) {
                    5113   MemoryTest_60:
00002D6E  BC8B      5114          cmp.l     A3,D6
00002D70  6400 00C8 5115          bhs       MemoryTest_62
                    5116   ; *word_addr = data_word;
00002D74  2046      5117          move.l    D6,A0
00002D76  30AE FFFA 5118          move.w    -6(A6),(A0)
                    5119   ; if (word_addr[0] != data_word) {
00002D7A  2046      5120          move.l    D6,A0
00002D7C  3010      5121          move.w    (A0),D0
00002D7E  B06E FFFA 5122          cmp.w     -6(A6),D0
00002D82  6700 0054 5123          beq       MemoryTest_63
                    5124   ; printf("\r\n---------------------------------");
00002D86  4879 0000 5125          pea       @m68kde~1_155.L
00002D8A  4FEE      
00002D8C  4E92      5126          jsr       (A2)
00002D8E  584F      5127          addq.w    #4,A7
                    5128   ; printf("\r\nTest number %d...", counter1);
00002D90  2F04      5129          move.l    D4,-(A7)
00002D92  4879 0000 5130          pea       @m68kde~1_156.L
00002D96  5012      
00002D98  4E92      5131          jsr       (A2)
00002D9A  504F      5132          addq.w    #8,A7
                    5133   ; printf("\r\nFailed to write to address %x", word_addr);
00002D9C  2F06      5134          move.l    D6,-(A7)
00002D9E  4879 0000 5135          pea       @m68kde~1_157.L
00002DA2  5026      
00002DA4  4E92      5136          jsr       (A2)
00002DA6  504F      5137          addq.w    #8,A7
                    5138   ; printf("\r\nValue to be written: %x", data_word);
00002DA8  322E FFFA 5139          move.w    -6(A6),D1
00002DAC  C2BC 0000 5140          and.l     #65535,D1
00002DB0  FFFF      
00002DB2  2F01      5141          move.l    D1,-(A7)
00002DB4  4879 0000 5142          pea       @m68kde~1_158.L
00002DB8  5046      
00002DBA  4E92      5143          jsr       (A2)
00002DBC  504F      5144          addq.w    #8,A7
                    5145   ; printf("\r\nValue read: %x", word_addr[0]);
00002DBE  2046      5146          move.l    D6,A0
00002DC0  3210      5147          move.w    (A0),D1
00002DC2  C2BC 0000 5148          and.l     #65535,D1
00002DC6  FFFF      
00002DC8  2F01      5149          move.l    D1,-(A7)
00002DCA  4879 0000 5150          pea       @m68kde~1_159.L
00002DCE  5060      
00002DD0  4E92      5151          jsr       (A2)
00002DD2  504F      5152          addq.w    #8,A7
                    5153   ; break;
00002DD4  6000 0064 5154          bra       MemoryTest_62
                    5155   MemoryTest_63:
                    5156   ; }
                    5157   ; if (counter1 % 500 == 0) {
00002DD8  2F04      5158          move.l    D4,-(A7)
00002DDA  4878 01F4 5159          pea       500
00002DDE  4EB9 0000 5160          jsr       ULDIV
00002DE2  31CC      
00002DE4  202F 0004 5161          move.l    4(A7),D0
00002DE8  504F      5162          addq.w    #8,A7
00002DEA  4A80      5163          tst.l     D0
00002DEC  6600 0044 5164          bne       MemoryTest_65
                    5165   ; printf("\r\n---------------------------------");
00002DF0  4879 0000 5166          pea       @m68kde~1_155.L
00002DF4  4FEE      
00002DF6  4E92      5167          jsr       (A2)
00002DF8  584F      5168          addq.w    #4,A7
                    5169   ; printf("\r\nTest number %d...", counter1);
00002DFA  2F04      5170          move.l    D4,-(A7)
00002DFC  4879 0000 5171          pea       @m68kde~1_156.L
00002E00  5012      
00002E02  4E92      5172          jsr       (A2)
00002E04  504F      5173          addq.w    #8,A7
                    5174   ; printf("\r\nAddress:%x", word_addr);
00002E06  2F06      5175          move.l    D6,-(A7)
00002E08  4879 0000 5176          pea       @m68kde~1_160.L
00002E0C  5072      
00002E0E  4E92      5177          jsr       (A2)
00002E10  504F      5178          addq.w    #8,A7
                    5179   ; printf("\r\nValue at specified address: %x", word_addr[0]);
00002E12  2046      5180          move.l    D6,A0
00002E14  3210      5181          move.w    (A0),D1
00002E16  C2BC 0000 5182          and.l     #65535,D1
00002E1A  FFFF      
00002E1C  2F01      5183          move.l    D1,-(A7)
00002E1E  4879 0000 5184          pea       @m68kde~1_161.L
00002E22  5080      
00002E24  4E92      5185          jsr       (A2)
00002E26  504F      5186          addq.w    #8,A7
                    5187   ; printf("\r\nTest Passed");
00002E28  4879 0000 5188          pea       @m68kde~1_162.L
00002E2C  50A2      
00002E2E  4E92      5189          jsr       (A2)
00002E30  584F      5190          addq.w    #4,A7
                    5191   MemoryTest_65:
                    5192   ; }
                    5193   ; counter1++;
00002E32  5284      5194          addq.l    #1,D4
00002E34  5486      5195          addq.l    #2,D6
00002E36  6000 FF36 5196          bra       MemoryTest_60
                    5197   MemoryTest_62:
00002E3A  6000 00C0 5198          bra       MemoryTest_71
                    5199   MemoryTest_58:
                    5200   ; }
                    5201   ; }
                    5202   ; //Long Words
                    5203   ; else if (c == 'C') {
00002E3E  0C03 0043 5204          cmp.b     #67,D3
00002E42  6600 00B8 5205          bne       MemoryTest_71
                    5206   ; long_addr = start_addr;
00002E46  2A0C      5207          move.l    A4,D5
                    5208   ; for (long_addr; long_addr < end_addr; long_addr++) {
                    5209   MemoryTest_69:
00002E48  BA8B      5210          cmp.l     A3,D5
00002E4A  6400 00B0 5211          bhs       MemoryTest_71
                    5212   ; *long_addr = data_long;
00002E4E  2045      5213          move.l    D5,A0
00002E50  20AE FFFC 5214          move.l    -4(A6),(A0)
                    5215   ; if (long_addr[0] != data_long) {
00002E54  2045      5216          move.l    D5,A0
00002E56  2010      5217          move.l    (A0),D0
00002E58  B0AE FFFC 5218          cmp.l     -4(A6),D0
00002E5C  6700 0044 5219          beq       MemoryTest_72
                    5220   ; printf("\r\n---------------------------------");
00002E60  4879 0000 5221          pea       @m68kde~1_155.L
00002E64  4FEE      
00002E66  4E92      5222          jsr       (A2)
00002E68  584F      5223          addq.w    #4,A7
                    5224   ; printf("\r\nTest number %d...", counter1);
00002E6A  2F04      5225          move.l    D4,-(A7)
00002E6C  4879 0000 5226          pea       @m68kde~1_156.L
00002E70  5012      
00002E72  4E92      5227          jsr       (A2)
00002E74  504F      5228          addq.w    #8,A7
                    5229   ; printf("\r\nFailed to write to address %x", long_addr);
00002E76  2F05      5230          move.l    D5,-(A7)
00002E78  4879 0000 5231          pea       @m68kde~1_157.L
00002E7C  5026      
00002E7E  4E92      5232          jsr       (A2)
00002E80  504F      5233          addq.w    #8,A7
                    5234   ; printf("\r\nValue to be written: %x", data_long);
00002E82  2F2E FFFC 5235          move.l    -4(A6),-(A7)
00002E86  4879 0000 5236          pea       @m68kde~1_158.L
00002E8A  5046      
00002E8C  4E92      5237          jsr       (A2)
00002E8E  504F      5238          addq.w    #8,A7
                    5239   ; printf("\r\nValue read: %x", long_addr[0]);
00002E90  2045      5240          move.l    D5,A0
00002E92  2F10      5241          move.l    (A0),-(A7)
00002E94  4879 0000 5242          pea       @m68kde~1_159.L
00002E98  5060      
00002E9A  4E92      5243          jsr       (A2)
00002E9C  504F      5244          addq.w    #8,A7
                    5245   ; break;
00002E9E  6000 005C 5246          bra       MemoryTest_71
                    5247   MemoryTest_72:
                    5248   ; }
                    5249   ; if (counter1 % 250 == 0) {
00002EA2  2F04      5250          move.l    D4,-(A7)
00002EA4  4878 00FA 5251          pea       250
00002EA8  4EB9 0000 5252          jsr       ULDIV
00002EAC  31CC      
00002EAE  202F 0004 5253          move.l    4(A7),D0
00002EB2  504F      5254          addq.w    #8,A7
00002EB4  4A80      5255          tst.l     D0
00002EB6  6600 003C 5256          bne       MemoryTest_74
                    5257   ; printf("\r\n---------------------------------");
00002EBA  4879 0000 5258          pea       @m68kde~1_155.L
00002EBE  4FEE      
00002EC0  4E92      5259          jsr       (A2)
00002EC2  584F      5260          addq.w    #4,A7
                    5261   ; printf("\r\nTest number %d...", counter1);
00002EC4  2F04      5262          move.l    D4,-(A7)
00002EC6  4879 0000 5263          pea       @m68kde~1_156.L
00002ECA  5012      
00002ECC  4E92      5264          jsr       (A2)
00002ECE  504F      5265          addq.w    #8,A7
                    5266   ; printf("\r\nAddress:%x", long_addr);
00002ED0  2F05      5267          move.l    D5,-(A7)
00002ED2  4879 0000 5268          pea       @m68kde~1_160.L
00002ED6  5072      
00002ED8  4E92      5269          jsr       (A2)
00002EDA  504F      5270          addq.w    #8,A7
                    5271   ; printf("\r\nValue at specified address: %x", long_addr[0]);
00002EDC  2045      5272          move.l    D5,A0
00002EDE  2F10      5273          move.l    (A0),-(A7)
00002EE0  4879 0000 5274          pea       @m68kde~1_161.L
00002EE4  5080      
00002EE6  4E92      5275          jsr       (A2)
00002EE8  504F      5276          addq.w    #8,A7
                    5277   ; printf("\r\nTest Passed");
00002EEA  4879 0000 5278          pea       @m68kde~1_162.L
00002EEE  50A2      
00002EF0  4E92      5279          jsr       (A2)
00002EF2  584F      5280          addq.w    #4,A7
                    5281   MemoryTest_74:
                    5282   ; }
                    5283   ; counter1++;
00002EF4  5284      5284          addq.l    #1,D4
00002EF6  5885      5285          addq.l    #4,D5
00002EF8  6000 FF4E 5286          bra       MemoryTest_69
                    5287   MemoryTest_71:
00002EFC  4CDF 3CFC 5288          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002F00  4E5E      5289          unlk      A6
00002F02  4E75      5290          rts
                    5291   ; }
                    5292   ; }
                    5293   ; }
                    5294   ; }
                    5295   ; void main(void)
                    5296   ; {
                    5297   _main:
00002F04  4E56 FFF4 5298          link      A6,#-12
00002F08  48E7 3030 5299          movem.l   D2/D3/A2/A3,-(A7)
00002F0C  45F8 0A30 5300          lea       _InstallExceptionHandler.L,A2
00002F10  47F9 0000 5301          lea       _printf.L,A3
00002F14  33B8      
                    5302   ; char c;
                    5303   ; int i, j;
                    5304   ; char* BugMessage = "DE1-68k Bug V1.77";
00002F16  41F9 0000 5305          lea       @m68kde~1_163.L,A0
00002F1A  50B0      
00002F1C  2608      5306          move.l    A0,D3
                    5307   ; char* CopyrightMessage = "Copyright (C) PJ Davies 2016";
00002F1E  41F9 0000 5308          lea       @m68kde~1_164.L,A0
00002F22  50C2      
00002F24  2D48 FFFC 5309          move.l    A0,-4(A6)
                    5310   ; KillAllBreakPoints();
00002F28  4EB8 200E 5311          jsr       _KillAllBreakPoints
                    5312   ; i = x = y = z = PortA_Count = 0;
00002F2C  42B9 0803 5313          clr.l     _PortA_Count.L
00002F30  00D4      
00002F32  42B9 0803 5314          clr.l     _z.L
00002F36  00D0      
00002F38  42B9 0803 5315          clr.l     _y.L
00002F3C  00CC      
00002F3E  42B9 0803 5316          clr.l     _x.L
00002F42  00C8      
00002F44  4282      5317          clr.l     D2
                    5318   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
00002F46  42B9 0803 5319          clr.l     _GoFlag.L
00002F4A  00DC      
00002F4C  42B9 0803 5320          clr.l     _Trace.L
00002F50  00D8      
                    5321   ; Echo = 1;
00002F52  23FC 0000 5322          move.l    #1,_Echo.L
00002F56  0001 0803 
00002F5A  00E0      
                    5323   ; d0 = d1 = d2 = d3 = d4 = d5 = d6 = d7 = 0;
00002F5C  42B9 0803 5324          clr.l     _d7.L
00002F60  0100      
00002F62  42B9 0803 5325          clr.l     _d6.L
00002F66  00FC      
00002F68  42B9 0803 5326          clr.l     _d5.L
00002F6C  00F8      
00002F6E  42B9 0803 5327          clr.l     _d4.L
00002F72  00F4      
00002F74  42B9 0803 5328          clr.l     _d3.L
00002F78  00F0      
00002F7A  42B9 0803 5329          clr.l     _d2.L
00002F7E  00EC      
00002F80  42B9 0803 5330          clr.l     _d1.L
00002F84  00E8      
00002F86  42B9 0803 5331          clr.l     _d0.L
00002F8A  00E4      
                    5332   ; a0 = a1 = a2 = a3 = a4 = a5 = a6 = 0;
00002F8C  42B9 0803 5333          clr.l     _a6.L
00002F90  011C      
00002F92  42B9 0803 5334          clr.l     _a5.L
00002F96  0118      
00002F98  42B9 0803 5335          clr.l     _a4.L
00002F9C  0114      
00002F9E  42B9 0803 5336          clr.l     _a3.L
00002FA2  0110      
00002FA4  42B9 0803 5337          clr.l     _a2.L
00002FA8  010C      
00002FAA  42B9 0803 5338          clr.l     _a1.L
00002FAE  0108      
00002FB0  42B9 0803 5339          clr.l     _a0.L
00002FB4  0104      
                    5340   ; PC = ProgramStart, SSP = TopOfStack, USP = TopOfStack;
00002FB6  23FC 0800 5341          move.l    #134217728,_PC.L
00002FBA  0000 0803 
00002FBE  0120      
00002FC0  23FC 0C00 5342          move.l    #201326592,_SSP.L
00002FC4  0000 0803 
00002FC8  0124      
00002FCA  23FC 0C00 5343          move.l    #201326592,_USP.L
00002FCE  0000 0803 
00002FD2  0128      
                    5344   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00002FD4  33FC 2000 5345          move.w    #8192,_SR.L
00002FD8  0803 012C 
                    5346   ; // Initialise Breakpoint variables
                    5347   ; for (i = 0; i < 8; i++) {
00002FDC  4282      5348          clr.l     D2
                    5349   main_1:
00002FDE  0C82 0000 5350          cmp.l     #8,D2
00002FE2  0008      
00002FE4  6C00 004C 5351          bge       main_3
                    5352   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00002FE8  2002      5353          move.l    D2,D0
00002FEA  E588      5354          lsl.l     #2,D0
00002FEC  41F9 0803 5355          lea       _BreakPointAddress.L,A0
00002FF0  012E      
00002FF2  42B0 0800 5356          clr.l     0(A0,D0.L)
                    5357   ; WatchPointAddress[i] = 0;
00002FF6  2002      5358          move.l    D2,D0
00002FF8  E588      5359          lsl.l     #2,D0
00002FFA  41F9 0803 5360          lea       _WatchPointAddress.L,A0
00002FFE  0182      
00003000  42B0 0800 5361          clr.l     0(A0,D0.L)
                    5362   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
00003004  2002      5363          move.l    D2,D0
00003006  E388      5364          lsl.l     #1,D0
00003008  41F9 0803 5365          lea       _BreakPointInstruction.L,A0
0000300C  014E      
0000300E  4270 0800 5366          clr.w     0(A0,D0.L)
                    5367   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
00003012  2002      5368          move.l    D2,D0
00003014  E588      5369          lsl.l     #2,D0
00003016  41F9 0803 5370          lea       _BreakPointSetOrCleared.L,A0
0000301A  015E      
0000301C  42B0 0800 5371          clr.l     0(A0,D0.L)
                    5372   ; WatchPointSetOrCleared[i] = 0;
00003020  2002      5373          move.l    D2,D0
00003022  E588      5374          lsl.l     #2,D0
00003024  41F9 0803 5375          lea       _WatchPointSetOrCleared.L,A0
00003028  01A2      
0000302A  42B0 0800 5376          clr.l     0(A0,D0.L)
0000302E  5282      5377          addq.l    #1,D2
00003030  60AC      5378          bra       main_1
                    5379   main_3:
                    5380   ; }
                    5381   ; Init_RS232();     // initialise the RS232 port
00003032  4EB8 0B12 5382          jsr       _Init_RS232
                    5383   ; Init_LCD();
00003036  4EB8 095E 5384          jsr       _Init_LCD
                    5385   ; for (i = 32; i < 48; i++)
0000303A  7420      5386          moveq     #32,D2
                    5387   main_4:
0000303C  0C82 0000 5388          cmp.l     #48,D2
00003040  0030      
00003042  6C0E      5389          bge.s     main_6
                    5390   ; InstallExceptionHandler(UnhandledTrap, i);		        // install Trap exception handler on vector 32-47
00003044  2F02      5391          move.l    D2,-(A7)
00003046  4878 2886 5392          pea       _UnhandledTrap.L
0000304A  4E92      5393          jsr       (A2)
0000304C  504F      5394          addq.w    #8,A7
0000304E  5282      5395          addq.l    #1,D2
00003050  60EA      5396          bra       main_4
                    5397   main_6:
                    5398   ; InstallExceptionHandler(menu, 47);		                   // TRAP #15 call debug and end program
00003052  4878 002F 5399          pea       47
00003056  4878 2560 5400          pea       _menu.L
0000305A  4E92      5401          jsr       (A2)
0000305C  504F      5402          addq.w    #8,A7
                    5403   ; InstallExceptionHandler(UnhandledIRQ1, 25);		      // install handler for interrupts
0000305E  4878 0019 5404          pea       25
00003062  4878 282C 5405          pea       _UnhandledIRQ1.L
00003066  4E92      5406          jsr       (A2)
00003068  504F      5407          addq.w    #8,A7
                    5408   ; InstallExceptionHandler(UnhandledIRQ2, 26);		      // install handler for interrupts
0000306A  4878 001A 5409          pea       26
0000306E  4878 2838 5410          pea       _UnhandledIRQ2.L
00003072  4E92      5411          jsr       (A2)
00003074  504F      5412          addq.w    #8,A7
                    5413   ; InstallExceptionHandler(UnhandledIRQ3, 27);		      // install handler for interrupts
00003076  4878 001B 5414          pea       27
0000307A  4878 2844 5415          pea       _UnhandledIRQ3.L
0000307E  4E92      5416          jsr       (A2)
00003080  504F      5417          addq.w    #8,A7
                    5418   ; InstallExceptionHandler(UnhandledIRQ4, 28);		      // install handler for interrupts
00003082  4878 001C 5419          pea       28
00003086  4878 2850 5420          pea       _UnhandledIRQ4.L
0000308A  4E92      5421          jsr       (A2)
0000308C  504F      5422          addq.w    #8,A7
                    5423   ; InstallExceptionHandler(UnhandledIRQ5, 29);		      // install handler for interrupts
0000308E  4878 001D 5424          pea       29
00003092  4878 285C 5425          pea       _UnhandledIRQ5.L
00003096  4E92      5426          jsr       (A2)
00003098  504F      5427          addq.w    #8,A7
                    5428   ; //InstallExceptionHandler(UnhandledIRQ6, 30);		      // install handler for interrupts
                    5429   ; InstallExceptionHandler(UnhandledIRQ7, 31);		      // install handler for interrupts
0000309A  4878 001F 5430          pea       31
0000309E  4878 287A 5431          pea       _UnhandledIRQ7.L
000030A2  4E92      5432          jsr       (A2)
000030A4  504F      5433          addq.w    #8,A7
                    5434   ; InstallExceptionHandler(HandleBreakPoint, 46);		           // install Trap 14 Break Point exception handler on vector 46
000030A6  4878 002E 5435          pea       46
000030AA  4878 229C 5436          pea       _HandleBreakPoint.L
000030AE  4E92      5437          jsr       (A2)
000030B0  504F      5438          addq.w    #8,A7
                    5439   ; InstallExceptionHandler(DumpRegistersandPause, 29);		   // install TRACE handler for IRQ5 on vector 29
000030B2  4878 001D 5440          pea       29
000030B6  4878 197C 5441          pea       _DumpRegistersandPause.L
000030BA  4E92      5442          jsr       (A2)
000030BC  504F      5443          addq.w    #8,A7
                    5444   ; InstallExceptionHandler(BusError, 2);                          // install Bus error handler
000030BE  4878 0002 5445          pea       2
000030C2  4878 2894 5446          pea       _BusError.L
000030C6  4E92      5447          jsr       (A2)
000030C8  504F      5448          addq.w    #8,A7
                    5449   ; InstallExceptionHandler(AddressError, 3);                      // install address error handler (doesn't work on soft core 68k implementation)
000030CA  4878 0003 5450          pea       3
000030CE  4878 28A2 5451          pea       _AddressError.L
000030D2  4E92      5452          jsr       (A2)
000030D4  504F      5453          addq.w    #8,A7
                    5454   ; InstallExceptionHandler(IllegalInstruction, 4);                // install illegal instruction exception handler
000030D6  4878 0004 5455          pea       4
000030DA  4878 28B0 5456          pea       _IllegalInstruction.L
000030DE  4E92      5457          jsr       (A2)
000030E0  504F      5458          addq.w    #8,A7
                    5459   ; InstallExceptionHandler(Dividebyzero, 5);                      // install /0 exception handler
000030E2  4878 0005 5460          pea       5
000030E6  4878 28BE 5461          pea       _Dividebyzero.L
000030EA  4E92      5462          jsr       (A2)
000030EC  504F      5463          addq.w    #8,A7
                    5464   ; InstallExceptionHandler(Check, 6);                             // install check instruction exception handler
000030EE  4878 0006 5465          pea       6
000030F2  4878 28CC 5466          pea       _Check.L
000030F6  4E92      5467          jsr       (A2)
000030F8  504F      5468          addq.w    #8,A7
                    5469   ; InstallExceptionHandler(Trapv, 7);                             // install trapv instruction exception handler
000030FA  4878 0007 5470          pea       7
000030FE  4878 28DA 5471          pea       _Trapv.L
00003102  4E92      5472          jsr       (A2)
00003104  504F      5473          addq.w    #8,A7
                    5474   ; InstallExceptionHandler(PrivError, 8);                         // install Priv Violation exception handler
00003106  4878 0008 5475          pea       8
0000310A  4878 28E8 5476          pea       _PrivError.L
0000310E  4E92      5477          jsr       (A2)
00003110  504F      5478          addq.w    #8,A7
                    5479   ; InstallExceptionHandler(UnitIRQ, 15);                          // install uninitialised IRQ exception handler
00003112  4878 000F 5480          pea       15
00003116  4878 28F6 5481          pea       _UnitIRQ.L
0000311A  4E92      5482          jsr       (A2)
0000311C  504F      5483          addq.w    #8,A7
                    5484   ; InstallExceptionHandler(Check, 24);                            // install spurious IRQ exception handler
0000311E  4878 0018 5485          pea       24
00003122  4878 28CC 5486          pea       _Check.L
00003126  4E92      5487          jsr       (A2)
00003128  504F      5488          addq.w    #8,A7
                    5489   ; FlushKeyboard();                        // dump unread characters from keyboard
0000312A  4EB8 0BA6 5490          jsr       _FlushKeyboard
                    5491   ; TraceException = 0;                     // clear trace exception port to remove any software generated single step/trace
0000312E  4239 0040 5492          clr.b     4194314
00003132  000A      
                    5493   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5494   ; while (((char)(PortB & 0x02)) == (char)(0x02)) {
                    5495   main_7:
00003134  1039 0040 5496          move.b    4194306,D0
00003138  0002      
0000313A  C03C 0002 5497          and.b     #2,D0
0000313E  0C00 0002 5498          cmp.b     #2,D0
00003142  662A      5499          bne.s     main_9
                    5500   ; LoadFromFlashChip();
00003144  4EB8 1440 5501          jsr       _LoadFromFlashChip
                    5502   ; printf("\r\nRunning.....");
00003148  4879 0000 5503          pea       @m68kde~1_165.L
0000314C  50E0      
0000314E  4E93      5504          jsr       (A3)
00003150  584F      5505          addq.w    #4,A7
                    5506   ; Oline1("Running.....");
00003152  4879 0000 5507          pea       @m68kde~1_166.L
00003156  50F0      
00003158  4EB8 0A02 5508          jsr       _Oline1
0000315C  584F      5509          addq.w    #4,A7
                    5510   ; GoFlag = 1;
0000315E  23FC 0000 5511          move.l    #1,_GoFlag.L
00003162  0001 0803 
00003166  00DC      
                    5512   ; go();
00003168  4EB8 08B8 5513          jsr       _go
0000316C  60C6      5514          bra       main_7
                    5515   main_9:
                    5516   ; }
                    5517   ; // otherwise start the debug monitor
                    5518   ; Oline0(BugMessage);
0000316E  2F03      5519          move.l    D3,-(A7)
00003170  4EB8 09D4 5520          jsr       _Oline0
00003174  584F      5521          addq.w    #4,A7
                    5522   ; Oline1("By: PJ Davies");
00003176  4879 0000 5523          pea       @m68kde~1_167.L
0000317A  50FE      
0000317C  4EB8 0A02 5524          jsr       _Oline1
00003180  584F      5525          addq.w    #4,A7
                    5526   ; printf("\r\nVictor Sheung, Mason Duan");
00003182  4879 0000 5527          pea       @m68kde~1_168.L
00003186  510C      
00003188  4E93      5528          jsr       (A3)
0000318A  584F      5529          addq.w    #4,A7
                    5530   ; printf("\r\n53176153, 19946383");
0000318C  4879 0000 5531          pea       @m68kde~1_169.L
00003190  5128      
00003192  4E93      5532          jsr       (A3)
00003194  584F      5533          addq.w    #4,A7
                    5534   ; printf("\r\n%s", BugMessage);
00003196  2F03      5535          move.l    D3,-(A7)
00003198  4879 0000 5536          pea       @m68kde~1_170.L
0000319C  513E      
0000319E  4E93      5537          jsr       (A3)
000031A0  504F      5538          addq.w    #8,A7
                    5539   ; printf("\r\n%s", CopyrightMessage);
000031A2  2F2E FFFC 5540          move.l    -4(A6),-(A7)
000031A6  4879 0000 5541          pea       @m68kde~1_170.L
000031AA  513E      
000031AC  4E93      5542          jsr       (A3)
000031AE  504F      5543          addq.w    #8,A7
                    5544   ; menu();
000031B0  4EB8 2560 5545          jsr       _menu
000031B4  4CDF 0C0C 5546          movem.l   (A7)+,D2/D3/A2/A3
000031B8  4E5E      5547          unlk      A6
000031BA  4E75      5548          rts
                    5549   ; }
                    5550   _strcpy:
000031BC  206F 0004 5551          move.l    (4,A7),A0
000031C0  226F 0008 5552          move.l    (8,A7),A1
000031C4  2008      5553          move.l    A0,D0
                    5554   strcpy_1:
000031C6  10D9      5555          move.b    (A1)+,(A0)+
000031C8  66FC      5556          bne       strcpy_1
000031CA  4E75      5557          rts
                    5558   ULDIV:
000031CC  4E56 0000 5559          link    A6,#0
000031D0  48E7 C000 5560          movem.l D0/D1,-(A7)
000031D4  222E 0008 5561          move.l  8(A6),D1
000031D8  202E 000C 5562          move.l  12(A6),D0
000031DC  6036      5563          bra.s   ldiv_3
                    5564   LDIV:
000031DE  4E56 0000 5565          link    A6,#0
000031E2  48E7 C000 5566          movem.l D0/D1,-(A7)
000031E6  222E 0008 5567          move.l  8(A6),D1
000031EA  202E 000C 5568          move.l  12(A6),D0
000031EE  4A80      5569          tst.l   D0
000031F0  6A0E      5570          bpl.s   ldiv_1
000031F2  4480      5571          neg.l   D0
000031F4  4A81      5572          tst.l   D1
000031F6  6A14      5573          bpl.s   ldiv_2
000031F8  4481      5574          neg.l   D1
000031FA  612A      5575          bsr.s   dodiv
000031FC  4481      5576          neg.l   D1
000031FE  6016      5577          bra.s   ldiv_4
                    5578   ldiv_1:
00003200  4A81      5579          tst.l   D1
00003202  6A10      5580          bpl.s   ldiv_3
00003204  4481      5581          neg.l   D1
00003206  611E      5582          bsr.s   dodiv
00003208  4480      5583          neg.l   D0
0000320A  600A      5584          bra.s   ldiv_4
                    5585   ldiv_2:
0000320C  6118      5586          bsr.s   dodiv
0000320E  4480      5587          neg.l   D0
00003210  4481      5588          neg.l   D1
00003212  6002      5589          bra.s   ldiv_4
                    5590   ldiv_3:
00003214  6110      5591          bsr.s   dodiv
                    5592   ldiv_4:
00003216  2D40 0008 5593          move.l  D0,8(A6)
0000321A  2D41 000C 5594          move.l  D1,12(A6)
0000321E  4CDF 0003 5595          movem.l (A7)+,D0/D1
00003222  4E5E      5596          unlk    A6
00003224  4E75      5597          rts
                    5598   dodiv:
00003226  0C81 0000 5599          cmpi.l  #$FFFF,D1
0000322A  FFFF      
0000322C  6236      5600          bhi.s   dodiv_2
0000322E  0C80 0000 5601          cmpi.l  #$FFFF,D0
00003232  FFFF      
00003234  6210      5602          bhi.s   dodiv_1
00003236  80C1      5603          divu    D1,D0
00003238  2200      5604          move.l  D0,D1
0000323A  4241      5605          clr.w   D1
0000323C  4841      5606          swap    D1
0000323E  0280 0000 5607          andi.l  #$FFFF,D0
00003242  FFFF      
00003244  4E75      5608          rts
                    5609   dodiv_1:
00003246  48A7 A000 5610          movem.w D0/D2,-(A7)
0000324A  4240      5611          clr.w   D0
0000324C  4840      5612          swap    D0
0000324E  80C1      5613          divu    D1,D0
00003250  3400      5614          move.w  D0,D2
00003252  301F      5615          move.w  (A7)+,D0
00003254  80C1      5616          divu    D1,D0
00003256  4840      5617          swap    D0
00003258  4281      5618          clr.l   D1
0000325A  3200      5619          move.w  D0,D1
0000325C  3002      5620          move.w  D2,D0
0000325E  4840      5621          swap    D0
00003260  341F      5622          move.w  (A7)+,D2
00003262  4E75      5623          rts
                    5624   dodiv_2:
00003264  48E7 3800 5625          movem.l D2/D3/D4,-(A7)
00003268  2401      5626          move.l  D1,D2
0000326A  4242      5627          clr.w   D2
0000326C  4842      5628          swap    D2
0000326E  5282      5629          addq.l  #1,D2
00003270  2600      5630          move.l  D0,D3
00003272  2801      5631          move.l  D1,D4
00003274  2202      5632          move.l  D2,D1
00003276  61CE      5633          bsr.s   dodiv_1
00003278  2204      5634          move.l  D4,D1
0000327A  82C2      5635          divu    D2,D1
0000327C  80C1      5636          divu    D1,D0
0000327E  0280 0000 5637          andi.l  #$FFFF,D0
00003282  FFFF      
                    5638   dodiv_3:
00003284  2204      5639          move.l  D4,D1
00003286  2404      5640          move.l  D4,D2
00003288  4842      5641          swap    D2
0000328A  C2C0      5642          mulu    D0,D1
0000328C  C4C0      5643          mulu    D0,D2
0000328E  4842      5644          swap    D2
00003290  D282      5645          add.l   D2,D1
00003292  9283      5646          sub.l   D3,D1
00003294  620A      5647          bhi.s   dodiv_4
00003296  4481      5648          neg.l   D1
00003298  B881      5649          cmp.l   D1,D4
0000329A  6208      5650          bhi.s   dodiv_5
0000329C  5280      5651          addq.l  #1,D0
0000329E  60E4      5652          bra.s   dodiv_3
                    5653   dodiv_4:
000032A0  5380      5654          subq.l  #1,D0
000032A2  60E0      5655          bra.s   dodiv_3
                    5656   dodiv_5:
000032A4  4CDF 001C 5657          movem.l (A7)+,D2/D3/D4
000032A8  4E75      5658          rts
                    5659   _putch:
000032AA  4E56 0000 5660          link      A6,#0
000032AE  48E7 2000 5661          movem.l   D2,-(A7)
000032B2  242E 0008 5662          move.l    8(A6),D2
000032B6  0C82 0000 5663          cmp.l     #10,D2
000032BA  000A      
000032BC  660A      5664          bne.s     putch_1
000032BE  4878 000D 5665          pea       13
000032C2  6100 D878 5666          bsr       __putch
000032C6  584F      5667          addq.w    #4,A7
                    5668   putch_1:
000032C8  2F02      5669          move.l    D2,-(A7)
000032CA  6100 D870 5670          bsr       __putch
000032CE  584F      5671          addq.w    #4,A7
000032D0  2002      5672          move.l    D2,D0
000032D2  4CDF 0004 5673          movem.l   (A7)+,D2
000032D6  4E5E      5674          unlk      A6
000032D8  4E75      5675          rts
                    5676   _getch:
000032DA  48E7 2000 5677          movem.l   D2,-(A7)
000032DE  2439 0803 5678          move.l    __ungetbuf,D2
000032E2  00C0      
000032E4  2039 0803 5679          move.l    __ungetbuf,D0
000032E8  00C0      
000032EA  0C80 FFFF 5680          cmp.l     #-1,D0
000032EE  FFFF      
000032F0  670C      5681          beq.s     getch_1
000032F2  23FC FFFF 5682          move.l    #-1,__ungetbuf
000032F6  FFFF 0803 
000032FA  00C0      
000032FC  6010      5683          bra.s     getch_3
                    5684   getch_1:
000032FE  6100 D868 5685          bsr       __getch
00003302  2400      5686          move.l    D0,D2
00003304  0C80 0000 5687          cmp.l     #13,D0
00003308  000D      
0000330A  6602      5688          bne.s     getch_3
0000330C  740A      5689          moveq     #10,D2
                    5690   getch_3:
0000330E  2002      5691          move.l    D2,D0
00003310  4CDF 0004 5692          movem.l   (A7)+,D2
00003314  4E75      5693          rts
                    5694   _tolower:
00003316  4E56 0000 5695          link      A6,#0
0000331A  48E7 2000 5696          movem.l   D2,-(A7)
0000331E  242E 0008 5697          move.l    8(A6),D2
00003322  0C82 0000 5698          cmp.l     #65,D2
00003326  0041      
00003328  6D0E      5699          blt.s     tolower_1
0000332A  0C82 0000 5700          cmp.l     #90,D2
0000332E  005A      
00003330  6E06      5701          bgt.s     tolower_1
00003332  84BC 0000 5702          or.l      #32,D2
00003336  0020      
                    5703   tolower_1:
00003338  2002      5704          move.l    D2,D0
0000333A  4CDF 0004 5705          movem.l   (A7)+,D2
0000333E  4E5E      5706          unlk      A6
00003340  4E75      5707          rts
                    5708   _sprintf:
00003342  4E56 FFFC 5709          link      A6,#-4
00003346  48E7 2000 5710          movem.l   D2,-(A7)
0000334A  41EE 000C 5711          lea       12(A6),A0
0000334E  5848      5712          addq.w    #4,A0
00003350  2408      5713          move.l    A0,D2
00003352  2F02      5714          move.l    D2,-(A7)
00003354  2F2E 000C 5715          move.l    12(A6),-(A7)
00003358  2F2E 0008 5716          move.l    8(A6),-(A7)
0000335C  6100 013E 5717          bsr       _vsprintf
00003360  DEFC 000C 5718          add.w     #12,A7
00003364  2D40 FFFC 5719          move.l    D0,-4(A6)
00003368  4282      5720          clr.l     D2
0000336A  202E FFFC 5721          move.l    -4(A6),D0
0000336E  4CDF 0004 5722          movem.l   (A7)+,D2
00003372  4E5E      5723          unlk      A6
00003374  4E75      5724          rts
                    5725   _strcat:
00003376  206F 0004 5726          move.l    (4,A7),A0	
0000337A  226F 0008 5727          move.l    (8,A7),A1	
0000337E  2008      5728          move.l    A0,D0		
                    5729   strcat_0:
00003380  4A18      5730          tst.b     (A0)+
00003382  66FC      5731          bne       strcat_0
00003384  5348      5732          subq      #1,A0
                    5733   strcat_1:
00003386  10D9      5734          move.b    (A1)+,(A0)+
00003388  66FC      5735          bne       strcat_1
0000338A  4E75      5736          rts
                    5737   _toupper:
0000338C  4E56 0000 5738          link      A6,#0
00003390  48E7 2000 5739          movem.l   D2,-(A7)
00003394  242E 0008 5740          move.l    8(A6),D2
00003398  0C82 0000 5741          cmp.l     #97,D2
0000339C  0061      
0000339E  6D0E      5742          blt.s     toupper_1
000033A0  0C82 0000 5743          cmp.l     #122,D2
000033A4  007A      
000033A6  6E06      5744          bgt.s     toupper_1
000033A8  C4BC 0000 5745          and.l     #95,D2
000033AC  005F      
                    5746   toupper_1:
000033AE  2002      5747          move.l    D2,D0
000033B0  4CDF 0004 5748          movem.l   (A7)+,D2
000033B4  4E5E      5749          unlk      A6
000033B6  4E75      5750          rts
                    5751   _printf:
000033B8  4E56 FFFC 5752          link      A6,#-4
000033BC  48E7 2000 5753          movem.l   D2,-(A7)
000033C0  41EE 0008 5754          lea       8(A6),A0
000033C4  5848      5755          addq.w    #4,A0
000033C6  2408      5756          move.l    A0,D2
000033C8  2F02      5757          move.l    D2,-(A7)
000033CA  2F2E 0008 5758          move.l    8(A6),-(A7)
000033CE  42A7      5759          clr.l     -(A7)
000033D0  6100 00CA 5760          bsr       _vsprintf
000033D4  DEFC 000C 5761          add.w     #12,A7
000033D8  2D40 FFFC 5762          move.l    D0,-4(A6)
000033DC  4282      5763          clr.l     D2
000033DE  202E FFFC 5764          move.l    -4(A6),D0
000033E2  4CDF 0004 5765          movem.l   (A7)+,D2
000033E6  4E5E      5766          unlk      A6
000033E8  4E75      5767          rts
                    5768   @vsprintf_copy:
000033EA  4E56 0000 5769          link      A6,#0
000033EE  206E 0008 5770          move.l    8(A6),A0
000033F2  4A90      5771          tst.l     (A0)
000033F4  6710      5772          beq.s     @vsprintf_copy_1
000033F6  202E 000C 5773          move.l    12(A6),D0
000033FA  206E 0008 5774          move.l    8(A6),A0
000033FE  2250      5775          move.l    (A0),A1
00003400  5290      5776          addq.l    #1,(A0)
00003402  1280      5777          move.b    D0,(A1)
00003404  600A      5778          bra.s     @vsprintf_copy_2
                    5779   @vsprintf_copy_1:
00003406  2F2E 000C 5780          move.l    12(A6),-(A7)
0000340A  6100 FE9E 5781          bsr       _putch
0000340E  584F      5782          addq.w    #4,A7
                    5783   @vsprintf_copy_2:
00003410  4E5E      5784          unlk      A6
00003412  4E75      5785          rts
                    5786   @vsprintf_getval:
00003414  4E56 0000 5787          link      A6,#0
00003418  48E7 3000 5788          movem.l   D2/D3,-(A7)
0000341C  242E 0008 5789          move.l    8(A6),D2
00003420  4283      5790          clr.l     D3
00003422  2042      5791          move.l    D2,A0
00003424  2050      5792          move.l    (A0),A0
00003426  1010      5793          move.b    (A0),D0
00003428  4880      5794          ext.w     D0
0000342A  48C0      5795          ext.l     D0
0000342C  0C80 0000 5796          cmp.l     #42,D0
00003430  002A      
00003432  6612      5797          bne.s     @vsprintf_getval_1
00003434  206E 000C 5798          move.l    12(A6),A0
00003438  2250      5799          move.l    (A0),A1
0000343A  5890      5800          addq.l    #4,(A0)
0000343C  2611      5801          move.l    (A1),D3
0000343E  2042      5802          move.l    D2,A0
00003440  5290      5803          addq.l    #1,(A0)
00003442  6000 004E 5804          bra       @vsprintf_getval_5
                    5805   @vsprintf_getval_1:
00003446  2042      5806          move.l    D2,A0
00003448  2050      5807          move.l    (A0),A0
0000344A  1010      5808          move.b    (A0),D0
0000344C  4880      5809          ext.w     D0
0000344E  48C0      5810          ext.l     D0
00003450  0C80 0000 5811          cmp.l     #48,D0
00003454  0030      
00003456  6D00 003A 5812          blt       @vsprintf_getval_5
0000345A  2042      5813          move.l    D2,A0
0000345C  2050      5814          move.l    (A0),A0
0000345E  1010      5815          move.b    (A0),D0
00003460  4880      5816          ext.w     D0
00003462  48C0      5817          ext.l     D0
00003464  0C80 0000 5818          cmp.l     #57,D0
00003468  0039      
0000346A  6E26      5819          bgt.s     @vsprintf_getval_5
0000346C  2F03      5820          move.l    D3,-(A7)
0000346E  4878 000A 5821          pea       10
00003472  6100 07F4 5822          bsr       LMUL
00003476  2017      5823          move.l    (A7),D0
00003478  504F      5824          addq.w    #8,A7
0000347A  2042      5825          move.l    D2,A0
0000347C  2250      5826          move.l    (A0),A1
0000347E  5290      5827          addq.l    #1,(A0)
00003480  1211      5828          move.b    (A1),D1
00003482  4881      5829          ext.w     D1
00003484  48C1      5830          ext.l     D1
00003486  D081      5831          add.l     D1,D0
00003488  0480 0000 5832          sub.l     #48,D0
0000348C  0030      
0000348E  2600      5833          move.l    D0,D3
00003490  60B4      5834          bra       @vsprintf_getval_1
                    5835   @vsprintf_getval_5:
00003492  2003      5836          move.l    D3,D0
00003494  4CDF 000C 5837          movem.l   (A7)+,D2/D3
00003498  4E5E      5838          unlk      A6
0000349A  4E75      5839          rts
                    5840   _vsprintf:
0000349C  4E56 FFCC 5841          link      A6,#-52
000034A0  48E7 3F3C 5842          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000034A4  45EE 0008 5843          lea       8(A6),A2
000034A8  47F8 33EA 5844          lea       @vsprintf_copy,A3
000034AC  49F9 0000 5845          lea       _ultoa,A4
000034B0  3BF4      
000034B2  4286      5846          clr.l     D6
                    5847   vsprintf_1:
000034B4  206E 000C 5848          move.l    12(A6),A0
000034B8  4A10      5849          tst.b     (A0)
000034BA  6700 0624 5850          beq       vsprintf_3
000034BE  206E 000C 5851          move.l    12(A6),A0
000034C2  1010      5852          move.b    (A0),D0
000034C4  4880      5853          ext.w     D0
000034C6  48C0      5854          ext.l     D0
000034C8  0C80 0000 5855          cmp.l     #37,D0
000034CC  0025      
000034CE  671C      5856          beq.s     vsprintf_4
000034D0  206E 000C 5857          move.l    12(A6),A0
000034D4  52AE 000C 5858          addq.l    #1,12(A6)
000034D8  1210      5859          move.b    (A0),D1
000034DA  4881      5860          ext.w     D1
000034DC  48C1      5861          ext.l     D1
000034DE  2F01      5862          move.l    D1,-(A7)
000034E0  2F0A      5863          move.l    A2,-(A7)
000034E2  4E93      5864          jsr       (A3)
000034E4  504F      5865          addq.w    #8,A7
000034E6  5286      5866          addq.l    #1,D6
000034E8  6000 05F2 5867          bra       vsprintf_2
                    5868   vsprintf_4:
000034EC  52AE 000C 5869          addq.l    #1,12(A6)
000034F0  422E FFD3 5870          clr.b     -45(A6)
000034F4  422E FFD2 5871          clr.b     -46(A6)
000034F8  422E FFD0 5872          clr.b     -48(A6)
000034FC  422E FFCF 5873          clr.b     -49(A6)
00003500  422E FFCE 5874          clr.b     -50(A6)
00003504  422E FFCD 5875          clr.b     -51(A6)
00003508  42AE FFFC 5876          clr.l     -4(A6)
0000350C  7AFF      5877          moveq     #-1,D5
0000350E  41EE FFDC 5878          lea       -36(A6),A0
00003512  2608      5879          move.l    A0,D3
00003514  2408      5880          move.l    A0,D2
                    5881   vsprintf_6:
00003516  206E 000C 5882          move.l    12(A6),A0
0000351A  1010      5883          move.b    (A0),D0
0000351C  4880      5884          ext.w     D0
0000351E  48C0      5885          ext.l     D0
00003520  0C80 0000 5886          cmp.l     #43,D0
00003524  002B      
00003526  6730      5887          beq.s     vsprintf_12
00003528  6E18      5888          bgt.s     vsprintf_15
0000352A  0C80 0000 5889          cmp.l     #35,D0
0000352E  0023      
00003530  6700 003E 5890          beq       vsprintf_14
00003534  6E00 0046 5891          bgt       vsprintf_9
00003538  0C80 0000 5892          cmp.l     #32,D0
0000353C  0020      
0000353E  6724      5893          beq.s     vsprintf_13
00003540  603A      5894          bra.s     vsprintf_9
                    5895   vsprintf_15:
00003542  0C80 0000 5896          cmp.l     #45,D0
00003546  002D      
00003548  6702      5897          beq.s     vsprintf_11
0000354A  6030      5898          bra.s     vsprintf_9
                    5899   vsprintf_11:
0000354C  1D7C 0001 5900          move.b    #1,-51(A6)
00003550  FFCD      
00003552  52AE 000C 5901          addq.l    #1,12(A6)
00003556  6026      5902          bra.s     vsprintf_7
                    5903   vsprintf_12:
00003558  1D7C 0001 5904          move.b    #1,-50(A6)
0000355C  FFCE      
0000355E  52AE 000C 5905          addq.l    #1,12(A6)
00003562  601A      5906          bra.s     vsprintf_7
                    5907   vsprintf_13:
00003564  1D7C 0001 5908          move.b    #1,-49(A6)
00003568  FFCF      
0000356A  52AE 000C 5909          addq.l    #1,12(A6)
0000356E  600E      5910          bra.s     vsprintf_7
                    5911   vsprintf_14:
00003570  1D7C 0001 5912          move.b    #1,-48(A6)
00003574  FFD0      
00003576  52AE 000C 5913          addq.l    #1,12(A6)
0000357A  6002      5914          bra.s     vsprintf_7
                    5915   vsprintf_9:
0000357C  6002      5916          bra.s     vsprintf_8
                    5917   vsprintf_7:
0000357E  6096      5918          bra       vsprintf_6
                    5919   vsprintf_8:
00003580  206E 000C 5920          move.l    12(A6),A0
00003584  1010      5921          move.b    (A0),D0
00003586  4880      5922          ext.w     D0
00003588  48C0      5923          ext.l     D0
0000358A  0C80 0000 5924          cmp.l     #48,D0
0000358E  0030      
00003590  660A      5925          bne.s     vsprintf_16
00003592  52AE 000C 5926          addq.l    #1,12(A6)
00003596  1D7C 0001 5927          move.b    #1,-46(A6)
0000359A  FFD2      
                    5928   vsprintf_16:
0000359C  486E 0010 5929          pea       16(A6)
000035A0  486E 000C 5930          pea       12(A6)
000035A4  6100 FE6E 5931          bsr       @vsprintf_getval
000035A8  504F      5932          addq.w    #8,A7
000035AA  2A40      5933          move.l    D0,A5
000035AC  206E 000C 5934          move.l    12(A6),A0
000035B0  1010      5935          move.b    (A0),D0
000035B2  4880      5936          ext.w     D0
000035B4  48C0      5937          ext.l     D0
000035B6  0C80 0000 5938          cmp.l     #46,D0
000035BA  002E      
000035BC  6614      5939          bne.s     vsprintf_18
000035BE  52AE 000C 5940          addq.l    #1,12(A6)
000035C2  486E 0010 5941          pea       16(A6)
000035C6  486E 000C 5942          pea       12(A6)
000035CA  6100 FE48 5943          bsr       @vsprintf_getval
000035CE  504F      5944          addq.w    #8,A7
000035D0  2A00      5945          move.l    D0,D5
                    5946   vsprintf_18:
000035D2  206E 000C 5947          move.l    12(A6),A0
000035D6  1010      5948          move.b    (A0),D0
000035D8  4880      5949          ext.w     D0
000035DA  48C0      5950          ext.l     D0
000035DC  0C80 0000 5951          cmp.l     #108,D0
000035E0  006C      
000035E2  660A      5952          bne.s     vsprintf_20
000035E4  52AE 000C 5953          addq.l    #1,12(A6)
000035E8  1D7C 0001 5954          move.b    #1,-45(A6)
000035EC  FFD3      
                    5955   vsprintf_20:
000035EE  206E 000C 5956          move.l    12(A6),A0
000035F2  1010      5957          move.b    (A0),D0
000035F4  4880      5958          ext.w     D0
000035F6  48C0      5959          ext.l     D0
000035F8  0C80 0000 5960          cmp.l     #111,D0
000035FC  006F      
000035FE  6700 00D4 5961          beq       vsprintf_27
00003602  6E34      5962          bgt.s     vsprintf_33
00003604  0C80 0000 5963          cmp.l     #100,D0
00003608  0064      
0000360A  6700 0054 5964          beq       vsprintf_24
0000360E  6E1C      5965          bgt.s     vsprintf_34
00003610  0C80 0000 5966          cmp.l     #99,D0
00003614  0063      
00003616  6700 012C 5967          beq       vsprintf_30
0000361A  6E00 016A 5968          bgt       vsprintf_22
0000361E  0C80 0000 5969          cmp.l     #88,D0
00003622  0058      
00003624  6700 00E6 5970          beq       vsprintf_28
00003628  6000 015C 5971          bra       vsprintf_22
                    5972   vsprintf_34:
0000362C  0C80 0000 5973          cmp.l     #105,D0
00003630  0069      
00003632  672C      5974          beq.s     vsprintf_24
00003634  6000 0150 5975          bra       vsprintf_22
                    5976   vsprintf_33:
00003638  0C80 0000 5977          cmp.l     #117,D0
0000363C  0075      
0000363E  6700 005C 5978          beq       vsprintf_26
00003642  6E0E      5979          bgt.s     vsprintf_35
00003644  0C80 0000 5980          cmp.l     #115,D0
00003648  0073      
0000364A  6700 011C 5981          beq       vsprintf_31
0000364E  6000 0136 5982          bra       vsprintf_22
                    5983   vsprintf_35:
00003652  0C80 0000 5984          cmp.l     #120,D0
00003656  0078      
00003658  6700 00B2 5985          beq       vsprintf_28
0000365C  6000 0128 5986          bra       vsprintf_22
                    5987   vsprintf_24:
00003660  4A2E FFD3 5988          tst.b     -45(A6)
00003664  671A      5989          beq.s     vsprintf_36
00003666  4878 000A 5990          pea       10
0000366A  2F03      5991          move.l    D3,-(A7)
0000366C  206E 0010 5992          move.l    16(A6),A0
00003670  58AE 0010 5993          addq.l    #4,16(A6)
00003674  2F10      5994          move.l    (A0),-(A7)
00003676  6100 04F8 5995          bsr       _ltoa
0000367A  DEFC 000C 5996          add.w     #12,A7
0000367E  6018      5997          bra.s     vsprintf_37
                    5998   vsprintf_36:
00003680  4878 000A 5999          pea       10
00003684  2F03      6000          move.l    D3,-(A7)
00003686  206E 0010 6001          move.l    16(A6),A0
0000368A  58AE 0010 6002          addq.l    #4,16(A6)
0000368E  2F10      6003          move.l    (A0),-(A7)
00003690  6100 04DE 6004          bsr       _ltoa
00003694  DEFC 000C 6005          add.w     #12,A7
                    6006   vsprintf_37:
00003698  6000 00FA 6007          bra       vsprintf_23
                    6008   vsprintf_26:
0000369C  4A2E FFD3 6009          tst.b     -45(A6)
000036A0  6718      6010          beq.s     vsprintf_38
000036A2  4878 000A 6011          pea       10
000036A6  2F03      6012          move.l    D3,-(A7)
000036A8  206E 0010 6013          move.l    16(A6),A0
000036AC  58AE 0010 6014          addq.l    #4,16(A6)
000036B0  2F10      6015          move.l    (A0),-(A7)
000036B2  4E94      6016          jsr       (A4)
000036B4  DEFC 000C 6017          add.w     #12,A7
000036B8  6016      6018          bra.s     vsprintf_39
                    6019   vsprintf_38:
000036BA  4878 000A 6020          pea       10
000036BE  2F03      6021          move.l    D3,-(A7)
000036C0  206E 0010 6022          move.l    16(A6),A0
000036C4  58AE 0010 6023          addq.l    #4,16(A6)
000036C8  2F10      6024          move.l    (A0),-(A7)
000036CA  4E94      6025          jsr       (A4)
000036CC  DEFC 000C 6026          add.w     #12,A7
                    6027   vsprintf_39:
000036D0  6000 00C2 6028          bra       vsprintf_23
                    6029   vsprintf_27:
000036D4  4A2E FFD3 6030          tst.b     -45(A6)
000036D8  6718      6031          beq.s     vsprintf_40
000036DA  4878 0008 6032          pea       8
000036DE  2F03      6033          move.l    D3,-(A7)
000036E0  206E 0010 6034          move.l    16(A6),A0
000036E4  58AE 0010 6035          addq.l    #4,16(A6)
000036E8  2F10      6036          move.l    (A0),-(A7)
000036EA  4E94      6037          jsr       (A4)
000036EC  DEFC 000C 6038          add.w     #12,A7
000036F0  6016      6039          bra.s     vsprintf_41
                    6040   vsprintf_40:
000036F2  4878 0008 6041          pea       8
000036F6  2F03      6042          move.l    D3,-(A7)
000036F8  206E 0010 6043          move.l    16(A6),A0
000036FC  58AE 0010 6044          addq.l    #4,16(A6)
00003700  2F10      6045          move.l    (A0),-(A7)
00003702  4E94      6046          jsr       (A4)
00003704  DEFC 000C 6047          add.w     #12,A7
                    6048   vsprintf_41:
00003708  6000 008A 6049          bra       vsprintf_23
                    6050   vsprintf_28:
0000370C  4A2E FFD3 6051          tst.b     -45(A6)
00003710  6718      6052          beq.s     vsprintf_42
00003712  4878 0010 6053          pea       16
00003716  2F03      6054          move.l    D3,-(A7)
00003718  206E 0010 6055          move.l    16(A6),A0
0000371C  58AE 0010 6056          addq.l    #4,16(A6)
00003720  2F10      6057          move.l    (A0),-(A7)
00003722  4E94      6058          jsr       (A4)
00003724  DEFC 000C 6059          add.w     #12,A7
00003728  6016      6060          bra.s     vsprintf_43
                    6061   vsprintf_42:
0000372A  4878 0010 6062          pea       16
0000372E  2F03      6063          move.l    D3,-(A7)
00003730  206E 0010 6064          move.l    16(A6),A0
00003734  58AE 0010 6065          addq.l    #4,16(A6)
00003738  2F10      6066          move.l    (A0),-(A7)
0000373A  4E94      6067          jsr       (A4)
0000373C  DEFC 000C 6068          add.w     #12,A7
                    6069   vsprintf_43:
00003740  6000 0052 6070          bra       vsprintf_23
                    6071   vsprintf_30:
00003744  206E 0010 6072          move.l    16(A6),A0
00003748  58AE 0010 6073          addq.l    #4,16(A6)
0000374C  2010      6074          move.l    (A0),D0
0000374E  2042      6075          move.l    D2,A0
00003750  5282      6076          addq.l    #1,D2
00003752  1080      6077          move.b    D0,(A0)
00003754  2042      6078          move.l    D2,A0
00003756  4210      6079          clr.b     (A0)
00003758  200D      6080          move.l    A5,D0
0000375A  6704      6081          beq.s     vsprintf_44
0000375C  200D      6082          move.l    A5,D0
0000375E  6002      6083          bra.s     vsprintf_45
                    6084   vsprintf_44:
00003760  7001      6085          moveq     #1,D0
                    6086   vsprintf_45:
00003762  2A00      6087          move.l    D0,D5
00003764  6000 002E 6088          bra       vsprintf_23
                    6089   vsprintf_31:
00003768  206E 0010 6090          move.l    16(A6),A0
0000376C  58AE 0010 6091          addq.l    #4,16(A6)
00003770  2610      6092          move.l    (A0),D3
00003772  0C85 FFFF 6093          cmp.l     #-1,D5
00003776  FFFF      
00003778  660A      6094          bne.s     vsprintf_46
0000377A  2F03      6095          move.l    D3,-(A7)
0000377C  6100 0578 6096          bsr       _strlen
00003780  584F      6097          addq.w    #4,A7
00003782  2A00      6098          move.l    D0,D5
                    6099   vsprintf_46:
00003784  600E      6100          bra.s     vsprintf_23
                    6101   vsprintf_22:
00003786  206E 000C 6102          move.l    12(A6),A0
0000378A  2242      6103          move.l    D2,A1
0000378C  5282      6104          addq.l    #1,D2
0000378E  1290      6105          move.b    (A0),(A1)
00003790  2042      6106          move.l    D2,A0
00003792  4210      6107          clr.b     (A0)
                    6108   vsprintf_23:
00003794  2F03      6109          move.l    D3,-(A7)
00003796  6100 055E 6110          bsr       _strlen
0000379A  584F      6111          addq.w    #4,A7
0000379C  1800      6112          move.b    D0,D4
0000379E  206E 000C 6113          move.l    12(A6),A0
000037A2  1010      6114          move.b    (A0),D0
000037A4  4880      6115          ext.w     D0
000037A6  48C0      6116          ext.l     D0
000037A8  0C80 0000 6117          cmp.l     #115,D0
000037AC  0073      
000037AE  6618      6118          bne.s     vsprintf_48
000037B0  0C85 0000 6119          cmp.l     #0,D5
000037B4  0000      
000037B6  6D10      6120          blt.s     vsprintf_48
000037B8  4884      6121          ext.w     D4
000037BA  48C4      6122          ext.l     D4
000037BC  B885      6123          cmp.l     D5,D4
000037BE  6F04      6124          ble.s     vsprintf_50
000037C0  1005      6125          move.b    D5,D0
000037C2  6002      6126          bra.s     vsprintf_51
                    6127   vsprintf_50:
000037C4  1004      6128          move.b    D4,D0
                    6129   vsprintf_51:
000037C6  1800      6130          move.b    D0,D4
                    6131   vsprintf_48:
000037C8  206E 000C 6132          move.l    12(A6),A0
000037CC  1010      6133          move.b    (A0),D0
000037CE  4880      6134          ext.w     D0
000037D0  48C0      6135          ext.l     D0
000037D2  0C80 0000 6136          cmp.l     #88,D0
000037D6  0058      
000037D8  6600 0026 6137          bne       vsprintf_56
000037DC  41EE FFDC 6138          lea       -36(A6),A0
000037E0  2408      6139          move.l    A0,D2
                    6140   vsprintf_54:
000037E2  2042      6141          move.l    D2,A0
000037E4  4A10      6142          tst.b     (A0)
000037E6  6718      6143          beq.s     vsprintf_56
000037E8  2042      6144          move.l    D2,A0
000037EA  1210      6145          move.b    (A0),D1
000037EC  4881      6146          ext.w     D1
000037EE  48C1      6147          ext.l     D1
000037F0  2F01      6148          move.l    D1,-(A7)
000037F2  6100 FB98 6149          bsr       _toupper
000037F6  584F      6150          addq.w    #4,A7
000037F8  2042      6151          move.l    D2,A0
000037FA  1080      6152          move.b    D0,(A0)
000037FC  5282      6153          addq.l    #1,D2
000037FE  60E2      6154          bra       vsprintf_54
                    6155   vsprintf_56:
00003800  7E00      6156          moveq     #0,D7
00003802  41EE FFD4 6157          lea       -44(A6),A0
00003806  2408      6158          move.l    A0,D2
00003808  206E 000C 6159          move.l    12(A6),A0
0000380C  1010      6160          move.b    (A0),D0
0000380E  4880      6161          ext.w     D0
00003810  48C0      6162          ext.l     D0
00003812  0C80 0000 6163          cmp.l     #100,D0
00003816  0064      
00003818  6714      6164          beq.s     vsprintf_59
0000381A  206E 000C 6165          move.l    12(A6),A0
0000381E  1010      6166          move.b    (A0),D0
00003820  4880      6167          ext.w     D0
00003822  48C0      6168          ext.l     D0
00003824  0C80 0000 6169          cmp.l     #105,D0
00003828  0069      
0000382A  6600 0076 6170          bne       vsprintf_65
                    6171   vsprintf_59:
0000382E  4A2E FFCE 6172          tst.b     -50(A6)
00003832  6612      6173          bne.s     vsprintf_62
00003834  2043      6174          move.l    D3,A0
00003836  1010      6175          move.b    (A0),D0
00003838  4880      6176          ext.w     D0
0000383A  48C0      6177          ext.l     D0
0000383C  0C80 0000 6178          cmp.l     #45,D0
00003840  002D      
00003842  6600 002E 6179          bne       vsprintf_60
                    6180   vsprintf_62:
00003846  2043      6181          move.l    D3,A0
00003848  1010      6182          move.b    (A0),D0
0000384A  4880      6183          ext.w     D0
0000384C  48C0      6184          ext.l     D0
0000384E  0C80 0000 6185          cmp.l     #45,D0
00003852  002D      
00003854  660E      6186          bne.s     vsprintf_63
00003856  2043      6187          move.l    D3,A0
00003858  5283      6188          addq.l    #1,D3
0000385A  2242      6189          move.l    D2,A1
0000385C  5282      6190          addq.l    #1,D2
0000385E  1290      6191          move.b    (A0),(A1)
00003860  5304      6192          subq.b    #1,D4
00003862  6008      6193          bra.s     vsprintf_64
                    6194   vsprintf_63:
00003864  2042      6195          move.l    D2,A0
00003866  5282      6196          addq.l    #1,D2
00003868  10BC 002B 6197          move.b    #43,(A0)
                    6198   vsprintf_64:
0000386C  5287      6199          addq.l    #1,D7
0000386E  6000 0032 6200          bra       vsprintf_65
                    6201   vsprintf_60:
00003872  4A2E FFCF 6202          tst.b     -49(A6)
00003876  6700 002A 6203          beq       vsprintf_65
0000387A  2043      6204          move.l    D3,A0
0000387C  1010      6205          move.b    (A0),D0
0000387E  4880      6206          ext.w     D0
00003880  48C0      6207          ext.l     D0
00003882  0C80 0000 6208          cmp.l     #45,D0
00003886  002D      
00003888  660E      6209          bne.s     vsprintf_67
0000388A  2043      6210          move.l    D3,A0
0000388C  5283      6211          addq.l    #1,D3
0000388E  2242      6212          move.l    D2,A1
00003890  5282      6213          addq.l    #1,D2
00003892  1290      6214          move.b    (A0),(A1)
00003894  5304      6215          subq.b    #1,D4
00003896  6008      6216          bra.s     vsprintf_68
                    6217   vsprintf_67:
00003898  2042      6218          move.l    D2,A0
0000389A  5282      6219          addq.l    #1,D2
0000389C  10BC 0020 6220          move.b    #32,(A0)
                    6221   vsprintf_68:
000038A0  5287      6222          addq.l    #1,D7
                    6223   vsprintf_65:
000038A2  4A2E FFD0 6224          tst.b     -48(A6)
000038A6  6700 0066 6225          beq       vsprintf_77
000038AA  206E 000C 6226          move.l    12(A6),A0
000038AE  1010      6227          move.b    (A0),D0
000038B0  4880      6228          ext.w     D0
000038B2  48C0      6229          ext.l     D0
000038B4  0C80 0000 6230          cmp.l     #111,D0
000038B8  006F      
000038BA  671A      6231          beq.s     vsprintf_73
000038BC  6E0C      6232          bgt.s     vsprintf_76
000038BE  0C80 0000 6233          cmp.l     #88,D0
000038C2  0058      
000038C4  6710      6234          beq.s     vsprintf_73
000038C6  6000 0046 6235          bra       vsprintf_77
                    6236   vsprintf_76:
000038CA  0C80 0000 6237          cmp.l     #120,D0
000038CE  0078      
000038D0  6704      6238          beq.s     vsprintf_73
000038D2  6000 003A 6239          bra       vsprintf_77
                    6240   vsprintf_73:
000038D6  2042      6241          move.l    D2,A0
000038D8  5282      6242          addq.l    #1,D2
000038DA  10BC 0030 6243          move.b    #48,(A0)
000038DE  5287      6244          addq.l    #1,D7
000038E0  206E 000C 6245          move.l    12(A6),A0
000038E4  1010      6246          move.b    (A0),D0
000038E6  4880      6247          ext.w     D0
000038E8  48C0      6248          ext.l     D0
000038EA  0C80 0000 6249          cmp.l     #120,D0
000038EE  0078      
000038F0  6712      6250          beq.s     vsprintf_79
000038F2  206E 000C 6251          move.l    12(A6),A0
000038F6  1010      6252          move.b    (A0),D0
000038F8  4880      6253          ext.w     D0
000038FA  48C0      6254          ext.l     D0
000038FC  0C80 0000 6255          cmp.l     #88,D0
00003900  0058      
00003902  660A      6256          bne.s     vsprintf_77
                    6257   vsprintf_79:
00003904  2042      6258          move.l    D2,A0
00003906  5282      6259          addq.l    #1,D2
00003908  10BC 0078 6260          move.b    #120,(A0)
0000390C  5287      6261          addq.l    #1,D7
                    6262   vsprintf_77:
0000390E  2042      6263          move.l    D2,A0
00003910  4210      6264          clr.b     (A0)
00003912  206E 000C 6265          move.l    12(A6),A0
00003916  1010      6266          move.b    (A0),D0
00003918  4880      6267          ext.w     D0
0000391A  48C0      6268          ext.l     D0
0000391C  0C80 0000 6269          cmp.l     #105,D0
00003920  0069      
00003922  6700 0076 6270          beq       vsprintf_82
00003926  6E42      6271          bgt.s     vsprintf_93
00003928  0C80 0000 6272          cmp.l     #99,D0
0000392C  0063      
0000392E  6700 0084 6273          beq       vsprintf_96
00003932  6E1C      6274          bgt.s     vsprintf_94
00003934  0C80 0000 6275          cmp.l     #88,D0
00003938  0058      
0000393A  6700 005E 6276          beq       vsprintf_82
0000393E  6E00 0184 6277          bgt       vsprintf_80
00003942  0C80 0000 6278          cmp.l     #69,D0
00003946  0045      
00003948  6700 0050 6279          beq       vsprintf_82
0000394C  6000 0176 6280          bra       vsprintf_80
                    6281   vsprintf_94:
00003950  0C80 0000 6282          cmp.l     #101,D0
00003954  0065      
00003956  6700 0042 6283          beq       vsprintf_82
0000395A  6E00 0168 6284          bgt       vsprintf_80
0000395E  0C80 0000 6285          cmp.l     #100,D0
00003962  0064      
00003964  6734      6286          beq.s     vsprintf_82
00003966  6000 015C 6287          bra       vsprintf_80
                    6288   vsprintf_93:
0000396A  0C80 0000 6289          cmp.l     #117,D0
0000396E  0075      
00003970  6728      6290          beq.s     vsprintf_82
00003972  6E1A      6291          bgt.s     vsprintf_95
00003974  0C80 0000 6292          cmp.l     #115,D0
00003978  0073      
0000397A  6700 0038 6293          beq       vsprintf_96
0000397E  6E00 0144 6294          bgt       vsprintf_80
00003982  0C80 0000 6295          cmp.l     #111,D0
00003986  006F      
00003988  6710      6296          beq.s     vsprintf_82
0000398A  6000 0138 6297          bra       vsprintf_80
                    6298   vsprintf_95:
0000398E  0C80 0000 6299          cmp.l     #120,D0
00003992  0078      
00003994  6704      6300          beq.s     vsprintf_82
00003996  6000 012C 6301          bra       vsprintf_80
                    6302   vsprintf_82:
0000399A  4A2E FFD2 6303          tst.b     -46(A6)
0000399E  6714      6304          beq.s     vsprintf_96
000039A0  4A2E FFCD 6305          tst.b     -51(A6)
000039A4  660E      6306          bne.s     vsprintf_96
000039A6  200D      6307          move.l    A5,D0
000039A8  9087      6308          sub.l     D7,D0
000039AA  4884      6309          ext.w     D4
000039AC  48C4      6310          ext.l     D4
000039AE  9084      6311          sub.l     D4,D0
000039B0  2D40 FFFC 6312          move.l    D0,-4(A6)
                    6313   vsprintf_96:
000039B4  202E FFFC 6314          move.l    -4(A6),D0
000039B8  0C80 0000 6315          cmp.l     #0,D0
000039BC  0000      
000039BE  6C04      6316          bge.s     vsprintf_98
000039C0  42AE FFFC 6317          clr.l     -4(A6)
                    6318   vsprintf_98:
000039C4  4A2E FFCD 6319          tst.b     -51(A6)
000039C8  6600 0030 6320          bne       vsprintf_104
000039CC  4884      6321          ext.w     D4
000039CE  48C4      6322          ext.l     D4
000039D0  2004      6323          move.l    D4,D0
000039D2  D0AE FFFC 6324          add.l     -4(A6),D0
000039D6  D087      6325          add.l     D7,D0
000039D8  1D40 FFD1 6326          move.b    D0,-47(A6)
                    6327   vsprintf_102:
000039DC  102E FFD1 6328          move.b    -47(A6),D0
000039E0  4880      6329          ext.w     D0
000039E2  48C0      6330          ext.l     D0
000039E4  220D      6331          move.l    A5,D1
000039E6  534D      6332          subq.w    #1,A5
000039E8  B081      6333          cmp.l     D1,D0
000039EA  6C0E      6334          bge.s     vsprintf_104
000039EC  4878 0020 6335          pea       32
000039F0  2F0A      6336          move.l    A2,-(A7)
000039F2  4E93      6337          jsr       (A3)
000039F4  504F      6338          addq.w    #8,A7
000039F6  5286      6339          addq.l    #1,D6
000039F8  60E2      6340          bra       vsprintf_102
                    6341   vsprintf_104:
000039FA  41EE FFD4 6342          lea       -44(A6),A0
000039FE  2408      6343          move.l    A0,D2
                    6344   vsprintf_105:
00003A00  2042      6345          move.l    D2,A0
00003A02  4A10      6346          tst.b     (A0)
00003A04  6716      6347          beq.s     vsprintf_107
00003A06  2042      6348          move.l    D2,A0
00003A08  5282      6349          addq.l    #1,D2
00003A0A  1210      6350          move.b    (A0),D1
00003A0C  4881      6351          ext.w     D1
00003A0E  48C1      6352          ext.l     D1
00003A10  2F01      6353          move.l    D1,-(A7)
00003A12  2F0A      6354          move.l    A2,-(A7)
00003A14  4E93      6355          jsr       (A3)
00003A16  504F      6356          addq.w    #8,A7
00003A18  5286      6357          addq.l    #1,D6
00003A1A  60E4      6358          bra       vsprintf_105
                    6359   vsprintf_107:
00003A1C  202E FFFC 6360          move.l    -4(A6),D0
00003A20  1D40 FFD1 6361          move.b    D0,-47(A6)
                    6362   vsprintf_108:
00003A24  102E FFD1 6363          move.b    -47(A6),D0
00003A28  532E FFD1 6364          subq.b    #1,-47(A6)
00003A2C  4A00      6365          tst.b     D0
00003A2E  670E      6366          beq.s     vsprintf_110
00003A30  4878 0030 6367          pea       48
00003A34  2F0A      6368          move.l    A2,-(A7)
00003A36  4E93      6369          jsr       (A3)
00003A38  504F      6370          addq.w    #8,A7
00003A3A  5286      6371          addq.l    #1,D6
00003A3C  60E6      6372          bra       vsprintf_108
                    6373   vsprintf_110:
00003A3E  2043      6374          move.l    D3,A0
00003A40  4A10      6375          tst.b     (A0)
00003A42  6700 0048 6376          beq       vsprintf_113
00003A46  206E 000C 6377          move.l    12(A6),A0
00003A4A  1010      6378          move.b    (A0),D0
00003A4C  4880      6379          ext.w     D0
00003A4E  48C0      6380          ext.l     D0
00003A50  0C80 0000 6381          cmp.l     #115,D0
00003A54  0073      
00003A56  670C      6382          beq.s     vsprintf_116
00003A58  6E18      6383          bgt.s     vsprintf_119
00003A5A  0C80 0000 6384          cmp.l     #99,D0
00003A5E  0063      
00003A60  6702      6385          beq.s     vsprintf_116
00003A62  600E      6386          bra.s     vsprintf_119
                    6387   vsprintf_116:
00003A64  2005      6388          move.l    D5,D0
00003A66  5385      6389          subq.l    #1,D5
00003A68  0C80 0000 6390          cmp.l     #0,D0
00003A6C  0000      
00003A6E  6E02      6391          bgt.s     vsprintf_119
00003A70  6016      6392          bra.s     vsprintf_115
                    6393   vsprintf_119:
00003A72  2043      6394          move.l    D3,A0
00003A74  5283      6395          addq.l    #1,D3
00003A76  1210      6396          move.b    (A0),D1
00003A78  4881      6397          ext.w     D1
00003A7A  48C1      6398          ext.l     D1
00003A7C  2F01      6399          move.l    D1,-(A7)
00003A7E  2F0A      6400          move.l    A2,-(A7)
00003A80  4E93      6401          jsr       (A3)
00003A82  504F      6402          addq.w    #8,A7
00003A84  5286      6403          addq.l    #1,D6
00003A86  6002      6404          bra.s     vsprintf_112
                    6405   vsprintf_115:
00003A88  6002      6406          bra.s     vsprintf_113
                    6407   vsprintf_112:
00003A8A  60B2      6408          bra       vsprintf_110
                    6409   vsprintf_113:
00003A8C  4A2E FFCD 6410          tst.b     -51(A6)
00003A90  6700 0030 6411          beq       vsprintf_125
00003A94  4884      6412          ext.w     D4
00003A96  48C4      6413          ext.l     D4
00003A98  2004      6414          move.l    D4,D0
00003A9A  D0AE FFFC 6415          add.l     -4(A6),D0
00003A9E  D087      6416          add.l     D7,D0
00003AA0  1D40 FFD1 6417          move.b    D0,-47(A6)
                    6418   vsprintf_123:
00003AA4  102E FFD1 6419          move.b    -47(A6),D0
00003AA8  4880      6420          ext.w     D0
00003AAA  48C0      6421          ext.l     D0
00003AAC  220D      6422          move.l    A5,D1
00003AAE  534D      6423          subq.w    #1,A5
00003AB0  B081      6424          cmp.l     D1,D0
00003AB2  6C0E      6425          bge.s     vsprintf_125
00003AB4  4878 0020 6426          pea       32
00003AB8  2F0A      6427          move.l    A2,-(A7)
00003ABA  4E93      6428          jsr       (A3)
00003ABC  504F      6429          addq.w    #8,A7
00003ABE  5386      6430          subq.l    #1,D6
00003AC0  60E2      6431          bra       vsprintf_123
                    6432   vsprintf_125:
00003AC2  6014      6433          bra.s     vsprintf_81
                    6434   vsprintf_80:
00003AC4  206E 000C 6435          move.l    12(A6),A0
00003AC8  1210      6436          move.b    (A0),D1
00003ACA  4881      6437          ext.w     D1
00003ACC  48C1      6438          ext.l     D1
00003ACE  2F01      6439          move.l    D1,-(A7)
00003AD0  2F0A      6440          move.l    A2,-(A7)
00003AD2  4E93      6441          jsr       (A3)
00003AD4  504F      6442          addq.w    #8,A7
00003AD6  5286      6443          addq.l    #1,D6
                    6444   vsprintf_81:
00003AD8  52AE 000C 6445          addq.l    #1,12(A6)
                    6446   vsprintf_2:
00003ADC  6000 F9D6 6447          bra       vsprintf_1
                    6448   vsprintf_3:
00003AE0  4A92      6449          tst.l     (A2)
00003AE2  6710      6450          beq.s     vsprintf_126
00003AE4  4201      6451          clr.b     D1
00003AE6  C2BC 0000 6452          and.l     #255,D1
00003AEA  00FF      
00003AEC  2F01      6453          move.l    D1,-(A7)
00003AEE  2F0A      6454          move.l    A2,-(A7)
00003AF0  4E93      6455          jsr       (A3)
00003AF2  504F      6456          addq.w    #8,A7
                    6457   vsprintf_126:
00003AF4  2006      6458          move.l    D6,D0
00003AF6  4CDF 3CFC 6459          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003AFA  4E5E      6460          unlk      A6
00003AFC  4E75      6461          rts
                    6462   @itoa_convert:
00003AFE  4E56 0000 6463          link      A6,#0
00003B02  48E7 3C00 6464          movem.l   D2/D3/D4/D5,-(A7)
00003B06  242E 0008 6465          move.l    8(A6),D2
00003B0A  262E 0010 6466          move.l    16(A6),D3
00003B0E  2A2E 000C 6467          move.l    12(A6),D5
00003B12  2F05      6468          move.l    D5,-(A7)
00003B14  2F03      6469          move.l    D3,-(A7)
00003B16  6100 F6B4 6470          bsr       ULDIV
00003B1A  202F 0004 6471          move.l    4(A7),D0
00003B1E  504F      6472          addq.w    #8,A7
00003B20  2800      6473          move.l    D0,D4
00003B22  BA83      6474          cmp.l     D3,D5
00003B24  651A      6475          blo.s     @itoa_convert_1
00003B26  2F03      6476          move.l    D3,-(A7)
00003B28  2F05      6477          move.l    D5,-(A7)
00003B2A  2F03      6478          move.l    D3,-(A7)
00003B2C  6100 F69E 6479          bsr       ULDIV
00003B30  2217      6480          move.l    (A7),D1
00003B32  504F      6481          addq.w    #8,A7
00003B34  2F01      6482          move.l    D1,-(A7)
00003B36  2F02      6483          move.l    D2,-(A7)
00003B38  61C4      6484          bsr       @itoa_convert
00003B3A  DEFC 000C 6485          add.w     #12,A7
00003B3E  2400      6486          move.l    D0,D2
                    6487   @itoa_convert_1:
00003B40  0C84 0000 6488          cmp.l     #9,D4
00003B44  0009      
00003B46  6E0A      6489          bgt.s     @itoa_convert_3
00003B48  2004      6490          move.l    D4,D0
00003B4A  0680 0000 6491          add.l     #48,D0
00003B4E  0030      
00003B50  600E      6492          bra.s     @itoa_convert_4
                    6493   @itoa_convert_3:
00003B52  2004      6494          move.l    D4,D0
00003B54  0680 0000 6495          add.l     #97,D0
00003B58  0061      
00003B5A  0480 0000 6496          sub.l     #10,D0
00003B5E  000A      
                    6497   @itoa_convert_4:
00003B60  2042      6498          move.l    D2,A0
00003B62  1080      6499          move.b    D0,(A0)
00003B64  2002      6500          move.l    D2,D0
00003B66  5280      6501          addq.l    #1,D0
00003B68  4CDF 003C 6502          movem.l   (A7)+,D2/D3/D4/D5
00003B6C  4E5E      6503          unlk      A6
00003B6E  4E75      6504          rts
                    6505   _ltoa:
00003B70  4E56 0000 6506          link      A6,#0
00003B74  48E7 3C00 6507          movem.l   D2/D3/D4/D5,-(A7)
00003B78  242E 0008 6508          move.l    8(A6),D2
00003B7C  262E 000C 6509          move.l    12(A6),D3
00003B80  2A2E 0010 6510          move.l    16(A6),D5
00003B84  2803      6511          move.l    D3,D4
00003B86  0C85 0000 6512          cmp.l     #2,D5
00003B8A  0002      
00003B8C  6D08      6513          blt.s     ltoa_3
00003B8E  0C85 0000 6514          cmp.l     #36,D5
00003B92  0024      
00003B94  6F06      6515          ble.s     ltoa_1
                    6516   ltoa_3:
00003B96  2003      6517          move.l    D3,D0
00003B98  6000 0052 6518          bra       ltoa_4
                    6519   ltoa_1:
00003B9C  0C85 0000 6520          cmp.l     #10,D5
00003BA0  000A      
00003BA2  6600 0032 6521          bne       ltoa_5
00003BA6  0C82 0000 6522          cmp.l     #0,D2
00003BAA  0000      
00003BAC  6C28      6523          bge.s     ltoa_5
00003BAE  2002      6524          move.l    D2,D0
00003BB0  4480      6525          neg.l     D0
00003BB2  2400      6526          move.l    D0,D2
00003BB4  0C82 0000 6527          cmp.l     #0,D2
00003BB8  0000      
00003BBA  6C12      6528          bge.s     ltoa_7
00003BBC  4879 0000 6529          pea       @itoa_1
00003BC0  5164      
00003BC2  2F03      6530          move.l    D3,-(A7)
00003BC4  6100 F5F6 6531          bsr       _strcpy
00003BC8  504F      6532          addq.w    #8,A7
00003BCA  2003      6533          move.l    D3,D0
00003BCC  601E      6534          bra.s     ltoa_4
                    6535   ltoa_7:
00003BCE  2044      6536          move.l    D4,A0
00003BD0  5284      6537          addq.l    #1,D4
00003BD2  10BC 002D 6538          move.b    #45,(A0)
                    6539   ltoa_5:
00003BD6  2F05      6540          move.l    D5,-(A7)
00003BD8  2F02      6541          move.l    D2,-(A7)
00003BDA  2F04      6542          move.l    D4,-(A7)
00003BDC  6100 FF20 6543          bsr       @itoa_convert
00003BE0  DEFC 000C 6544          add.w     #12,A7
00003BE4  2800      6545          move.l    D0,D4
00003BE6  2044      6546          move.l    D4,A0
00003BE8  4210      6547          clr.b     (A0)
00003BEA  2003      6548          move.l    D3,D0
                    6549   ltoa_4:
00003BEC  4CDF 003C 6550          movem.l   (A7)+,D2/D3/D4/D5
00003BF0  4E5E      6551          unlk      A6
00003BF2  4E75      6552          rts
                    6553   _ultoa:
00003BF4  4E56 0000 6554          link      A6,#0
00003BF8  48E7 3800 6555          movem.l   D2/D3/D4,-(A7)
00003BFC  262E 0010 6556          move.l    16(A6),D3
00003C00  282E 000C 6557          move.l    12(A6),D4
00003C04  2404      6558          move.l    D4,D2
00003C06  0C83 0000 6559          cmp.l     #2,D3
00003C0A  0002      
00003C0C  6D08      6560          blt.s     ultoa_3
00003C0E  0C83 0000 6561          cmp.l     #36,D3
00003C12  0024      
00003C14  6F04      6562          ble.s     ultoa_1
                    6563   ultoa_3:
00003C16  2004      6564          move.l    D4,D0
00003C18  6018      6565          bra.s     ultoa_4
                    6566   ultoa_1:
00003C1A  2F03      6567          move.l    D3,-(A7)
00003C1C  2F2E 0008 6568          move.l    8(A6),-(A7)
00003C20  2F02      6569          move.l    D2,-(A7)
00003C22  6100 FEDA 6570          bsr       @itoa_convert
00003C26  DEFC 000C 6571          add.w     #12,A7
00003C2A  2400      6572          move.l    D0,D2
00003C2C  2042      6573          move.l    D2,A0
00003C2E  4210      6574          clr.b     (A0)
00003C30  2004      6575          move.l    D4,D0
                    6576   ultoa_4:
00003C32  4CDF 001C 6577          movem.l   (A7)+,D2/D3/D4
00003C36  4E5E      6578          unlk      A6
00003C38  4E75      6579          rts
                    6580   _itoa:
00003C3A  4E56 0000 6581          link      A6,#0
00003C3E  2F2E 0010 6582          move.l    16(A6),-(A7)
00003C42  2F2E 000C 6583          move.l    12(A6),-(A7)
00003C46  2F2E 0008 6584          move.l    8(A6),-(A7)
00003C4A  6100 FF24 6585          bsr       _ltoa
00003C4E  DEFC 000C 6586          add.w     #12,A7
00003C52  4E5E      6587          unlk      A6
00003C54  4E75      6588          rts
                    6589   ULMUL:
00003C56  4E56 0000 6590          link    A6,#0
00003C5A  48E7 C000 6591          movem.l D0/D1,-(A7)
00003C5E  222E 0008 6592          move.l  8(A6),D1
00003C62  202E 000C 6593          move.l  12(A6),D0
00003C66  602C      6594          bra.s   lmul_3
                    6595   LMUL:
00003C68  4E56 0000 6596          link    A6,#0
00003C6C  48E7 C000 6597          movem.l D0/D1,-(A7)
00003C70  222E 0008 6598          move.l  8(A6),D1
00003C74  202E 000C 6599          move.l  12(A6),D0
00003C78  4A80      6600          tst.l   D0
00003C7A  6A0A      6601          bpl.s   lmul_1
00003C7C  4480      6602          neg.l   D0
00003C7E  4A81      6603          tst.l   D1
00003C80  6A0A      6604          bpl.s   lmul_2
00003C82  4481      6605          neg.l   D1
00003C84  600E      6606          bra.s   lmul_3
                    6607   lmul_1:
00003C86  4A81      6608          tst.l   D1
00003C88  6A0A      6609          bpl.s   lmul_3
00003C8A  4481      6610          neg.l   D1
                    6611   lmul_2:
00003C8C  6114      6612          bsr.s   domul
00003C8E  4481      6613          neg.l   D1
00003C90  4080      6614          negx.l  D0
00003C92  6002      6615          bra.s   lmul_4
                    6616   lmul_3:
00003C94  610C      6617          bsr.s   domul
                    6618   lmul_4:
00003C96  2D41 0008 6619          move.l  D1,8(A6)
00003C9A  4CDF 0003 6620          movem.l (A7)+,D0/D1
00003C9E  4E5E      6621          unlk    A6
00003CA0  4E75      6622          rts
                    6623   domul:
00003CA2  0C81 0000 6624          cmpi.l  #$FFFF,D1
00003CA6  FFFF      
00003CA8  620C      6625          bhi.s   domul_1
00003CAA  0C80 0000 6626          cmpi.l  #$FFFF,D0
00003CAE  FFFF      
00003CB0  620E      6627          bhi.s   domul_2
00003CB2  C2C0      6628          mulu    D0,D1
00003CB4  4E75      6629          rts
                    6630   domul_1:
00003CB6  0C80 0000 6631          cmpi.l  #$FFFF,D0
00003CBA  FFFF      
00003CBC  6218      6632          bhi.s   domul_4
00003CBE  6002      6633          bra.s   domul_3
                    6634   domul_2
00003CC0  C141      6635          exg     D0,D1
                    6636   domul_3:
00003CC2  2F02      6637          move.l  D2,-(A7)
00003CC4  2401      6638          move.l  D1,D2
00003CC6  4842      6639          swap    D2
00003CC8  C2C0      6640          mulu    D0,D1
00003CCA  C4C0      6641          mulu    D0,D2
00003CCC  4842      6642          swap    D2
00003CCE  4242      6643          clr.w   D2
00003CD0  D282      6644          add.l   D2,D1
00003CD2  241F      6645          move.l  (A7)+,D2
00003CD4  4E75      6646          rts
                    6647   domul_4:
00003CD6  48E7 3000 6648          movem.l D2/D3,-(A7)
00003CDA  2401      6649          move.l  D1,D2
00003CDC  2601      6650          move.l  D1,D3
00003CDE  C2C0      6651          mulu    D0,D1
00003CE0  4842      6652          swap    D2
00003CE2  C4C0      6653          mulu    D0,D2
00003CE4  4840      6654          swap    D0
00003CE6  C6C0      6655          mulu    D0,D3
00003CE8  D483      6656          add.l   D3,D2
00003CEA  4842      6657          swap    D2
00003CEC  4242      6658          clr.w   D2
00003CEE  D282      6659          add.l   D2,D1
00003CF0  4CDF 000C 6660          movem.l (A7)+,D2/D3
00003CF4  4E75      6661          rts
                    6662   _strlen:
00003CF6  206F 0004 6663          move.l    (4,A7),A0
00003CFA  2248      6664          move.l    A0,A1
                    6665   strlen_1:
00003CFC  4A19      6666          tst.b     (A1)+
00003CFE  66FC      6667          bne       strlen_1
00003D00  2009      6668          move.l    A1,D0
00003D02  9088      6669          sub.l     A0,D0
00003D04  5380      6670          subq.l    #1,D0
00003D06  4E75      6671          rts
                    6672          section   const
                    6673   
                    6674   @m68kde~1_1:
00003D08  0D0A 00   6675          dc.b      13,10,0
                    6676   @m68kde~1_2:
00003D0C  0D53 7769 6677          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00003D10  7463 6865 
00003D14  7320 5357 
00003D18  5B        
00003D19  372D 305D 6678          dc.b      55,45,48,93,32,61,32,0
00003D1D  203D 2000 
                    6679   @m68kde~1_3:
00003D22  3000      6680          dc.b      48,0
                    6681   @m68kde~1_4:
00003D24  3100      6682          dc.b      49,0
                    6683   @m68kde~1_5:
00003D26  0D0A 4475 6684          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00003D2A  6D70 204D 
00003D2E  656D 6F72 
00003D32  79        
00003D33  2042 6C6F 6685          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00003D37  636B 3A20 
00003D3B  3C45 5343 
00003D3F  3E20      
00003D41  746F 2041 6686          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00003D45  626F 7274 
00003D49  2C20 3C53 
00003D4D  50        
00003D4E  4143 453E 6687          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00003D52  2074 6F20 
00003D56  436F 6E74 
00003D5A  69        
00003D5B  6E75 6500 6688          dc.b      110,117,101,0
                    6689   @m68kde~1_6:
00003D60  0D0A 456E 6690          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00003D64  7465 7220 
00003D68  5374 6172 
00003D6C  74        
00003D6D  2041 6464 6691          dc.b      32,65,100,100,114,101,115,115,58,32,0
00003D71  7265 7373 
00003D75  3A20 00   
                    6692   @m68kde~1_7:
00003D78  0D0A 2530 6693          dc.b      13,10,37,48,56,120,32,0
00003D7C  3878 2000 
                    6694   @m68kde~1_8:
00003D80  2530 3258 6695          dc.b      37,48,50,88,0
00003D84  00        
                    6696   @m68kde~1_9:
00003D86  2020 00   6697          dc.b      32,32,0
                    6698   @m68kde~1_10:
00003D8A  0D0A 4669 6699          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00003D8E  6C6C 204D 
00003D92  656D 6F72 
00003D96  79        
00003D97  2042 6C6F 6700          dc.b      32,66,108,111,99,107,0
00003D9B  636B 00   
                    6701   @m68kde~1_11:
00003D9E  0D0A 456E 6702          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00003DA2  7465 7220 
00003DA6  456E 6420 
00003DAA  41        
00003DAB  6464 7265 6703          dc.b      100,100,114,101,115,115,58,32,0
00003DAF  7373 3A20 
00003DB3  00        
                    6704   @m68kde~1_12:
00003DB4  0D0A 456E 6705          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00003DB8  7465 7220 
00003DBC  4669 6C6C 
00003DC0  20        
00003DC1  4461 7461 6706          dc.b      68,97,116,97,58,32,0
00003DC5  3A20 00   
                    6707   @m68kde~1_13:
00003DC8  0D0A 4669 6708          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00003DCC  6C6C 696E 
00003DD0  6720 4164 
00003DD4  64        
00003DD5  7265 7373 6709          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00003DD9  6573 205B 
00003DDD  2425 3038 
00003DE1  58        
00003DE2  202D 2024 6710          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00003DE6  2530 3858 
00003DEA  5D20 7769 
00003DEE  7468      
00003DF0  2024 2530 6711          dc.b      32,36,37,48,50,88,0
00003DF4  3258 00   
                    6712   @m68kde~1_14:
00003DF8  0D0A 5573 6713          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00003DFC  6520 4879 
00003E00  7065 7254 
00003E04  65        
00003E05  726D 696E 6714          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00003E09  616C 2074 
00003E0D  6F20 5365 
00003E11  6E64 2054 6715          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00003E15  6578 7420 
00003E19  4669 6C65 
00003E1D  2028 2E68 6716          dc.b      32,40,46,104,101,120,41,13,10,0
00003E21  6578 290D 
00003E25  0A00      
                    6717   @m68kde~1_15:
00003E28  0D0A 4C6F 6718          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00003E2C  6164 2046 
00003E30  6169 6C65 
00003E34  64        
00003E35  2061 7420 6719          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00003E39  4164 6472 
00003E3D  6573 7320 
00003E41  3D        
00003E42  205B 2425 6720          dc.b      32,91,36,37,48,56,88,93,13,10,0
00003E46  3038 585D 
00003E4A  0D0A 00   
                    6721   @m68kde~1_16:
00003E4E  0D0A 5375 6722          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00003E52  6363 6573 
00003E56  733A 2044 
00003E5A  6F        
00003E5B  776E 6C6F 6723          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00003E5F  6164 6564 
00003E63  2025 6420 
00003E67  6279 7465 6724          dc.b      98,121,116,101,115,13,10,0
00003E6B  730D 0A00 
                    6725   @m68kde~1_17:
00003E70  0D0A 4578 6726          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00003E74  616D 696E 
00003E78  6520 616E 
00003E7C  64        
00003E7D  2043 6861 6727          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00003E81  6E67 6520 
00003E85  4D65 6D6F 
00003E89  72        
00003E8A  7900      6728          dc.b      121,0
                    6729   @m68kde~1_18:
00003E8C  0D0A 3C45 6730          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00003E90  5343 3E20 
00003E94  746F 2053 
00003E98  746F      
00003E9A  702C 203C 6731          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00003E9E  5350 4143 
00003EA2  453E 2074 
00003EA6  6F20      
00003EA8  4164 7661 6732          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00003EAC  6E63 652C 
00003EB0  2027 2D27 
00003EB4  2074      
00003EB6  6F20 476F 6733          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00003EBA  2042 6163 
00003EBE  6B2C 203C 
00003EC2  4441      
00003EC4  5441 3E20 6734          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00003EC8  746F 2063 
00003ECC  6861 6E67 
00003ED0  65        
00003ED1  00        6735          dc.b      0
                    6736   @m68kde~1_19:
00003ED2  0D0A 456E 6737          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00003ED6  7465 7220 
00003EDA  4164 6472 
00003EDE  65        
00003EDF  7373 3A20 6738          dc.b      115,115,58,32,0
00003EE3  00        
                    6739   @m68kde~1_20:
00003EE4  0D0A 5B25 6740          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00003EE8  3038 785D 
00003EEC  203A 2025 
00003EF0  3032 78   
00003EF3  2020 00   6741          dc.b      32,32,0
                    6742   @m68kde~1_21:
00003EF6  0D0A 5761 6743          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00003EFA  726E 696E 
00003EFE  6720 4368 
00003F02  61        
00003F03  6E67 6520 6744          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00003F07  4661 696C 
00003F0B  6564 3A20 
00003F0F  57        
00003F10  726F 7465 6745          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00003F14  205B 2530 
00003F18  3278 5D2C 
00003F1C  20        
00003F1D  5265 6164 6746          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00003F21  205B 2530 
00003F25  3278 5D00 
                    6747   @m68kde~1_22:
00003F2A  0D0A 4578 6748          dc.b      13,10,69,120,101,99,117,116,105,110,103,32,80
00003F2E  6563 7574 
00003F32  696E 6720 
00003F36  50        
00003F37  726F 6772 6749          dc.b      114,111,103,114,97,109,32,70,117,110,99,116
00003F3B  616D 2046 
00003F3F  756E 6374 
00003F43  696F 6E2E 6750          dc.b      105,111,110,46,46,46,46,0
00003F47  2E2E 2E00 
                    6751   @m68kde~1_23:
00003F4C  0A00      6752          dc.b      10,0
                    6753   @m68kde~1_24:
00003F4E  0D0A 5020 6754          dc.b      13,10,80,32,67,111,109,109,97,110,100,32,67
00003F52  436F 6D6D 
00003F56  616E 6420 
00003F5A  43        
00003F5B  6F6D 706C 6755          dc.b      111,109,112,108,101,116,101,100,46,0
00003F5F  6574 6564 
00003F63  2E00      
                    6756   @m68kde~1_25:
00003F66  0D0A 4C6F 6757          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
00003F6A  6164 696E 
00003F6E  6720 5072 
00003F72  6F        
00003F73  6772 616D 6758          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
00003F77  2046 726F 
00003F7B  6D20 5350 
00003F7F  49        
00003F80  2046 6C61 6759          dc.b      32,70,108,97,115,104,46,46,46,46,0
00003F84  7368 2E2E 
00003F88  2E2E 00   
                    6760   @m68kde~1_26:
00003F8C  0D0A 4320 6761          dc.b      13,10,67,32,67,111,109,109,97,110,100,32,67
00003F90  436F 6D6D 
00003F94  616E 6420 
00003F98  43        
00003F99  6F6D 706C 6762          dc.b      111,109,112,108,101,116,101,100,46,0
00003F9D  6574 6564 
00003FA1  2E00      
                    6763   @m68kde~1_27:
00003FA4  2425 3038 6764          dc.b      36,37,48,56,88,32,32,0
00003FA8  5820 2000 
                    6765   @m68kde~1_28:
00003FAC  2000      6766          dc.b      32,0
                    6767   @m68kde~1_29:
00003FAE  2E00      6768          dc.b      46,0
                    6769   @m68kde~1_30:
00003FB0  2563 00   6770          dc.b      37,99,0
                    6771   @m68kde~1_31:
00003FB4  00        6772          dc.b      0
                    6773   @m68kde~1_32:
00003FB6  0D0A 0D0A 6774          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
00003FBA  2044 3020 
00003FBE  3D20 2425 
00003FC2  3038 58   
00003FC5  2020 4130 6775          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
00003FC9  203D 2024 
00003FCD  2530 3858 
00003FD1  00        
                    6776   @m68kde~1_33:
00003FD2  0D0A 2044 6777          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
00003FD6  3120 3D20 
00003FDA  2425 3038 
00003FDE  5820 20   
00003FE1  4131 203D 6778          dc.b      65,49,32,61,32,36,37,48,56,88,0
00003FE5  2024 2530 
00003FE9  3858 00   
                    6779   @m68kde~1_34:
00003FEC  0D0A 2044 6780          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00003FF0  3220 3D20 
00003FF4  2425 3038 
00003FF8  5820 20   
00003FFB  4132 203D 6781          dc.b      65,50,32,61,32,36,37,48,56,88,0
00003FFF  2024 2530 
00004003  3858 00   
                    6782   @m68kde~1_35:
00004006  0D0A 2044 6783          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
0000400A  3320 3D20 
0000400E  2425 3038 
00004012  5820 20   
00004015  4133 203D 6784          dc.b      65,51,32,61,32,36,37,48,56,88,0
00004019  2024 2530 
0000401D  3858 00   
                    6785   @m68kde~1_36:
00004020  0D0A 2044 6786          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
00004024  3420 3D20 
00004028  2425 3038 
0000402C  5820 20   
0000402F  4134 203D 6787          dc.b      65,52,32,61,32,36,37,48,56,88,0
00004033  2024 2530 
00004037  3858 00   
                    6788   @m68kde~1_37:
0000403A  0D0A 2044 6789          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
0000403E  3520 3D20 
00004042  2425 3038 
00004046  5820 20   
00004049  4135 203D 6790          dc.b      65,53,32,61,32,36,37,48,56,88,0
0000404D  2024 2530 
00004051  3858 00   
                    6791   @m68kde~1_38:
00004054  0D0A 2044 6792          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
00004058  3620 3D20 
0000405C  2425 3038 
00004060  5820 20   
00004063  4136 203D 6793          dc.b      65,54,32,61,32,36,37,48,56,88,0
00004067  2024 2530 
0000406B  3858 00   
                    6794   @m68kde~1_39:
0000406E  0D0A 2044 6795          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
00004072  3720 3D20 
00004076  2425 3038 
0000407A  5820 20   
0000407D  4137 203D 6796          dc.b      65,55,32,61,32,36,37,48,56,88,0
00004081  2024 2530 
00004085  3858 00   
                    6797   @m68kde~1_40:
00004088  0D0A 0D0A 6798          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
0000408C  5553 5020 
00004090  3D20 2425 
00004094  3038 58   
00004097  2020 2841 6799          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
0000409B  3729 2055 
0000409F  7365 7220 
000040A3  5350      
000040A5  00        6800          dc.b      0
                    6801   @m68kde~1_41:
000040A6  0D0A 5353 6802          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
000040AA  5020 3D20 
000040AE  2425 3038 
000040B2  5820 20   
000040B5  2841 3729 6803          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
000040B9  2053 7570 
000040BD  6572 7669 
000040C1  73        
000040C2  6F72 2053 6804          dc.b      111,114,32,83,80,0
000040C6  5000      
                    6805   @m68kde~1_42:
000040C8  0D0A 2053 6806          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000040CC  5220 3D20 
000040D0  2425 3034 
000040D4  5820 20   
000040D7  2000      6807          dc.b      32,0
                    6808   @m68kde~1_43:
000040DA  2020 205B 6809          dc.b      32,32,32,91,0
000040DE  00        
                    6810   @m68kde~1_44:
000040E0  0D0A 2050 6811          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
000040E4  4320 3D20 
000040E8  2425 3038 
000040EC  5820 20   
000040EF  00        6812          dc.b      0
                    6813   @m68kde~1_45:
000040F0  5B40 2042 6814          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
000040F4  5245 414B 
000040F8  504F 494E 
000040FC  545D 00   
                    6815   @m68kde~1_46:
00004100  0D0A 5750 6816          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00004104  2564 203D 
00004108  2025 7300 
                    6817   @m68kde~1_47:
0000410C  0D0A 0D0A 6818          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00004110  0D0A 0D0A 
00004114  0D0A 0D0A 
00004118  5369 6E   
0000411B  676C 6520 6819          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
0000411F  5374 6570 
00004123  2020 3A5B 
00004127  4F        
00004128  4E5D 00   6820          dc.b      78,93,0
                    6821   @m68kde~1_48:
0000412C  0D0A 4272 6822          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004130  6561 6B20 
00004134  506F 696E 
00004138  74        
00004139  7320 3A5B 6823          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
0000413D  4469 7361 
00004141  626C 6564 
00004145  5D        
00004146  00        6824          dc.b      0
                    6825   @m68kde~1_49:
00004148  0D0A 5072 6826          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
0000414C  6573 7320 
00004150  3C53 5041 
00004154  4345      
00004156  3E20 746F 6827          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
0000415A  2045 7865 
0000415E  6375 7465 
00004162  20        
00004163  4E65 7874 6828          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
00004167  2049 6E73 
0000416B  7472 7563 
0000416F  7469 6F6E 6829          dc.b      116,105,111,110,0
00004173  00        
                    6830   @m68kde~1_50:
00004174  0D0A 5072 6831          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004178  6573 7320 
0000417C  3C45 5343 
00004180  3E20      
00004182  746F 2052 6832          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
00004186  6573 756D 
0000418A  6520 5072 
0000418E  6F67 7261 6833          dc.b      111,103,114,97,109,0
00004192  6D00      
                    6834   @m68kde~1_51:
00004194  0D0A 496C 6835          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00004198  6C65 6761 
0000419C  6C20 4461 
000041A0  74        
000041A1  6120 5265 6836          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
000041A5  6769 7374 
000041A9  6572 203A 
000041AD  20        
000041AE  5573 6520 6837          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
000041B2  4430 2D44 
000041B6  372E 2E2E 
000041BA  2E2E      
000041BC  0D0A 00   6838          dc.b      13,10,0
                    6839   @m68kde~1_52:
000041C0  0D0A 4425 6840          dc.b      13,10,68,37,99,32,61,32,0
000041C4  6320 3D20 
000041C8  00        
                    6841   @m68kde~1_53:
000041CA  0D0A 496C 6842          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000041CE  6C65 6761 
000041D2  6C20 4164 
000041D6  64        
000041D7  7265 7373 6843          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
000041DB  2052 6567 
000041DF  6973 7465 
000041E3  7220 3A20 6844          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
000041E7  5573 6520 
000041EB  4130 2D41 
000041EF  372E      
000041F1  2E2E 2E2E 6845          dc.b      46,46,46,46,13,10,0
000041F5  0D0A 00   
                    6846   @m68kde~1_54:
000041F8  0D0A 4125 6847          dc.b      13,10,65,37,99,32,61,32,0
000041FC  6320 3D20 
00004200  00        
                    6848   @m68kde~1_55:
00004202  0D0A 5573 6849          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00004206  6572 2053 
0000420A  5020 3D20 
0000420E  00        
                    6850   @m68kde~1_56:
00004210  0D0A 496C 6851          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00004214  6C65 6761 
00004218  6C20 5265 
0000421C  67        
0000421D  6973 7465 6852          dc.b      105,115,116,101,114,46,46,46,46,0
00004221  722E 2E2E 
00004225  2E00      
                    6853   @m68kde~1_57:
00004228  0D0A 5379 6854          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
0000422C  7374 656D 
00004230  2053 5020 
00004234  3D        
00004235  2000      6855          dc.b      32,0
                    6856   @m68kde~1_58:
00004238  0D0A 5043 6857          dc.b      13,10,80,67,32,61,32,0
0000423C  203D 2000 
                    6858   @m68kde~1_59:
00004240  0D0A 5352 6859          dc.b      13,10,83,82,32,61,32,0
00004244  203D 2000 
                    6860   @m68kde~1_60:
00004248  0D0A 496C 6861          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
0000424C  6C65 6761 
00004250  6C20 5265 
00004254  67        
00004255  6973 7465 6862          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00004259  723A 2055 
0000425D  7365 2041 
00004261  30        
00004262  2D41 372C 6863          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00004266  2044 302D 
0000426A  4437 2C20 
0000426E  5353 50   
00004271  2C20 5553 6864          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
00004275  502C 2050 
00004279  4320 6F72 
0000427D  2053      
0000427F  520D 0A00 6865          dc.b      82,13,10,0
                    6866   @m68kde~1_61:
00004284  0D0A 0D0A 6867          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00004288  4E75 6D20 
0000428C  2020 2020 
00004290  4164      
00004292  6472 6573 6868          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
00004296  7320 2020 
0000429A  2020 2049 
0000429E  6E        
0000429F  7374 7275 6869          dc.b      115,116,114,117,99,116,105,111,110,0
000042A3  6374 696F 
000042A7  6E00      
                    6870   @m68kde~1_62:
000042AA  0D0A 2D2D 6871          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000042AE  2D20 2020 
000042B2  2020 2D2D 
000042B6  2D2D 2D   
000042B9  2D2D 2D2D 6872          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
000042BD  2020 2020 
000042C1  2D2D 2D2D 
000042C5  2D2D 2D   
000042C8  2D2D 2D2D 6873          dc.b      45,45,45,45,0
000042CC  00        
                    6874   @m68kde~1_63:
000042CE  0D0A 4E6F 6875          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000042D2  2042 7265 
000042D6  616B 506F 
000042DA  69        
000042DB  6E74 7320 6876          dc.b      110,116,115,32,83,101,116,0
000042DF  5365 7400 
                    6877   @m68kde~1_64:
000042E4  0D0A 2533 6878          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
000042E8  6420 2020 
000042EC  2020 2425 
000042F0  3038 78   
000042F3  00        6879          dc.b      0
                    6880   @m68kde~1_65:
000042F4  0D0A 4E75 6881          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
000042F8  6D20 2020 
000042FC  2020 4164 
00004300  6472      
00004302  6573 7300 6882          dc.b      101,115,115,0
                    6883   @m68kde~1_66:
00004306  0D0A 2D2D 6884          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
0000430A  2D20 2020 
0000430E  2020 2D2D 
00004312  2D2D 2D   
00004315  2D2D 2D2D 6885          dc.b      45,45,45,45,0
00004319  00        
                    6886   @m68kde~1_67:
0000431A  0D0A 4E6F 6887          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
0000431E  2057 6174 
00004322  6368 506F 
00004326  69        
00004327  6E74 7320 6888          dc.b      110,116,115,32,83,101,116,0
0000432B  5365 7400 
                    6889   @m68kde~1_68:
00004330  0D0A 456E 6890          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00004334  7465 7220 
00004338  4272 6561 
0000433C  6B        
0000433D  2050 6F69 6891          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00004341  6E74 204E 
00004345  756D 6265 
00004349  72        
0000434A  3A20 00   6892          dc.b      58,32,0
                    6893   @m68kde~1_69:
0000434E  0D0A 496C 6894          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00004352  6C65 6761 
00004356  6C20 5261 
0000435A  6E        
0000435B  6765 203A 6895          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
0000435F  2055 7365 
00004363  2030 202D 
00004367  2037      
00004369  00        6896          dc.b      0
                    6897   @m68kde~1_70:
0000436A  0D0A 4272 6898          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000436E  6561 6B20 
00004372  506F 696E 
00004376  74        
00004377  2043 6C65 6899          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
0000437B  6172 6564 
0000437F  2E2E 2E2E 
00004383  2E        
00004384  0D0A 00   6900          dc.b      13,10,0
                    6901   @m68kde~1_71:
00004388  0D0A 4272 6902          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000438C  6561 6B20 
00004390  506F 696E 
00004394  74        
00004395  2077 6173 6903          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
00004399  6E27 7420 
0000439D  5365 742E 
000043A1  2E        
000043A2  2E2E 2E00 6904          dc.b      46,46,46,0
                    6905   @m68kde~1_72:
000043A6  0D0A 456E 6906          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
000043AA  7465 7220 
000043AE  5761 7463 
000043B2  68        
000043B3  2050 6F69 6907          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000043B7  6E74 204E 
000043BB  756D 6265 
000043BF  72        
000043C0  3A20 00   6908          dc.b      58,32,0
                    6909   @m68kde~1_73:
000043C4  0D0A 5761 6910          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000043C8  7463 6820 
000043CC  506F 696E 
000043D0  74        
000043D1  2043 6C65 6911          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000043D5  6172 6564 
000043D9  2E2E 2E2E 
000043DD  2E        
000043DE  0D0A 00   6912          dc.b      13,10,0
                    6913   @m68kde~1_74:
000043E2  0D0A 5761 6914          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000043E6  7463 6820 
000043EA  506F 696E 
000043EE  74        
000043EF  2057 6173 6915          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
000043F3  206E 6F74 
000043F7  2053 6574 
000043FB  2E        
000043FC  2E2E 2E2E 6916          dc.b      46,46,46,46,0
00004400  00        
                    6917   @m68kde~1_75:
00004402  0D0A 4E6F 6918          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00004406  2046 5245 
0000440A  4520 4272 
0000440E  6561      
00004410  6B20 506F 6919          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00004414  696E 7473 
00004418  2E2E 2E2E 
0000441C  2E        
0000441D  00        6920          dc.b      0
                    6921   @m68kde~1_76:
0000441E  0D0A 4272 6922          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004422  6561 6B20 
00004426  506F 696E 
0000442A  74        
0000442B  2041 6464 6923          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000442F  7265 7373 
00004433  3A20 00   
                    6924   @m68kde~1_77:
00004436  0D0A 4572 6925          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
0000443A  726F 7220 
0000443E  3A20 4272 
00004442  65        
00004443  616B 2050 6926          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00004447  6F69 6E74 
0000444B  7320 4341 
0000444F  4E        
00004450  4E4F 5420 6927          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00004454  6265 2073 
00004458  6574 2061 
0000445C  74        
0000445D  204F 4444 6928          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00004461  2061 6464 
00004465  7265 7373 
00004469  65        
0000446A  7300      6929          dc.b      115,0
                    6930   @m68kde~1_78:
0000446C  0D0A 4572 6931          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00004470  726F 7220 
00004474  3A20 4272 
00004478  65        
00004479  616B 2050 6932          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
0000447D  6F69 6E74 
00004481  7320 4341 
00004485  4E        
00004486  4E4F 5420 6933          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
0000448A  6265 2073 
0000448E  6574 2066 
00004492  6F        
00004493  7220 524F 6934          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
00004497  4D20 696E 
0000449B  2052 616E 
0000449F  67        
000044A0  6520 3A20 6935          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
000044A4  5B24 302D 
000044A8  2430 3030 
000044AC  3037 46   
000044AF  4646 5D00 6936          dc.b      70,70,93,0
                    6937   @m68kde~1_79:
000044B4  0D0A 4572 6938          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
000044B8  726F 723A 
000044BC  2042 7265 
000044C0  61        
000044C1  6B20 506F 6939          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
000044C5  696E 7420 
000044C9  416C 7265 
000044CD  6164 7920 6940          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
000044D1  4578 6973 
000044D5  7473 2061 
000044D9  74        
000044DA  2041 6464 6941          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
000044DE  7265 7373 
000044E2  203A 2025 
000044E6  30        
000044E7  3878 0D0A 6942          dc.b      56,120,13,10,0
000044EB  00        
                    6943   @m68kde~1_80:
000044EC  0D0A 4272 6944          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000044F0  6561 6B20 
000044F4  506F 696E 
000044F8  74        
000044F9  2053 6574 6945          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
000044FD  2061 7420 
00004501  4164 6472 
00004505  65        
00004506  7373 3A20 6946          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
0000450A  5B24 2530 
0000450E  3878 5D00 
                    6947   @m68kde~1_81:
00004512  0D0A 4E6F 6948          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00004516  2046 5245 
0000451A  4520 5761 
0000451E  7463      
00004520  6820 506F 6949          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00004524  696E 7473 
00004528  2E2E 2E2E 
0000452C  2E        
0000452D  00        6950          dc.b      0
                    6951   @m68kde~1_82:
0000452E  0D0A 5761 6952          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004532  7463 6820 
00004536  506F 696E 
0000453A  74        
0000453B  2041 6464 6953          dc.b      32,65,100,100,114,101,115,115,58,32,0
0000453F  7265 7373 
00004543  3A20 00   
                    6954   @m68kde~1_83:
00004546  0D0A 4572 6955          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
0000454A  726F 723A 
0000454E  2057 6174 
00004552  63        
00004553  6820 506F 6956          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00004557  696E 7420 
0000455B  416C 7265 
0000455F  6164 7920 6957          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00004563  5365 7420 
00004567  6174 2041 
0000456B  64        
0000456C  6472 6573 6958          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00004570  7320 3A20 
00004574  2530 3878 
00004578  0D        
00004579  0A00      6959          dc.b      10,0
                    6960   @m68kde~1_84:
0000457C  0D0A 5761 6961          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00004580  7463 6820 
00004584  506F 696E 
00004588  74        
00004589  2053 6574 6962          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
0000458D  2061 7420 
00004591  4164 6472 
00004595  65        
00004596  7373 3A20 6963          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
0000459A  5B24 2530 
0000459E  3878 5D00 
                    6964   @m68kde~1_85:
000045A2  0D0A 0D0A 6965          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
000045A6  0D0A 0D0A 
000045AA  4042 5245 
000045AE  414B 50   
000045B1  4F49 4E54 6966          dc.b      79,73,78,84,0
000045B5  00        
                    6967   @m68kde~1_86:
000045B6  0D0A 5369 6968          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000045BA  6E67 6C65 
000045BE  2053 7465 
000045C2  70        
000045C3  203A 205B 6969          dc.b      32,58,32,91,79,78,93,0
000045C7  4F4E 5D00 
                    6970   @m68kde~1_87:
000045CC  0D0A 4272 6971          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
000045D0  6561 6B50 
000045D4  6F69 6E74 
000045D8  73        
000045D9  203A 205B 6972          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
000045DD  456E 6162 
000045E1  6C65 645D 
000045E5  00        
                    6973   @m68kde~1_88:
000045E6  0D0A 5072 6974          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000045EA  6573 7320 
000045EE  3C45 5343 
000045F2  3E20      
000045F4  746F 2052 6975          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
000045F8  6573 756D 
000045FC  6520 5573 
00004600  6572 2050 6976          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00004604  726F 6772 
00004608  616D 0D0A 
0000460C  00        
                    6977   @m68kde~1_89:
0000460E  0D0A 556E 6978          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00004612  6B6E 6F77 
00004616  6E20 436F 
0000461A  6D        
0000461B  6D61 6E64 6979          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
0000461F  2E2E 2E2E 
00004623  2E0D 0A00 
                    6980   @m68kde~1_90:
00004628  0D0A 5072 6981          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
0000462C  6F67 7261 
00004630  6D20 456E 
00004634  64        
00004635  6564 2028 6982          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00004639  5452 4150 
0000463D  2023 3135 
00004641  292E      
00004643  2E2E 2E00 6983          dc.b      46,46,46,0
                    6984   @m68kde~1_91:
00004648  0D0A 4B69 6985          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
0000464C  6C6C 2041 
00004650  6C6C 2042 
00004654  72        
00004655  6561 6B20 6986          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00004659  506F 696E 
0000465D  7473 2E2E 
00004661  2E        
00004662  2879 2F6E 6987          dc.b      40,121,47,110,41,63,0
00004666  293F 00   
                    6988   @m68kde~1_92:
0000466A  0D0A 4B69 6989          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
0000466E  6C6C 2041 
00004672  6C6C 2057 
00004676  61        
00004677  7463 6820 6990          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
0000467B  506F 696E 
0000467F  7473 2E2E 
00004683  2E        
00004684  2879 2F6E 6991          dc.b      40,121,47,110,41,63,0
00004688  293F 00   
                    6992   @m68kde~1_93:
0000468C  0D0A 2D2D 6993          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00004690  2D2D 2D2D 
00004694  2D2D 2D2D 
00004698  2D2D 2D   
0000469B  2D2D 2D2D 6994          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
0000469F  2D2D 2D2D 
000046A3  2D2D 2D2D 
000046A7  2D2D 2D   
000046AA  2D2D 2D2D 6995          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000046AE  2D2D 2D2D 
000046B2  2D2D 2D2D 
000046B6  2D2D 2D   
000046B9  2D2D 2D2D 6996          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
000046BD  2D2D 2D2D 
000046C1  2D2D 2D2D 
000046C5  2D2D 2D   
000046C8  2D2D 2D2D 6997          dc.b      45,45,45,45,45,45,0
000046CC  2D2D 00   
                    6998   @m68kde~1_94:
000046D0  0D0A 2020 6999          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
000046D4  4465 6275 
000046D8  6767 6572 
000046DC  20        
000046DD  436F 6D6D 7000          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
000046E1  616E 6420 
000046E5  5375 6D6D 
000046E9  6172 7900 7001          dc.b      97,114,121,0
                    7002   @m68kde~1_95:
000046EE  0D0A 2020 7003          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
000046F2  2E28 7265 
000046F6  6729 2020 
000046FA  2020      
000046FC  2020 202D 7004          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00004700  2043 6861 
00004704  6E67 6520 
00004708  5265      
0000470A  6769 7374 7005          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
0000470E  6572 733A 
00004712  2065 2E67 
00004716  2041 302D 7006          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
0000471A  4137 2C44 
0000471E  302D 4437 
00004722  2C50 43   
00004725  2C53 5350 7007          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00004729  2C55 5350 
0000472D  2C53 5200 
                    7008   @m68kde~1_96:
00004732  0D0A 2020 7009          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00004736  4244 2F42 
0000473A  532F 4243 
0000473E  2F42 4B   
00004741  2020 2D20 7010          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00004745  4272 6561 
00004749  6B20 506F 
0000474D  69        
0000474E  6E74 3A20 7011          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00004752  4469 7370 
00004756  6C61 792F 
0000475A  53        
0000475B  6574 2F43 7012          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
0000475F  6C65 6172 
00004763  2F4B 696C 
00004767  6C        
00004768  00        7013          dc.b      0
                    7014   @m68kde~1_97:
0000476A  0D0A 2020 7015          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
0000476E  4320 2020 
00004772  2020 2020 
00004776  2020 20   
00004779  2020 2D20 7016          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
0000477D  436F 7079 
00004781  2050 726F 
00004785  67        
00004786  7261 6D20 7017          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
0000478A  6672 6F6D 
0000478E  2046 6C61 
00004792  73        
00004793  6820 746F 7018          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
00004797  204D 6169 
0000479B  6E20 4D65 
0000479F  6D        
000047A0  6F72 7900 7019          dc.b      111,114,121,0
                    7020   @m68kde~1_98:
000047A4  0D0A 2020 7021          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
000047A8  4420 2020 
000047AC  2020 2020 
000047B0  2020 20   
000047B3  2020 2D20 7022          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
000047B7  4475 6D70 
000047BB  204D 656D 
000047BF  6F        
000047C0  7279 2043 7023          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
000047C4  6F6E 7465 
000047C8  6E74 7320 
000047CC  746F 2053 7024          dc.b      116,111,32,83,99,114,101,101,110,0
000047D0  6372 6565 
000047D4  6E00      
                    7025   @m68kde~1_99:
000047D6  0D0A 2020 7026          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
000047DA  4520 2020 
000047DE  2020 2020 
000047E2  2020 20   
000047E5  2020 2D20 7027          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
000047E9  456E 7465 
000047ED  7220 5374 
000047F1  72        
000047F2  696E 6720 7028          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
000047F6  696E 746F 
000047FA  204D 656D 
000047FE  6F72 7900 7029          dc.b      111,114,121,0
                    7030   @m68kde~1_100:
00004802  0D0A 2020 7031          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00004806  4620 2020 
0000480A  2020 2020 
0000480E  2020 20   
00004811  2020 2D20 7032          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00004815  4669 6C6C 
00004819  204D 656D 
0000481D  6F        
0000481E  7279 2077 7033          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00004822  6974 6820 
00004826  4461 7461 
0000482A  00        
                    7034   @m68kde~1_101:
0000482C  0D0A 2020 7035          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00004830  4720 2020 
00004834  2020 2020 
00004838  2020 20   
0000483B  2020 2D20 7036          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
0000483F  476F 2050 
00004843  726F 6772 
00004847  61        
00004848  6D20 5374 7037          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
0000484C  6172 7469 
00004850  6E67 2061 
00004854  74        
00004855  2041 6464 7038          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00004859  7265 7373 
0000485D  3A20 2425 
00004861  30        
00004862  3858 00   7039          dc.b      56,88,0
                    7040   @m68kde~1_102:
00004866  0D0A 2020 7041          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
0000486A  4C20 2020 
0000486E  2020 2020 
00004872  2020 20   
00004875  2020 2D20 7042          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00004879  4C6F 6164 
0000487D  2050 726F 
00004881  67        
00004882  7261 6D20 7043          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00004886  282E 4845 
0000488A  5820 6669 
0000488E  6C        
0000488F  6529 2066 7044          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
00004893  726F 6D20 
00004897  4C61 7074 
0000489B  6F        
0000489C  7000      7045          dc.b      112,0
                    7046   @m68kde~1_103:
0000489E  0D0A 2020 7047          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
000048A2  4D20 2020 
000048A6  2020 2020 
000048AA  2020 20   
000048AD  2020 2D20 7048          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
000048B1  4D65 6D6F 
000048B5  7279 2045 
000048B9  78        
000048BA  616D 696E 7049          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
000048BE  6520 616E 
000048C2  6420 4368 
000048C6  61        
000048C7  6E67 6500 7050          dc.b      110,103,101,0
                    7051   @m68kde~1_104:
000048CC  0D0A 2020 7052          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
000048D0  5020 2020 
000048D4  2020 2020 
000048D8  2020 20   
000048DB  2020 2D20 7053          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
000048DF  5072 6F67 
000048E3  7261 6D20 
000048E7  46        
000048E8  6C61 7368 7054          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
000048EC  204D 656D 
000048F0  6F72 7920 
000048F4  7769 7468 7055          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
000048F8  2055 7365 
000048FC  7220 5072 
00004900  6F67 7261 7056          dc.b      111,103,114,97,109,0
00004904  6D00      
                    7057   @m68kde~1_105:
00004906  0D0A 2020 7058          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
0000490A  5220 2020 
0000490E  2020 2020 
00004912  2020 20   
00004915  2020 2D20 7059          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00004919  4469 7370 
0000491D  6C61 7920 
00004921  36        
00004922  3830 3030 7060          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00004926  2052 6567 
0000492A  6973 7465 
0000492E  72        
0000492F  7300      7061          dc.b      115,0
                    7062   @m68kde~1_106:
00004932  0D0A 2020 7063          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00004936  5320 2020 
0000493A  2020 2020 
0000493E  2020 20   
00004941  2020 2D20 7064          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00004945  546F 6767 
00004949  6C65 204F 
0000494D  4E        
0000494E  2F4F 4646 7065          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00004952  2053 696E 
00004956  676C 6520 
0000495A  53        
0000495B  7465 7020 7066          dc.b      116,101,112,32,77,111,100,101,0
0000495F  4D6F 6465 
00004963  00        
                    7067   @m68kde~1_107:
00004964  0D0A 2020 7068          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00004968  544D 2020 
0000496C  2020 2020 
00004970  2020 20   
00004973  2020 2D20 7069          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00004977  5465 7374 
0000497B  204D 656D 
0000497F  6F        
00004980  7279 00   7070          dc.b      114,121,0
                    7071   @m68kde~1_108:
00004984  0D0A 2020 7072          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00004988  5453 2020 
0000498C  2020 2020 
00004990  2020 20   
00004993  2020 2D20 7073          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00004997  5465 7374 
0000499B  2053 7769 
0000499F  74        
000049A0  6368 6573 7074          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
000049A4  3A20 5357 
000049A8  372D 3000 
                    7075   @m68kde~1_109:
000049AC  0D0A 2020 7076          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
000049B0  5444 2020 
000049B4  2020 2020 
000049B8  2020 20   
000049BB  2020 2D20 7077          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
000049BF  5465 7374 
000049C3  2044 6973 
000049C7  70        
000049C8  6C61 7973 7078          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
000049CC  3A20 4C45 
000049D0  4473 2061 
000049D4  6E        
000049D5  6420 372D 7079          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
000049D9  5365 676D 
000049DD  656E 7400 
                    7080   @m68kde~1_110:
000049E2  0D0A 2020 7081          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
000049E6  5744 2F57 
000049EA  532F 5743 
000049EE  2F57 4B   
000049F1  2020 2D20 7082          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
000049F5  5761 7463 
000049F9  6820 506F 
000049FD  696E      
000049FF  743A 2044 7083          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00004A03  6973 706C 
00004A07  6179 2F53 
00004A0B  65        
00004A0C  742F 436C 7084          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00004A10  6561 722F 
00004A14  4B69 6C6C 
00004A18  00        
                    7085   @m68kde~1_111:
00004A1A  0D0A 2300 7086          dc.b      13,10,35,0
                    7087   @m68kde~1_112:
00004A1E  0D0A 5072 7088          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00004A22  6F67 7261 
00004A26  6D20 5275 
00004A2A  6E        
00004A2B  6E69 6E67 7089          dc.b      110,105,110,103,46,46,46,46,46,0
00004A2F  2E2E 2E2E 
00004A33  2E00      
                    7090   @m68kde~1_113:
00004A36  0D0A 5072 7091          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00004A3A  6573 7320 
00004A3E  3C52 4553 
00004A42  4554      
00004A44  3E20 6275 7092          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00004A48  7474 6F6E 
00004A4C  203C 4B65 
00004A50  79        
00004A51  303E 206F 7093          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00004A55  6E20 4445 
00004A59  3120 746F 
00004A5D  2073      
00004A5F  746F 7000 7094          dc.b      116,111,112,0
                    7095   @m68kde~1_114:
00004A64  0D0A 4572 7096          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00004A68  726F 723A 
00004A6C  2050 7265 
00004A70  73        
00004A71  7320 2747 7097          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00004A75  2720 6669 
00004A79  7273 7420 
00004A7D  74        
00004A7E  6F20 7374 7098          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00004A82  6172 7420 
00004A86  7072 6F67 
00004A8A  7261 6D00 7099          dc.b      114,97,109,0
                    7100   @m68kde~1_115:
00004A8E  0D0A 5369 7101          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004A92  6E67 6C65 
00004A96  2053 7465 
00004A9A  70        
00004A9B  2020 3A5B 7102          dc.b      32,32,58,91,79,78,93,0
00004A9F  4F4E 5D00 
                    7103   @m68kde~1_116:
00004AA4  0D0A 5072 7104          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00004AA8  6573 7320 
00004AAC  2747 2720 
00004AB0  74        
00004AB1  6F20 5472 7105          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00004AB5  6163 6520 
00004AB9  5072 6F67 
00004ABD  72        
00004ABE  616D 2066 7106          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00004AC2  726F 6D20 
00004AC6  6164 6472 
00004ACA  6573 7320 7107          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00004ACE  2425 582E 
00004AD2  2E2E 2E2E 
00004AD6  00        
                    7108   @m68kde~1_117:
00004AD8  0D0A 5075 7109          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00004ADC  7368 203C 
00004AE0  5245 5345 
00004AE4  5420      
00004AE6  4275 7474 7110          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00004AEA  6F6E 3E20 
00004AEE  746F 2053 
00004AF2  74        
00004AF3  6F70 2E2E 7111          dc.b      111,112,46,46,46,46,46,0
00004AF7  2E2E 2E00 
                    7112   @m68kde~1_118:
00004AFC  0D0A 5369 7113          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004B00  6E67 6C65 
00004B04  2053 7465 
00004B08  70        
00004B09  203A 205B 7114          dc.b      32,58,32,91,79,70,70,93,0
00004B0D  4F46 465D 
00004B11  00        
                    7115   @m68kde~1_119:
00004B12  0D0A 4272 7116          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00004B16  6561 6B20 
00004B1A  506F 696E 
00004B1E  74        
00004B1F  7320 3A5B 7117          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00004B23  456E 6162 
00004B27  6C65 645D 
00004B2B  00        
                    7118   @m68kde~1_120:
00004B2C  0D0A 5072 7119          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00004B30  6573 7320 
00004B34  3C45 5343 
00004B38  3E20      
00004B3A  746F 2052 7120          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00004B3E  6573 756D 
00004B42  6520 5573 
00004B46  6572 2050 7121          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00004B4A  726F 6772 
00004B4E  616D 2E2E 
00004B52  2E        
00004B53  2E2E 00   7122          dc.b      46,46,0
                    7123   @m68kde~1_121:
00004B56  0D0A 5369 7124          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00004B5A  6E67 6C65 
00004B5E  2053 7465 
00004B62  70        
00004B63  2020 3A5B 7125          dc.b      32,32,58,91,79,70,70,93,0
00004B67  4F46 465D 
00004B6B  00        
                    7126   @m68kde~1_122:
00004B6C  0D0A 0D0A 7127          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004B70  5072 6F67 
00004B74  7261 6D20 
00004B78  41        
00004B79  424F 5254 7128          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00004B7D  2021 2121 
00004B81  2121 210D 
00004B85  0A00      
                    7129   @m68kde~1_123:
00004B88  2573 0D0A 7130          dc.b      37,115,13,10,0
00004B8C  00        
                    7131   @m68kde~1_124:
00004B8E  0D0A 0D0A 7132          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00004B92  5072 6F67 
00004B96  7261 6D20 
00004B9A  41        
00004B9B  424F 5254 7133          dc.b      66,79,82,84,32,33,33,33,33,33,0
00004B9F  2021 2121 
00004BA3  2121 00   
                    7134   @m68kde~1_125:
00004BA6  0D0A 556E 7135          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00004BAA  6861 6E64 
00004BAE  6C65 6420 
00004BB2  49        
00004BB3  6E74 6572 7136          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00004BB7  7275 7074 
00004BBB  3A20 4952 
00004BBF  5125 6420 7137          dc.b      81,37,100,32,33,33,33,33,33,0
00004BC3  2121 2121 
00004BC7  2100      
                    7138   @m68kde~1_126:
00004BCA  4144 4452 7139          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00004BCE  4553 5320 
00004BD2  4552 524F 
00004BD6  523A 20   
00004BD9  3136 206F 7140          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00004BDD  7220 3332 
00004BE1  2042 6974 
00004BE5  2054      
00004BE7  7261 6E73 7141          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00004BEB  6665 7220 
00004BEF  746F 2F66 
00004BF3  726F 6D20 7142          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00004BF7  616E 204F 
00004BFB  4444 2041 
00004BFF  64        
00004C00  6472 6573 7143          dc.b      100,114,101,115,115,46,46,46,46,0
00004C04  732E 2E2E 
00004C08  2E00      
                    7144   @m68kde~1_127:
00004C0A  556E 6861 7145          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00004C0E  6E64 6C65 
00004C12  6420 5472 
00004C16  6170 2021 7146          dc.b      97,112,32,33,33,33,33,33,0
00004C1A  2121 2121 
00004C1E  00        
                    7147   @m68kde~1_128:
00004C20  4255 5320 7148          dc.b      66,85,83,32,69,114,114,111,114,33,0
00004C24  4572 726F 
00004C28  7221 00   
                    7149   @m68kde~1_129:
00004C2C  4144 4452 7150          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00004C30  4553 5320 
00004C34  4572 726F 
00004C38  7221      
00004C3A  00        7151          dc.b      0
                    7152   @m68kde~1_130:
00004C3C  494C 4C45 7153          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00004C40  4741 4C20 
00004C44  494E 5354 
00004C48  5255 43   
00004C4B  5449 4F4E 7154          dc.b      84,73,79,78,0
00004C4F  00        
                    7155   @m68kde~1_131:
00004C50  4449 5649 7156          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00004C54  4445 2042 
00004C58  5920 5A45 
00004C5C  524F 00   
                    7157   @m68kde~1_132:
00004C60  2743 484B 7158          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00004C64  2720 494E 
00004C68  5354 5255 
00004C6C  4354 49   
00004C6F  4F4E 00   7159          dc.b      79,78,0
                    7160   @m68kde~1_133:
00004C72  5452 4150 7161          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00004C76  5620 494E 
00004C7A  5354 5255 
00004C7E  4354 49   
00004C81  4F4E 00   7162          dc.b      79,78,0
                    7163   @m68kde~1_134:
00004C84  5052 4956 7164          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00004C88  494C 4547 
00004C8C  4520 5649 
00004C90  4F4C 41   
00004C93  5449 4F4E 7165          dc.b      84,73,79,78,0
00004C97  00        
                    7166   @m68kde~1_135:
00004C98  554E 494E 7167          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00004C9C  4954 4941 
00004CA0  4C49 5345 
00004CA4  4420 49   
00004CA7  5251 00   7168          dc.b      82,81,0
                    7169   @m68kde~1_136:
00004CAA  5350 5552 7170          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00004CAE  494F 5553 
00004CB2  2049 5251 
00004CB6  00        
                    7171   @m68kde~1_137:
00004CB8  0D0A 5374 7172          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00004CBC  6172 7420 
00004CC0  4164 6472 
00004CC4  65        
00004CC5  7373 2069 7173          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00004CC9  6E20 4D65 
00004CCD  6D6F 7279 
00004CD1  3A20 00   7174          dc.b      58,32,0
                    7175   @m68kde~1_138:
00004CD4  0D0A 456E 7176          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00004CD8  7465 7220 
00004CDC  5374 7269 
00004CE0  6E        
00004CE1  6720 2845 7177          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00004CE5  5343 2074 
00004CE9  6F20 656E 
00004CED  64        
00004CEE  2920 3A00 7178          dc.b      41,32,58,0
                    7179   @m68kde~1_139:
00004CF2  0D0A 5468 7180          dc.b      13,10,84,104,105,115,32,105,115,32,116,104,101
00004CF6  6973 2069 
00004CFA  7320 7468 
00004CFE  65        
00004CFF  2063 6F64 7181          dc.b      32,99,111,100,101,32,102,111,114,32,116,104
00004D03  6520 666F 
00004D07  7220 7468 
00004D0B  6520 7465 7182          dc.b      101,32,116,101,115,116,46,0
00004D0F  7374 2E00 
                    7183   @m68kde~1_140:
00004D14  0D0A 576F 7184          dc.b      13,10,87,111,117,108,100,32,121,111,117,32,108
00004D18  756C 6420 
00004D1C  796F 7520 
00004D20  6C        
00004D21  696B 6520 7185          dc.b      105,107,101,32,116,111,32,99,97,114,114,121
00004D25  746F 2063 
00004D29  6172 7279 
00004D2D  206F 7574 7186          dc.b      32,111,117,116,32,116,104,101,32,116,101,115
00004D31  2074 6865 
00004D35  2074 6573 
00004D39  7420 666F 7187          dc.b      116,32,102,111,114,32,98,121,116,101,115,44
00004D3D  7220 6279 
00004D41  7465 732C 
00004D45  2077 6F72 7188          dc.b      32,119,111,114,100,115,44,32,111,114,32,108
00004D49  6473 2C20 
00004D4D  6F72 206C 
00004D51  6F6E 6720 7189          dc.b      111,110,103,32,119,111,114,100,115,63,0
00004D55  776F 7264 
00004D59  733F 00   
                    7190   @m68kde~1_141:
00004D5C  0D0A 456E 7191          dc.b      13,10,69,110,116,101,114,32,65,32,102,111,114
00004D60  7465 7220 
00004D64  4120 666F 
00004D68  72        
00004D69  2062 7974 7192          dc.b      32,98,121,116,101,44,32,66,32,102,111,114,32
00004D6D  652C 2042 
00004D71  2066 6F72 
00004D75  20        
00004D76  776F 7264 7193          dc.b      119,111,114,100,115,44,32,67,32,102,111,114
00004D7A  732C 2043 
00004D7E  2066 6F72 
00004D82  206C 6F6E 7194          dc.b      32,108,111,110,103,32,119,111,114,100,115,58
00004D86  6720 776F 
00004D8A  7264 733A 
00004D8E  2000      7195          dc.b      32,0
                    7196   @m68kde~1_142:
00004D90  0D0A 204E 7197          dc.b      13,10,32,78,111,116,32,97,32,118,97,108,105
00004D94  6F74 2061 
00004D98  2076 616C 
00004D9C  69        
00004D9D  6420 696E 7198          dc.b      100,32,105,110,112,117,116,44,32,112,108,101
00004DA1  7075 742C 
00004DA5  2070 6C65 
00004DA9  6173 6520 7199          dc.b      97,115,101,32,116,114,121,32,97,103,97,105,110
00004DAD  7472 7920 
00004DB1  6167 6169 
00004DB5  6E        
00004DB6  2E00      7200          dc.b      46,0
                    7201   @m68kde~1_143:
00004DB8  0D0A 5069 7202          dc.b      13,10,80,105,99,107,32,116,104,101,32,102,111
00004DBC  636B 2074 
00004DC0  6865 2066 
00004DC4  6F        
00004DC5  6C6C 6F77 7203          dc.b      108,108,111,119,105,110,103,32,116,101,115,116
00004DC9  696E 6720 
00004DCD  7465 7374 
00004DD1  2064 6174 7204          dc.b      32,100,97,116,97,32,116,111,32,117,115,101,46
00004DD5  6120 746F 
00004DD9  2075 7365 
00004DDD  2E        
00004DDE  00        7205          dc.b      0
                    7206   @m68kde~1_144:
00004DE0  0D0A 456E 7207          dc.b      13,10,69,110,116,101,114,32,65,32,102,111,114
00004DE4  7465 7220 
00004DE8  4120 666F 
00004DEC  72        
00004DED  2035 352C 7208          dc.b      32,53,53,44,32,66,32,102,111,114,32,65,65,44
00004DF1  2042 2066 
00004DF5  6F72 2041 
00004DF9  412C      
00004DFB  2043 2066 7209          dc.b      32,67,32,102,111,114,32,70,70,44,32,68,32,102
00004DFF  6F72 2046 
00004E03  462C 2044 
00004E07  2066      
00004E09  6F72 2030 7210          dc.b      111,114,32,48,48,58,32,0
00004E0D  303A 2000 
                    7211   @m68kde~1_145:
00004E12  0D0A 5069 7212          dc.b      13,10,80,105,99,107,32,116,104,101,32,102,111
00004E16  636B 2074 
00004E1A  6865 2066 
00004E1E  6F        
00004E1F  6C6C 6F77 7213          dc.b      108,108,111,119,105,110,103,32,116,101,115,116
00004E23  696E 6720 
00004E27  7465 7374 
00004E2B  2064 6174 7214          dc.b      32,100,97,116,97,32,116,111,32,117,115,101,58
00004E2F  6120 746F 
00004E33  2075 7365 
00004E37  3A        
00004E38  00        7215          dc.b      0
                    7216   @m68kde~1_146:
00004E3A  0D0A 456E 7217          dc.b      13,10,69,110,116,101,114,32,65,32,102,111,114
00004E3E  7465 7220 
00004E42  4120 666F 
00004E46  72        
00004E47  2035 3535 7218          dc.b      32,53,53,53,53,44,32,66,32,102,111,114,32,65
00004E4B  352C 2042 
00004E4F  2066 6F72 
00004E53  2041      
00004E55  4141 412C 7219          dc.b      65,65,65,44,32,67,32,102,111,114,32,70,70,70
00004E59  2043 2066 
00004E5D  6F72 2046 
00004E61  4646      
00004E63  462C 2044 7220          dc.b      70,44,32,68,32,102,111,114,32,48,48,48,48,58
00004E67  2066 6F72 
00004E6B  2030 3030 
00004E6F  303A      
00004E71  2000      7221          dc.b      32,0
                    7222   @m68kde~1_147:
00004E74  0D0A 456E 7223          dc.b      13,10,69,110,116,101,114,32,65,32,102,111,114
00004E78  7465 7220 
00004E7C  4120 666F 
00004E80  72        
00004E81  2035 3535 7224          dc.b      32,53,53,53,53,32,53,53,53,53,44,32,66,32,102
00004E85  3520 3535 
00004E89  3535 2C20 
00004E8D  4220 66   
00004E90  6F72 2041 7225          dc.b      111,114,32,65,65,65,65,32,65,65,65,65,44,32
00004E94  4141 4120 
00004E98  4141 4141 
00004E9C  2C20      
00004E9E  4320 666F 7226          dc.b      67,32,102,111,114,32,66,66,66,70,32,70,70,70
00004EA2  7220 4242 
00004EA6  4246 2046 
00004EAA  4646      
00004EAC  462C 2044 7227          dc.b      70,44,32,68,32,102,111,114,32,48,48,48,48,32
00004EB0  2066 6F72 
00004EB4  2030 3030 
00004EB8  3020      
00004EBA  3030 3030 7228          dc.b      48,48,48,48,58,32,0
00004EBE  3A20 00   
                    7229   @m68kde~1_148:
00004EC2  0D0A 5370 7230          dc.b      13,10,83,112,101,99,105,102,121,32,115,116,97
00004EC6  6563 6966 
00004ECA  7920 7374 
00004ECE  61        
00004ECF  7274 2061 7231          dc.b      114,116,32,97,100,100,114,101,115,115,32,105
00004ED3  6464 7265 
00004ED7  7373 2069 
00004EDB  6E20 6865 7232          dc.b      110,32,104,101,120,97,100,101,99,105,109,97
00004EDF  7861 6465 
00004EE3  6369 6D61 
00004EE7  6C3A 2000 7233          dc.b      108,58,32,0
                    7234   @m68kde~1_149:
00004EEC  0D0A 5370 7235          dc.b      13,10,83,112,101,99,105,102,121,32,101,110,100
00004EF0  6563 6966 
00004EF4  7920 656E 
00004EF8  64        
00004EF9  2061 6464 7236          dc.b      32,97,100,100,114,101,115,115,32,105,110,32
00004EFD  7265 7373 
00004F01  2069 6E20 
00004F05  6865 7861 7237          dc.b      104,101,120,97,100,101,99,105,109,97,108,58
00004F09  6465 6369 
00004F0D  6D61 6C3A 
00004F11  2000      7238          dc.b      32,0
                    7239   @m68kde~1_150:
00004F14  0D0A 5772 7240          dc.b      13,10,87,114,105,116,105,110,103,32,116,111
00004F18  6974 696E 
00004F1C  6720 746F 
00004F20  2061 6464 7241          dc.b      32,97,100,100,114,101,115,115,46,46,46,46,46
00004F24  7265 7373 
00004F28  2E2E 2E2E 
00004F2C  2E        
00004F2D  00        7242          dc.b      0
                    7243   @m68kde~1_151:
00004F2E  0D0A 4361 7244          dc.b      13,10,67,97,110,110,111,116,32,119,114,105,116
00004F32  6E6E 6F74 
00004F36  2077 7269 
00004F3A  74        
00004F3B  6520 776F 7245          dc.b      101,32,119,111,114,100,32,116,111,32,97,100
00004F3F  7264 2074 
00004F43  6F20 6164 
00004F47  6472 6573 7246          dc.b      100,114,101,115,115,44,32,115,116,97,114,116
00004F4B  732C 2073 
00004F4F  7461 7274 
00004F53  696E 6720 7247          dc.b      105,110,103,32,97,100,100,114,101,115,115,32
00004F57  6164 6472 
00004F5B  6573 7320 
00004F5F  6D75 7374 7248          dc.b      109,117,115,116,32,98,101,32,108,101,115,115
00004F63  2062 6520 
00004F67  6C65 7373 
00004F6B  2074 6861 7249          dc.b      32,116,104,97,110,32,101,110,100,32,97,100,100
00004F6F  6E20 656E 
00004F73  6420 6164 
00004F77  64        
00004F78  7265 7373 7250          dc.b      114,101,115,115,46,0
00004F7C  2E00      
                    7251   @m68kde~1_152:
00004F7E  0D0A 5374 7252          dc.b      13,10,83,116,97,114,116,32,97,100,100,114,101
00004F82  6172 7420 
00004F86  6164 6472 
00004F8A  65        
00004F8B  7373 2074 7253          dc.b      115,115,32,116,101,115,116,101,100,58,32,37
00004F8F  6573 7465 
00004F93  643A 2025 
00004F97  7800      7254          dc.b      120,0
                    7255   @m68kde~1_153:
00004F9A  0D0A 456E 7256          dc.b      13,10,69,110,100,32,97,100,100,114,101,115,115
00004F9E  6420 6164 
00004FA2  6472 6573 
00004FA6  73        
00004FA7  2074 6573 7257          dc.b      32,116,101,115,116,101,100,58,32,37,120,0
00004FAB  7465 643A 
00004FAF  2025 7800 
                    7258   @m68kde~1_154:
00004FB4  0D0A 4361 7259          dc.b      13,10,67,97,110,110,111,116,32,119,114,105,116
00004FB8  6E6E 6F74 
00004FBC  2077 7269 
00004FC0  74        
00004FC1  6520 776F 7260          dc.b      101,32,119,111,114,100,32,116,111,32,97,100
00004FC5  7264 2074 
00004FC9  6F20 6164 
00004FCD  6472 6573 7261          dc.b      100,114,101,115,115,44,32,117,110,101,118,101
00004FD1  732C 2075 
00004FD5  6E65 7665 
00004FD9  6E20 6D65 7262          dc.b      110,32,109,101,109,111,114,121,32,97,100,100
00004FDD  6D6F 7279 
00004FE1  2061 6464 
00004FE5  7265 7373 7263          dc.b      114,101,115,115,105,110,103,46,0
00004FE9  696E 672E 
00004FED  00        
                    7264   @m68kde~1_155:
00004FEE  0D0A 2D2D 7265          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00004FF2  2D2D 2D2D 
00004FF6  2D2D 2D2D 
00004FFA  2D2D 2D   
00004FFD  2D2D 2D2D 7266          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005001  2D2D 2D2D 
00005005  2D2D 2D2D 
00005009  2D2D 2D   
0000500C  2D2D 2D2D 7267          dc.b      45,45,45,45,45,0
00005010  2D00      
                    7268   @m68kde~1_156:
00005012  0D0A 5465 7269          dc.b      13,10,84,101,115,116,32,110,117,109,98,101,114
00005016  7374 206E 
0000501A  756D 6265 
0000501E  72        
0000501F  2025 642E 7270          dc.b      32,37,100,46,46,46,0
00005023  2E2E 00   
                    7271   @m68kde~1_157:
00005026  0D0A 4661 7272          dc.b      13,10,70,97,105,108,101,100,32,116,111,32,119
0000502A  696C 6564 
0000502E  2074 6F20 
00005032  77        
00005033  7269 7465 7273          dc.b      114,105,116,101,32,116,111,32,97,100,100,114
00005037  2074 6F20 
0000503B  6164 6472 
0000503F  6573 7320 7274          dc.b      101,115,115,32,37,120,0
00005043  2578 00   
                    7275   @m68kde~1_158:
00005046  0D0A 5661 7276          dc.b      13,10,86,97,108,117,101,32,116,111,32,98,101
0000504A  6C75 6520 
0000504E  746F 2062 
00005052  65        
00005053  2077 7269 7277          dc.b      32,119,114,105,116,116,101,110,58,32,37,120
00005057  7474 656E 
0000505B  3A20 2578 
0000505F  00        7278          dc.b      0
                    7279   @m68kde~1_159:
00005060  0D0A 5661 7280          dc.b      13,10,86,97,108,117,101,32,114,101,97,100,58
00005064  6C75 6520 
00005068  7265 6164 
0000506C  3A        
0000506D  2025 7800 7281          dc.b      32,37,120,0
                    7282   @m68kde~1_160:
00005072  0D0A 4164 7283          dc.b      13,10,65,100,100,114,101,115,115,58,37,120,0
00005076  6472 6573 
0000507A  733A 2578 
0000507E  00        
                    7284   @m68kde~1_161:
00005080  0D0A 5661 7285          dc.b      13,10,86,97,108,117,101,32,97,116,32,115,112
00005084  6C75 6520 
00005088  6174 2073 
0000508C  70        
0000508D  6563 6966 7286          dc.b      101,99,105,102,105,101,100,32,97,100,100,114
00005091  6965 6420 
00005095  6164 6472 
00005099  6573 733A 7287          dc.b      101,115,115,58,32,37,120,0
0000509D  2025 7800 
                    7288   @m68kde~1_162:
000050A2  0D0A 5465 7289          dc.b      13,10,84,101,115,116,32,80,97,115,115,101,100
000050A6  7374 2050 
000050AA  6173 7365 
000050AE  64        
000050AF  00        7290          dc.b      0
                    7291   @m68kde~1_163:
000050B0  4445 312D 7292          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
000050B4  3638 6B20 
000050B8  4275 6720 
000050BC  5631      
000050BE  2E37 3700 7293          dc.b      46,55,55,0
                    7294   @m68kde~1_164:
000050C2  436F 7079 7295          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
000050C6  7269 6768 
000050CA  7420 2843 
000050CE  2920 504A 7296          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
000050D2  2044 6176 
000050D6  6965 7320 
000050DA  3230      
000050DC  3136 00   7297          dc.b      49,54,0
                    7298   @m68kde~1_165:
000050E0  0D0A 5275 7299          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
000050E4  6E6E 696E 
000050E8  672E 2E2E 
000050EC  2E        
000050ED  2E00      7300          dc.b      46,0
                    7301   @m68kde~1_166:
000050F0  5275 6E6E 7302          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
000050F4  696E 672E 
000050F8  2E2E 2E2E 
000050FC  00        
                    7303   @m68kde~1_167:
000050FE  4279 3A20 7304          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
00005102  504A 2044 
00005106  6176 6965 
0000510A  73        
0000510B  00        7305          dc.b      0
                    7306   @m68kde~1_168:
0000510C  0D0A 5669 7307          dc.b      13,10,86,105,99,116,111,114,32,83,104,101,117
00005110  6374 6F72 
00005114  2053 6865 
00005118  75        
00005119  6E67 2C20 7308          dc.b      110,103,44,32,77,97,115,111,110,32,68,117,97
0000511D  4D61 736F 
00005121  6E20 4475 
00005125  61        
00005126  6E00      7309          dc.b      110,0
                    7310   @m68kde~1_169:
00005128  0D0A 3533 7311          dc.b      13,10,53,51,49,55,54,49,53,51,44,32,49,57,57
0000512C  3137 3631 
00005130  3533 2C20 
00005134  3139 39   
00005137  3436 3338 7312          dc.b      52,54,51,56,51,0
0000513B  3300      
                    7313   @m68kde~1_170:
0000513E  0D0A 2573 7314          dc.b      13,10,37,115,0
00005142  00        
                    7315          section   data
00005144            7316                   align
          0000 5144 7317   DataStart       equ       *
                    7318   
                    7319   *********************************************************************************************************
                    7320   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    7321   * to ram as part of the CStart routine in this file
                    7322   *********************************************************************************************************
                    7323   
                    7324   _Write_Enable_Command:
00005144  0000 0006 7325          dc.l      6
                    7326   _Page_Program_Command:
00005148  0000 0002 7327          dc.l      2
                    7328   _Erase_Chip_Command:
0000514C  0000 00C7 7329          dc.l      199
                    7330   _Read_Status_Register_Command:
00005150  0000 0005 7331          dc.l      5
                    7332   _Read_Flash_Chip_Command:
00005154  0000 0003 7333          dc.l      3
                    7334   _First_Address_Byte:
00005158  0000 0000 7335          dc.l      0
                    7336   _Test_Data_Byte:
0000515C  0000 0009 7337          dc.l      9
                    7338   _Dummy_Data_Byte:
00005160  0000 00FF 7339          dc.l      255
                    7340   @itoa_1:
00005164  2D32 3134 7341          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00005168  3734 3833 
0000516C  3634 3800 
                    7342          section   bss
00005170            7343                   align
          0000 5170 7344   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    7345   
                    7346   *********************************************************************************************************
                    7347   * Section for Uninitialised Data held in ROM as constants
                    7348   *********************************************************************************************************
                    7349   
08030000            7350                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 002C 7351   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    7352   
                    7353   
08030000            7354   bss             org       bss
                    7355   
                    7356   *********************************************************************************************************
                    7357   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    7358   * install the exception handler using the C function InstallExceptionHandler()
                    7359   *********************************************************************************************************
                    7360   
                    7361   
                    7362   
08030000            7363   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
08030004            7364   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
08030008            7365   VBusError        ds.l    1      storage for address of Bus Error Handler
0803000C            7366   VAddressError    ds.l    1      storage for address of Address Error Handler
08030010            7367   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
08030014            7368   VDividebyZero    ds.l    1      storage for address of divide by zero handler
08030018            7369   VCheck           ds.l    1      ditto
0803001C            7370   VTrapV           ds.l    1      ditto
08030020            7371   VPrivilege       ds.l    1      ditto
08030024            7372   VTrace           ds.l    1
08030028            7373   VLine1010emul    ds.l    1
0803002C            7374   VLine1111emul    ds.l    1
08030030            7375   VUnassigned1     ds.l    1
08030034            7376   VUnassigned2     ds.l    1
08030038            7377   VUnassigned3     ds.l    1
0803003C            7378   VUninit_IRQ      ds.l    1
08030040            7379   VUnassigned4     ds.l    1
08030044            7380   VUnassigned5     ds.l    1
08030048            7381   VUnassigned6     ds.l    1
0803004C            7382   VUnassigned7     ds.l    1
08030050            7383   VUnassigned8     ds.l    1
08030054            7384   VUnassigned9     ds.l    1
08030058            7385   VUnassigned10    ds.l    1
0803005C            7386   VUnassigned11    ds.l    1
08030060            7387   VSpuriousIRQ     ds.l    1
                    7388   
                    7389   * Interrupt handlers Vector 25-31
08030064            7390   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030068            7391   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0803006C            7392   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030070            7393   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030074            7394   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
08030078            7395   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0803007C            7396   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7397   
                    7398   * Trap Handler vectors 32-47
08030080            7399   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030084            7400   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030088            7401   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0803008C            7402   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030090            7403   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030094            7404   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
08030098            7405   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0803009C            7406   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A0            7407   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A4            7408   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300A8            7409   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300AC            7410   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B0            7411   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B4            7412   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300B8            7413   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
080300BC            7414   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    7415   
                    7416   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    7417   
                    7418   ***********************************************************************************************************
                    7419   * Other Variables
                    7420   ***********************************************************************************************************
                    7421   *__DebugA5       ds.l    1
                    7422   *__UserA5        ds.l    1
                    7423   
                    7424   ***********************************************************************************************************
080300C0            7425   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
080300C4            7426   __allocp:       ds.l    0       ; start of allocation units
080300C4            7427   __heap:         ds.l    0       ; pointers for malloc functions
                    7428   
                    7429   *__himem:       ds.l    himem            ; highest memory location + 1
                    7430   *__stklen:      ds.l    stklen           ; default stack size
                    7431   
                    7432   *********************************************************************************************************
                    7433   * Section for Heap
                    7434   *********************************************************************************************************
                    7435   
                    7436   _i:
080300C4            7437          ds.b      4
                    7438   _x:
080300C8            7439          ds.b      4
                    7440   _y:
080300CC            7441          ds.b      4
                    7442   _z:
080300D0            7443          ds.b      4
                    7444   _PortA_Count:
080300D4            7445          ds.b      4
                    7446   _Trace:
080300D8            7447          ds.b      4
                    7448   _GoFlag:
080300DC            7449          ds.b      4
                    7450   _Echo:
080300E0            7451          ds.b      4
                    7452   _d0:
080300E4            7453          ds.b      4
                    7454   _d1:
080300E8            7455          ds.b      4
                    7456   _d2:
080300EC            7457          ds.b      4
                    7458   _d3:
080300F0            7459          ds.b      4
                    7460   _d4:
080300F4            7461          ds.b      4
                    7462   _d5:
080300F8            7463          ds.b      4
                    7464   _d6:
080300FC            7465          ds.b      4
                    7466   _d7:
08030100            7467          ds.b      4
                    7468   _a0:
08030104            7469          ds.b      4
                    7470   _a1:
08030108            7471          ds.b      4
                    7472   _a2:
0803010C            7473          ds.b      4
                    7474   _a3:
08030110            7475          ds.b      4
                    7476   _a4:
08030114            7477          ds.b      4
                    7478   _a5:
08030118            7479          ds.b      4
                    7480   _a6:
0803011C            7481          ds.b      4
                    7482   _PC:
08030120            7483          ds.b      4
                    7484   _SSP:
08030124            7485          ds.b      4
                    7486   _USP:
08030128            7487          ds.b      4
                    7488   _SR:
0803012C            7489          ds.b      2
                    7490   _BreakPointAddress:
0803012E            7491          ds.b      32
                    7492   _BreakPointInstruction:
0803014E            7493          ds.b      16
                    7494   _BreakPointSetOrCleared:
0803015E            7495          ds.b      32
                    7496   _InstructionSize:
0803017E            7497          ds.b      4
                    7498   _WatchPointAddress:
08030182            7499          ds.b      32
                    7500   _WatchPointSetOrCleared:
080301A2            7501          ds.b      32
                    7502   _WatchPointString:
080301C2            7503          ds.b      800
                    7504   _TempString:
080304E2            7505          ds.b      100
                    7506          section   heap
08030546            7507                   align
          0803 0546 7508   bssEnd          equ *                   end of storage space for unitialised variables
                    7509   *                                       we have to copy all initialised variable from rom to here at startup
          0803 0546 7510   heap   equ       *
08030546            7511                    align
          0000 0000

Assembly errors: 0
